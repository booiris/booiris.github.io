<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.147.7"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://booiris.space/wiki/leetcode/857.-minimum-cost-to-hire-k-workers/"><link rel=canonical href=https://booiris.space/wiki/leetcode/857.-minimum-cost-to-hire-k-workers/><link rel=apple-touch-icon href=/avatar.svg><link rel=icon href=/avatar.svg><link rel=shortcut href=/avatar.svg><link rel=alternate type=application/atom+xml href=https://booiris.space/index.xml title><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/booiris.space\/"},"articleSection":"wiki","name":"857. Minimum Cost to Hire K Workers","headline":"857. Minimum Cost to Hire K Workers","description":"题意 有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。\n现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：\n对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 题解 #![allow(dead_code, unused_imports, unused_macros)] use std::cmp::*; use std::collections::*; use std::ops::Bound::*; #[cfg(feature = \u0026#34;local\u0026#34;)] struct Solution; macro_rules! hashmap { ($( $key: expr =\u0026gt; $val: expr ),*) =\u0026gt; {{ let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map }} } impl Solution { pub fn mincost_to_hire_workers(quality: Vec\u0026lt;i32\u0026gt;, wage: Vec\u0026lt;i32\u0026gt;, k: i32) -\u0026gt; f64 { let mut key = quality .iter() .zip(wage.iter()) .map(|(\u0026amp;x, \u0026amp;y)| vec![x, y]) .collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); key.sort_unstable_by(|x, y| (x[1] * y[0]).cmp(\u0026amp;(x[0] * y[1]))); let mut q = BinaryHeap::new(); let mut sum = 0; for i in 0..(k - 1) as usize { q.push(key[i][0]); sum \u002b= key[i][0]; } let mut res: f64 = 1000000000.0; for i in (k - 1) as usize..key.len() { let temp = sum \u002b key[i][0]; res = res.min(temp as f64 \/ key[i][0] as f64 * key[i][1] as f64); if let Some(x) = q.peek() { if key[i][0] \u0026lt; *x { sum -= *x; q.pop(); q.push(key[i][0]); sum \u002b= key[i][0]; } } } res } } #[cfg(feature = \u0026#34;local\u0026#34;)] pub fn main() { let a = vec![3, 1, 10, 10, 1]; let b = vec![4, 8, 2, 2, 7]; println!(\u0026#34;res:{}\u0026#34;, Solution::mincost_to_hire_workers(a, b, 3)); } ","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2022","datePublished":"2022-09-11 16:10:05 \u002b0000 UTC","dateModified":"2022-09-11 16:10:05 \u002b0000 UTC","url":"https:\/\/booiris.space\/wiki\/leetcode\/857.-minimum-cost-to-hire-k-workers\/","keywords":["贪心","优先队列"]}</script><title>857. Minimum Cost to Hire K Workers</title><meta property="og:title" content="857. Minimum Cost to Hire K Workers"><meta property="og:type" content="article"><meta property="og:description" content='题意 有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。
现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：
对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 题解 #![allow(dead_code, unused_imports, unused_macros)] use std::cmp::*; use std::collections::*; use std::ops::Bound::*; #[cfg(feature = "local")] struct Solution; macro_rules! hashmap { ($( $key: expr => $val: expr ),*) => {{ let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map }} } impl Solution { pub fn mincost_to_hire_workers(quality: Vec<i32>, wage: Vec<i32>, k: i32) -> f64 { let mut key = quality .iter() .zip(wage.iter()) .map(|(&amp;x, &amp;y)| vec![x, y]) .collect::<Vec<_>>(); key.sort_unstable_by(|x, y| (x[1] * y[0]).cmp(&(x[0] * y[1]))); let mut q = BinaryHeap::new(); let mut sum = 0; for i in 0..(k - 1) as usize { q.push(key[i][0]); sum += key[i][0]; } let mut res: f64 = 1000000000.0; for i in (k - 1) as usize..key.len() { let temp = sum + key[i][0]; res = res.min(temp as f64 / key[i][0] as f64 * key[i][1] as f64); if let Some(x) = q.peek() { if key[i][0] < *x { sum -= *x; q.pop(); q.push(key[i][0]); sum += key[i][0]; } } } res } } #[cfg(feature = "local")] pub fn main() { let a = vec![3, 1, 10, 10, 1]; let b = vec![4, 8, 2, 2, 7]; println!("res:{}", Solution::mincost_to_hire_workers(a, b, 3)); } '><meta name=description content='题意 有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。
现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：
对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 题解 #![allow(dead_code, unused_imports, unused_macros)] use std::cmp::*; use std::collections::*; use std::ops::Bound::*; #[cfg(feature = "local")] struct Solution; macro_rules! hashmap { ($( $key: expr => $val: expr ),*) => {{ let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map }} } impl Solution { pub fn mincost_to_hire_workers(quality: Vec<i32>, wage: Vec<i32>, k: i32) -> f64 { let mut key = quality .iter() .zip(wage.iter()) .map(|(&amp;x, &amp;y)| vec![x, y]) .collect::<Vec<_>>(); key.sort_unstable_by(|x, y| (x[1] * y[0]).cmp(&(x[0] * y[1]))); let mut q = BinaryHeap::new(); let mut sum = 0; for i in 0..(k - 1) as usize { q.push(key[i][0]); sum += key[i][0]; } let mut res: f64 = 1000000000.0; for i in (k - 1) as usize..key.len() { let temp = sum + key[i][0]; res = res.min(temp as f64 / key[i][0] as f64 * key[i][1] as f64); if let Some(x) = q.peek() { if key[i][0] < *x { sum -= *x; q.pop(); q.push(key[i][0]); sum += key[i][0]; } } } res } } #[cfg(feature = "local")] pub fn main() { let a = vec![3, 1, 10, 10, 1]; let b = vec![4, 8, 2, 2, 7]; println!("res:{}", Solution::mincost_to_hire_workers(a, b, 3)); } '><meta property="og:locale" content="cn"><meta property="og:image" content="/avatar.svg"><link rel=stylesheet href=/css/index.min.css><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.min.css><link href=/%20index.xml rel=alternate type=application/rss+xml title><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css></head><body><article class="post 简体中文" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>HELLO WORLD</a></div><div class=header-subtitle>Live long and prosper.</div></header><div class="row end-md header-items"><div class=header-item><a href=/about>About</a></div><div class=header-item><a href=https://github.com/booiris target=_blank>Github</a></div><div class=header-item><a href=/memos>Memos</a></div></div><div class=row></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>857. Minimum Cost to Hire K Workers</h1></header><div class="post-content markdown-body"><h2 id=题意>题意</h2><p>有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。</p><p>现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：</p><ol><li>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。</li><li>工资组中的每名工人至少应当得到他们的最低期望工资。</li></ol><p>给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 </p><h2 id=题解>题解</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#57606a>#![allow(dead_code, unused_imports, unused_macros)]</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>use</span><span style=color:#fff> </span>std::cmp::<span style=color:#0550ae>*</span><span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>use</span><span style=color:#fff> </span>std::collections::<span style=color:#0550ae>*</span><span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>use</span><span style=color:#fff> </span>std::ops::Bound::<span style=color:#0550ae>*</span><span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#57606a>#[cfg(feature = </span><span style=color:#0a3069>&#34;local&#34;</span><span style=color:#57606a>)]</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>struct</span> <span style=color:#1f2328>Solution</span><span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span>macro_rules<span style=color:#0550ae>!</span><span style=color:#fff> </span>hashmap<span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>(</span><span style=color:#57606a>$(</span><span style=color:#fff> </span><span style=color:#57606a>$key</span>: <span style=color:#1f2328>expr</span><span style=color:#fff> </span><span style=color:#0550ae>=&gt;</span><span style=color:#fff> </span><span style=color:#57606a>$val</span>: <span style=color:#1f2328>expr</span><span style=color:#fff> </span><span style=color:#1f2328>),</span><span style=color:#0550ae>*</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#0550ae>=&gt;</span><span style=color:#fff> </span><span style=color:#1f2328>{{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>         </span><span style=color:#cf222e>let</span><span style=color:#fff> </span><span style=color:#cf222e>mut</span><span style=color:#fff> </span>map<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span>::std::collections::HashMap::new<span style=color:#1f2328>();</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>         </span><span style=color:#57606a>$(</span><span style=color:#fff> </span>map<span style=color:#1f2328>.</span>insert<span style=color:#1f2328>(</span><span style=color:#57606a>$key</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#57606a>$val</span><span style=color:#1f2328>);</span><span style=color:#fff> </span><span style=color:#1f2328>)</span><span style=color:#0550ae>*</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>         </span>map<span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>}}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>impl</span><span style=color:#fff> </span>Solution<span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>pub</span><span style=color:#fff> </span><span style=color:#cf222e>fn</span> <span style=color:#6639ba>mincost_to_hire_workers</span><span style=color:#1f2328>(</span>quality: <span style=color:#6639ba>Vec</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>i32</span><span style=color:#0550ae>&gt;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span>wage: <span style=color:#6639ba>Vec</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>i32</span><span style=color:#0550ae>&gt;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span>k: <span style=color:#cf222e>i32</span><span style=color:#1f2328>)</span><span style=color:#fff> </span>-&gt; <span style=color:#cf222e>f64</span> <span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>let</span><span style=color:#fff> </span><span style=color:#cf222e>mut</span><span style=color:#fff> </span>key<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span>quality<span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span><span style=color:#1f2328>.</span>iter<span style=color:#1f2328>()</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span><span style=color:#1f2328>.</span>zip<span style=color:#1f2328>(</span>wage<span style=color:#1f2328>.</span>iter<span style=color:#1f2328>())</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span><span style=color:#1f2328>.</span>map<span style=color:#1f2328>(</span><span style=color:#0550ae>|</span><span style=color:#1f2328>(</span><span style=color:#0550ae>&amp;</span>x<span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>&amp;</span>y<span style=color:#1f2328>)</span><span style=color:#0550ae>|</span><span style=color:#fff> </span><span style=color:#6639ba>vec!</span><span style=color:#1f2328>[</span>x<span style=color:#1f2328>,</span><span style=color:#fff> </span>y<span style=color:#1f2328>])</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span><span style=color:#1f2328>.</span>collect::<span style=color:#0550ae>&lt;</span><span style=color:#6639ba>Vec</span><span style=color:#0550ae>&lt;</span>_<span style=color:#0550ae>&gt;&gt;</span><span style=color:#1f2328>();</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span>key<span style=color:#1f2328>.</span>sort_unstable_by<span style=color:#1f2328>(</span><span style=color:#0550ae>|</span>x<span style=color:#1f2328>,</span><span style=color:#fff> </span>y<span style=color:#0550ae>|</span><span style=color:#fff> </span><span style=color:#1f2328>(</span>x<span style=color:#1f2328>[</span><span style=color:#0550ae>1</span><span style=color:#1f2328>]</span><span style=color:#fff> </span><span style=color:#0550ae>*</span><span style=color:#fff> </span>y<span style=color:#1f2328>[</span><span style=color:#0550ae>0</span><span style=color:#1f2328>]).</span>cmp<span style=color:#1f2328>(</span><span style=color:#0550ae>&amp;</span><span style=color:#1f2328>(</span>x<span style=color:#1f2328>[</span><span style=color:#0550ae>0</span><span style=color:#1f2328>]</span><span style=color:#fff> </span><span style=color:#0550ae>*</span><span style=color:#fff> </span>y<span style=color:#1f2328>[</span><span style=color:#0550ae>1</span><span style=color:#1f2328>])));</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>let</span><span style=color:#fff> </span><span style=color:#cf222e>mut</span><span style=color:#fff> </span>q<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span>BinaryHeap::new<span style=color:#1f2328>();</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>let</span><span style=color:#fff> </span><span style=color:#cf222e>mut</span><span style=color:#fff> </span>sum<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span><span style=color:#0550ae>0</span><span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>for</span><span style=color:#fff> </span>i<span style=color:#fff> </span><span style=color:#cf222e>in</span><span style=color:#fff> </span><span style=color:#0550ae>0</span><span style=color:#0550ae>..</span><span style=color:#1f2328>(</span>k<span style=color:#fff> </span><span style=color:#0550ae>-</span><span style=color:#fff> </span><span style=color:#0550ae>1</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#cf222e>as</span><span style=color:#fff> </span><span style=color:#cf222e>usize</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span>q<span style=color:#1f2328>.</span>push<span style=color:#1f2328>(</span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>0</span><span style=color:#1f2328>]);</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span>sum<span style=color:#fff> </span><span style=color:#0550ae>+=</span><span style=color:#fff> </span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>0</span><span style=color:#1f2328>];</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>let</span><span style=color:#fff> </span><span style=color:#cf222e>mut</span><span style=color:#fff> </span>res: <span style=color:#cf222e>f64</span> <span style=color:#0550ae>=</span><span style=color:#fff> </span><span style=color:#0550ae>1000000000.0</span><span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>for</span><span style=color:#fff> </span>i<span style=color:#fff> </span><span style=color:#cf222e>in</span><span style=color:#fff> </span><span style=color:#1f2328>(</span>k<span style=color:#fff> </span><span style=color:#0550ae>-</span><span style=color:#fff> </span><span style=color:#0550ae>1</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#cf222e>as</span><span style=color:#fff> </span><span style=color:#cf222e>usize</span><span style=color:#0550ae>..</span>key<span style=color:#1f2328>.</span>len<span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span><span style=color:#cf222e>let</span><span style=color:#fff> </span>temp<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span>sum<span style=color:#fff> </span><span style=color:#0550ae>+</span><span style=color:#fff> </span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>0</span><span style=color:#1f2328>];</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span>res<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span>res<span style=color:#1f2328>.</span>min<span style=color:#1f2328>(</span>temp<span style=color:#fff> </span><span style=color:#cf222e>as</span><span style=color:#fff> </span><span style=color:#cf222e>f64</span><span style=color:#fff> </span><span style=color:#0550ae>/</span><span style=color:#fff> </span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>0</span><span style=color:#1f2328>]</span><span style=color:#fff> </span><span style=color:#cf222e>as</span><span style=color:#fff> </span><span style=color:#cf222e>f64</span><span style=color:#fff> </span><span style=color:#0550ae>*</span><span style=color:#fff> </span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>1</span><span style=color:#1f2328>]</span><span style=color:#fff> </span><span style=color:#cf222e>as</span><span style=color:#fff> </span><span style=color:#cf222e>f64</span><span style=color:#1f2328>);</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span><span style=color:#cf222e>if</span><span style=color:#fff> </span><span style=color:#cf222e>let</span><span style=color:#fff> </span><span style=color:#6639ba>Some</span><span style=color:#1f2328>(</span>x<span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span>q<span style=color:#1f2328>.</span>peek<span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>                </span><span style=color:#cf222e>if</span><span style=color:#fff> </span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>0</span><span style=color:#1f2328>]</span><span style=color:#fff> </span><span style=color:#0550ae>&lt;</span><span style=color:#fff> </span><span style=color:#0550ae>*</span>x<span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>                    </span>sum<span style=color:#fff> </span><span style=color:#0550ae>-=</span><span style=color:#fff> </span><span style=color:#0550ae>*</span>x<span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>                    </span>q<span style=color:#1f2328>.</span>pop<span style=color:#1f2328>();</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>                    </span>q<span style=color:#1f2328>.</span>push<span style=color:#1f2328>(</span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>0</span><span style=color:#1f2328>]);</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>                    </span>sum<span style=color:#fff> </span><span style=color:#0550ae>+=</span><span style=color:#fff> </span>key<span style=color:#1f2328>[</span>i<span style=color:#1f2328>][</span><span style=color:#0550ae>0</span><span style=color:#1f2328>];</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>                </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>            </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span>res<span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#57606a>#[cfg(feature = </span><span style=color:#0a3069>&#34;local&#34;</span><span style=color:#57606a>)]</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>pub</span><span style=color:#fff> </span><span style=color:#cf222e>fn</span> <span style=color:#6639ba>main</span><span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>let</span><span style=color:#fff> </span>a<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span><span style=color:#6639ba>vec!</span><span style=color:#1f2328>[</span><span style=color:#0550ae>3</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>1</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>10</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>10</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>1</span><span style=color:#1f2328>];</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>let</span><span style=color:#fff> </span>b<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span><span style=color:#6639ba>vec!</span><span style=color:#1f2328>[</span><span style=color:#0550ae>4</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>8</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>2</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>2</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>7</span><span style=color:#1f2328>];</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#6639ba>println!</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;res:</span><span style=color:#0a3069>{}</span><span style=color:#0a3069>&#34;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span>Solution::mincost_to_hire_workers<span style=color:#1f2328>(</span>a<span style=color:#1f2328>,</span><span style=color:#fff> </span>b<span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>3</span><span style=color:#1f2328>));</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span></code></pre></div></div><div class="row middle-xs"><div class=col-xs-12><div class=post-tags><a href=/tags/%E8%B4%AA%E5%BF%83/>贪心</a></div><div class=post-tags><a href=/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/>优先队列</a></div></div></div><div class=site-footer></div></div></div></article><script src=/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script></body></html>