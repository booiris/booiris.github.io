<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.147.7"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://booiris.space/posts/blog/siphash/"><link rel=canonical href=https://booiris.space/posts/blog/siphash/><link rel=apple-touch-icon href=/avatar.svg><link rel=icon href=/avatar.svg><link rel=shortcut href=/avatar.svg><link rel=alternate type=application/atom+xml href=https://booiris.space/index.xml title><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/booiris.space\/"},"articleSection":"posts","name":"SipHash","headline":"SipHash","description":" 论文 eprint.iacr.org\/2012\/351.pdf\n代码位置 library\/core\/src\/hash\/sip.rs\nSipHash 是一类针对短消息设计的伪随机函数族，相较于其他的哈希函数有在短消息上性能高、由于随机输入的存在难以构造哈希 dos 攻击的优点，是 rust 、python 的内置哈希函数实现。\n实现 对于 SipHash-c-d 函数族，输入为一个 128 bit 的 k 和 可为空的输入 m，输出为一个 64 位长度的 SipHash-c-d(k,m)。其中 c 为 \u0026ldquo;compression rounds\u0026rdquo; 的次数， d 为 \u0026ldquo;finalization rounds\u0026rdquo; 的次数，\u0026ldquo;compression rounds\u0026rdquo; 和 \u0026ldquo;finalization rounds\u0026rdquo; 在之后中有说明具体的实现步骤。\n初始化 首先使用 k0、k1 初始化四个值 v0 、v1 、v2 、v3，其中 k0、k1 为 输入 k 的 64 位的小端编码 (也就是两个 u64 值 k0 、k1 组成了 k )。\n对于其中的常量，论文的选取解释为:\nThe initial state constant corresponds to the ASCII string \u0026ldquo;somepseudorandomlygeneratedbytes\u0026rdquo;, big-endian encoded.\n","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2023","datePublished":"2023-10-13 13:36:05 \u002b0000 UTC","dateModified":"2023-10-13 13:36:05 \u002b0000 UTC","url":"https:\/\/booiris.space\/posts\/blog\/siphash\/","keywords":["hash"]}</script><title>SipHash</title><meta property="og:title" content="SipHash"><meta property="og:type" content="article"><meta property="og:description" content=" 论文 eprint.iacr.org/2012/351.pdf
代码位置 library/core/src/hash/sip.rs
SipHash 是一类针对短消息设计的伪随机函数族，相较于其他的哈希函数有在短消息上性能高、由于随机输入的存在难以构造哈希 dos 攻击的优点，是 rust 、python 的内置哈希函数实现。
实现 对于 SipHash-c-d 函数族，输入为一个 128 bit 的 k 和 可为空的输入 m，输出为一个 64 位长度的 SipHash-c-d(k,m)。其中 c 为 &ldquo;compression rounds&rdquo; 的次数， d 为 &ldquo;finalization rounds&rdquo; 的次数，&ldquo;compression rounds&rdquo; 和 &ldquo;finalization rounds&rdquo; 在之后中有说明具体的实现步骤。
初始化 首先使用 k0、k1 初始化四个值 v0 、v1 、v2 、v3，其中 k0、k1 为 输入 k 的 64 位的小端编码 (也就是两个 u64 值 k0 、k1 组成了 k )。
对于其中的常量，论文的选取解释为:
The initial state constant corresponds to the ASCII string &ldquo;somepseudorandomlygeneratedbytes&rdquo;, big-endian encoded.
"><meta name=description content=" 论文 eprint.iacr.org/2012/351.pdf
代码位置 library/core/src/hash/sip.rs
SipHash 是一类针对短消息设计的伪随机函数族，相较于其他的哈希函数有在短消息上性能高、由于随机输入的存在难以构造哈希 dos 攻击的优点，是 rust 、python 的内置哈希函数实现。
实现 对于 SipHash-c-d 函数族，输入为一个 128 bit 的 k 和 可为空的输入 m，输出为一个 64 位长度的 SipHash-c-d(k,m)。其中 c 为 &ldquo;compression rounds&rdquo; 的次数， d 为 &ldquo;finalization rounds&rdquo; 的次数，&ldquo;compression rounds&rdquo; 和 &ldquo;finalization rounds&rdquo; 在之后中有说明具体的实现步骤。
初始化 首先使用 k0、k1 初始化四个值 v0 、v1 、v2 、v3，其中 k0、k1 为 输入 k 的 64 位的小端编码 (也就是两个 u64 值 k0 、k1 组成了 k )。
对于其中的常量，论文的选取解释为:
The initial state constant corresponds to the ASCII string &ldquo;somepseudorandomlygeneratedbytes&rdquo;, big-endian encoded.
"><meta property="og:locale" content="cn"><meta property="og:image" content="/avatar.svg"><link rel=stylesheet href=/css/index.min.css><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.min.css><link href=/%20index.xml rel=alternate type=application/rss+xml title><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css></head><body><article class="post 简体中文" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>HELLO WORLD</a></div><div class=header-subtitle>Live long and prosper.</div></header><div class="row end-md header-items"><div class=header-item><a href=/about>About</a></div><div class=header-item><a href=https://github.com/booiris>Github</a></div><div class=header-item><a href=/memos>Memos</a></div></div><div class=row></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>SipHash</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2023-10-13 13:36:05 UTC">13 Oct 2023</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><blockquote><p>论文 <a href=https://eprint.iacr.org/2012/351.pdf>eprint.iacr.org/2012/351.pdf</a></p></blockquote><blockquote><p>代码位置 <a href=https://github.com/rust-lang/rust/blob/1.72.0/library/core/src/hash/sip.rs>library/core/src/hash/sip.rs</a></p></blockquote><p>SipHash 是一类针对短消息设计的伪随机函数族，相较于其他的哈希函数有在短消息上性能高、由于随机输入的存在难以构造<a href=../todo/todo.md>哈希 dos 攻击</a>的优点，是 rust 、python 的内置哈希函数实现。</p><h2 id=实现>实现</h2><p>对于 SipHash-c-d 函数族，输入为一个 128 bit 的 <code>k</code> 和 可为空的输入 <code>m</code>，输出为一个 64 位长度的 <code>SipHash-c-d(k,m)</code>。其中 <code>c</code> 为 &ldquo;compression rounds&rdquo; 的次数， <code>d</code> 为 &ldquo;finalization rounds&rdquo; 的次数，&ldquo;compression rounds&rdquo; 和 &ldquo;finalization rounds&rdquo; 在之后中有说明具体的实现步骤。</p><h3 id=初始化>初始化</h3><p>首先使用 <code>k0</code>、<code>k1</code> 初始化四个值 <code>v0</code> 、<code>v1</code> 、<code>v2</code> 、<code>v3</code>，其中 <code>k0</code>、<code>k1</code> 为 输入 <code>k</code> 的 64 位的小端编码 (也就是两个 u64 值 <code>k0</code> 、<code>k1</code> 组成了 <code>k</code> )。</p><p>对于其中的常量，论文的选取解释为:</p><blockquote><p>The initial state constant corresponds to the ASCII string &ldquo;somepseudorandomlygeneratedbytes&rdquo;, big-endian encoded.</p></blockquote><p>论文中提出只需要满足 <code>v0</code> 和 <code>v1</code> 不同于 <code>v2</code> 和 <code>v3</code> 即可(也没分析为啥。。。)。</p><blockquote><p>the only requirement was some asymmetry so that the initial v0 and v1 differ from v2 and v3.</p></blockquote><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img/spihash1.png alt></p><h3 id=compression-round>Compression Round</h3><p>在初始化状态后，将输入的字符串进行编码，将输入的字符串以每 8 字节作为一组以小端序编码成 64 位的数 $m_i$ ，最后不够的用 0 做填充，最后一个字节的值为输入的字符串长度 $len \bmod 256$。具体来说，编码的过程如下图:</p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img/siphash_encode.png alt></p><p>在将输入 <code>s</code> 编码成 $m_0,m_1 \dots m_{\lceil \frac{(len+1)}{8} \rceil}$ 后，对于每个 $m_i$ 执行以下步骤，迭代执行完所有的输入后，<code>Compression Round</code> 完成。</p><p>$$
\begin{aligned}
v_3 \ \oplus = m_i \
SipRound(v_0,v_1,v_2,v_3)\ for\ c \ times \
v_0 \ \oplus = m_i
\end{aligned}
$$</p><p>PS: 巨💩🤡的是论文中的 &ldquo;For example, the one-byte input string m = ab is parsed as m0 = 01000000000000ab&rdquo;。开始我还以为输入的是字符串 &ldquo;ab&rdquo;，没看到 &ldquo;one-byte input&rdquo;，导致编码输入 m 这块卡了一会。感觉写成 &ldquo;0xab&rdquo; 和 &ldquo;0x01000000000000ab&rdquo; 会好一点🤡。</p><h3 id=finalization-round>Finalization Round</h3><p>在所有的输入字节处理在 <code>Compression Round</code> 处理完成后，将 $v_2$ 和常量 $0\mathrm{xff}$ (也是一个随机的非零值即可) 进行异或，再进行 <code>d</code> 轮 <code>SipRound</code> 之后，将 $v_0$ 、$v_1$、$v_2$、$v_3$ 进行异或和后得到最终的 64 位哈希值。</p><p>$$
\begin{aligned}
v_2 \ \oplus = 0\mathrm{xff} \
SipRound(v_0,v_1,v_2,v_3)\ for\ d \ times \
res = v_0 \oplus v_1 \oplus v_2 \oplus v_3
\end{aligned}
$$</p><h3 id=sipround>SipRound</h3><p>SipRound 的运算过程如下:</p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img/siphash_sipround1.png alt></p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img/spihash2.png alt></p><h2 id=安全性分析>安全性分析</h2><p>#todo</p><ul><li><input disabled type=checkbox> SipHash 安全性分析</li></ul></div><div class="row middle-xs"><div class=col-xs-12><div class=post-tags><a href=/categories/blog/>/blog</a></div><div class=post-tags><a href=/tags/hash/>hash</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer></div></div></div></article><script src=/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script></body></html>