<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.147.8"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://booiris.space/posts/blog/%E4%B8%BA%E5%95%A5-go-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/"><link rel=canonical href=https://booiris.space/posts/blog/%E4%B8%BA%E5%95%A5-go-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/><link rel=apple-touch-icon href=/avatar.svg><link rel=icon href=/avatar.svg><link rel=shortcut href=/avatar.svg><link rel=alternate type=application/atom+xml href=https://booiris.space/index.xml title><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/booiris.space\/"},"articleSection":"posts","name":"为啥 go 不支持泛型方法","headline":"为啥 go 不支持泛型方法","description":"引言 众所周知， go 的泛型并不完善，由于其不支持 parameterized methods (泛型方法)，导致其无法实现 monad、流式调用等等操作。在这个 issue 中 proposal: spec: allow parameterized methods in methods · Issue #49085 · golang\/go · GitHub 有着充分的讨论，本文旨在对其中的讨论进行总结(加一点指指点点)，找出 go 是 xx 的原因，如有错误恳请斧正。\n有点长的前置知识… 在看 issue 之前，首先介绍一下泛型的通常实现方式，一般有如下几种方式\n类型擦除\u002b虚函数表: 这是 Java 泛型的实现方式。在编译时，泛型类型信息会被擦除，所有的泛型被转换为基类 Object (在 go 中相当于将所有的类型变成 interface{} )，编译器同时会在必要时插入类型转换代码来确保类型安全。 模板实例化: C\u002b\u002b 使用模板来实现泛型。在编译时，模板会生成对应于每种具体类型的实例化代码。如 T add(T a, T b) 的泛型方法，对于 add(1,2) 和 add(1.0,2.0) 会生成两个函数 int add(int a, int b) 和 double add( double a, double b) 。 即时编译: How Generics Differ in Java and C# | HackerNoon, C#泛型详解 - 知乎, c# - What is reification? - Stack Overflow，从这些链接可以大致看出，c# 的泛型实现是编译时使用占位符表示泛型类型，然后在运行时动态实例化各种类型。 回到 go 的泛型，实际上 go 的泛型实现方式有三种提案，下面分别介绍这三种提案，有助于后续对 issue 中的讨论进行分析。(本来想简单写写的，写着写着太长了，不想看的请跳至 正文 部分)\n","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2024","datePublished":"2024-02-20 22:10:20 \u002b0000 UTC","dateModified":"2024-02-20 22:10:20 \u002b0000 UTC","url":"https:\/\/booiris.space\/posts\/blog\/%E4%B8%BA%E5%95%A5-go-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\/","keywords":[]}</script><title>为啥 go 不支持泛型方法</title><meta property="og:title" content="为啥 go 不支持泛型方法"><meta property="og:type" content="article"><meta property="og:description" content="引言 众所周知， go 的泛型并不完善，由于其不支持 parameterized methods (泛型方法)，导致其无法实现 monad、流式调用等等操作。在这个 issue 中 proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub 有着充分的讨论，本文旨在对其中的讨论进行总结(加一点指指点点)，找出 go 是 xx 的原因，如有错误恳请斧正。
有点长的前置知识… 在看 issue 之前，首先介绍一下泛型的通常实现方式，一般有如下几种方式
类型擦除+虚函数表: 这是 Java 泛型的实现方式。在编译时，泛型类型信息会被擦除，所有的泛型被转换为基类 Object (在 go 中相当于将所有的类型变成 interface{} )，编译器同时会在必要时插入类型转换代码来确保类型安全。 模板实例化: C++ 使用模板来实现泛型。在编译时，模板会生成对应于每种具体类型的实例化代码。如 T add(T a, T b) 的泛型方法，对于 add(1,2) 和 add(1.0,2.0) 会生成两个函数 int add(int a, int b) 和 double add( double a, double b) 。 即时编译: How Generics Differ in Java and C# | HackerNoon, C#泛型详解 - 知乎, c# - What is reification? - Stack Overflow，从这些链接可以大致看出，c# 的泛型实现是编译时使用占位符表示泛型类型，然后在运行时动态实例化各种类型。 回到 go 的泛型，实际上 go 的泛型实现方式有三种提案，下面分别介绍这三种提案，有助于后续对 issue 中的讨论进行分析。(本来想简单写写的，写着写着太长了，不想看的请跳至 正文 部分)
"><meta name=description content="引言 众所周知， go 的泛型并不完善，由于其不支持 parameterized methods (泛型方法)，导致其无法实现 monad、流式调用等等操作。在这个 issue 中 proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub 有着充分的讨论，本文旨在对其中的讨论进行总结(加一点指指点点)，找出 go 是 xx 的原因，如有错误恳请斧正。
有点长的前置知识… 在看 issue 之前，首先介绍一下泛型的通常实现方式，一般有如下几种方式
类型擦除+虚函数表: 这是 Java 泛型的实现方式。在编译时，泛型类型信息会被擦除，所有的泛型被转换为基类 Object (在 go 中相当于将所有的类型变成 interface{} )，编译器同时会在必要时插入类型转换代码来确保类型安全。 模板实例化: C++ 使用模板来实现泛型。在编译时，模板会生成对应于每种具体类型的实例化代码。如 T add(T a, T b) 的泛型方法，对于 add(1,2) 和 add(1.0,2.0) 会生成两个函数 int add(int a, int b) 和 double add( double a, double b) 。 即时编译: How Generics Differ in Java and C# | HackerNoon, C#泛型详解 - 知乎, c# - What is reification? - Stack Overflow，从这些链接可以大致看出，c# 的泛型实现是编译时使用占位符表示泛型类型，然后在运行时动态实例化各种类型。 回到 go 的泛型，实际上 go 的泛型实现方式有三种提案，下面分别介绍这三种提案，有助于后续对 issue 中的讨论进行分析。(本来想简单写写的，写着写着太长了，不想看的请跳至 正文 部分)
"><meta property="og:locale" content="cn"><meta property="og:image" content="/avatar.svg"><link rel=stylesheet href=/css/index.min.css><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.min.css><link href=/%20index.xml rel=alternate type=application/rss+xml title><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css></head><body><article class="post cn" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>KEEP SEEKING</a></div><div class=header-subtitle>Live long and prosper.</div></header><div class="row end-md header-items"><div class=header-item><a href=/>Home</a></div><div class=header-item><a href=/about>About</a></div><div class=header-item><a href=https://github.com/booiris target=_blank>Github</a></div><div class=header-item><a href=/memos>Memos</a></div></div><div class=row></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>为啥 go 不支持泛型方法</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2024-02-20 22:10:20 UTC">20 Feb 2024</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><h2 id=引言>引言</h2><p>众所周知， go 的泛型并不完善，由于其不支持 <code>parameterized methods</code> (泛型方法)，导致其无法实现 monad、流式调用等等操作。在这个 issue 中 <a href=https://github.com/golang/go/issues/49085>proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub</a> 有着充分的讨论，本文旨在对其中的讨论进行总结(加一点<del>指指点点</del>)，找出 go 是 xx 的原因，如有错误恳请斧正。</p><h2 id=有点长的前置知识>有点长的前置知识…</h2><p>在看 issue 之前，首先介绍一下泛型的通常实现方式，一般有如下几种方式</p><ol><li><strong>类型擦除+虚函数表</strong>: 这是 Java 泛型的实现方式。在编译时，泛型类型信息会被擦除，所有的泛型被转换为基类 Object (在 go 中相当于将所有的类型变成 interface{} )，编译器同时会在必要时插入类型转换代码来确保类型安全。</li><li><strong>模板实例化</strong>: C++ 使用模板来实现泛型。在编译时，模板会生成对应于每种具体类型的实例化代码。如 <code>T add(T a, T b) </code>的泛型方法，对于 <code>add(1,2)</code> 和 <code>add(1.0,2.0)</code> 会生成两个函数 <code>int add(int a, int b)</code> 和 <code>double add( double a, double b)</code> 。</li><li><strong>即时编译</strong>: <a href=https://hackernoon.com/how-generics-differ-in-java-and-c>How Generics Differ in Java and C# | HackerNoon</a>, <a href=https://zhuanlan.zhihu.com/p/348761322>C#泛型详解 - 知乎</a>, <a href=https://stackoverflow.com/questions/31876372/what-is-reification>c# - What is reification? - Stack Overflow</a>，从这些链接可以大致看出，c# 的泛型实现是编译时使用占位符表示泛型类型，然后在运行时动态实例化各种类型。</li></ol><p>回到 go 的泛型，实际上 go 的泛型实现方式有三种提案，下面分别介绍这三种提案，有助于后续对 issue 中的讨论进行分析。(本来想简单写写的，写着写着太长了，不想看的请跳至 <a href=/posts/blog/%E4%B8%BA%E5%95%A5-go-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/#%e6%ad%a3%e6%96%87>正文</a> 部分)</p><h3 id=stenciling>Stenciling</h3><p><a href=https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-stenciling.md>Generics implementation - Stenciling</a></p><p>首先是被称为蜡印(Stenciling) 的实现，实际上这个 c++、rust 的泛型实现方法很相似，都是在编译实例化所有的类型，生成多个对应类型的函数。</p><p>对于如下泛型函数:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#1f2328>T1</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>T2</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>](</span><span style=color:#1f2328>x</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#1f2328>T1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T2</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>存在如下两个调用:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>var</span> <span style=color:#1f2328>a</span> <span style=color:#cf222e>float64</span> <span style=color:#1f2328>=</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#cf222e>float64</span><span style=color:#1f2328>](</span><span style=color:#0550ae>7</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>8.0</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>var</span> <span style=color:#1f2328>b</span> <span style=color:#cf222e>struct</span><span style=color:#1f2328>{</span><span style=color:#1f2328>f</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>}</span> <span style=color:#1f2328>=</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#cf222e>complex128</span><span style=color:#1f2328>,</span> <span style=color:#cf222e>struct</span><span style=color:#1f2328>{</span><span style=color:#1f2328>f</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>}](</span><span style=color:#0550ae>3</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>1</span><span style=color:#0550ae>+</span><span style=color:#0550ae>1i</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>使用 Stenciling 方法会实例化两个类型函数用于调用:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#6639ba>f1</span><span style=color:#1f2328>(</span><span style=color:#1f2328>x</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>)</span> <span style=color:#cf222e>float64</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span> <span style=color:#1f2328>identical</span> <span style=color:#1f2328>bodies</span> <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#6639ba>f2</span><span style=color:#1f2328>(</span><span style=color:#1f2328>x</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#cf222e>complex128</span><span style=color:#1f2328>)</span> <span style=color:#cf222e>struct</span><span style=color:#1f2328>{</span><span style=color:#1f2328>f</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>}</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span> <span style=color:#1f2328>identical</span> <span style=color:#1f2328>bodies</span> <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>由于不是 go 泛型的实际实现，所以其中所提到的命名实现、实例化方法、类型约束和重复实例化代码处理就不细说了。具体提一下其中的问题部分。</p><h4 id=问题>问题</h4><p>对于 Stenciling 方法，提案提出两个问题:</p><ol><li>编译期实例化泛型导致编译时间变长</li><li>编译期实例化泛型导致生成的代码变多，生成的二进制文件变大，有可能导致 instruction cache miss 和 分支预测失效(为啥?)等问题。</li></ol><p>提案末尾中大致提出了使用增量编译减少编译时间、多次调用编译器来去除重复的实例化代码(因为 go 是以包维度进行编译的)等方案。不过这些都不重要，重要的是提案中的一段话:</p><blockquote><p>I suspect there will be lots of cases where sharing is possible, if the underlying types are indistinguishable w.r.t. the garbage collector (same size and ptr/nonptr layout)</p></blockquote><p>提案认为尽管类型可以有很多个(如 <code>int</code> 、<code>type IntAlias = int</code> )，但实际上内存布局都是相同的，相同内存布局的值类型可以共享代码，这就减少了生成的代码大小同时也加快了编译时间。实际上这就是 go 实际的泛型实现(GC Shape Stenciling) 。</p><h3 id=dictionaries>Dictionaries</h3><p><a href=https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-dictionaries.md>Generics implementation - Dictionaries</a></p><p>字典(Dictionaries)方式的实现方式正如其名，对于如下泛型函数:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#1f2328>T1</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>T2</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>](</span><span style=color:#1f2328>x</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#1f2328>T1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T2</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>存在如下两个调用:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>var</span> <span style=color:#1f2328>a</span> <span style=color:#cf222e>float64</span> <span style=color:#1f2328>=</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#cf222e>float64</span><span style=color:#1f2328>](</span><span style=color:#0550ae>7</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>8.0</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>var</span> <span style=color:#1f2328>b</span> <span style=color:#cf222e>struct</span><span style=color:#1f2328>{</span><span style=color:#1f2328>f</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>}</span> <span style=color:#1f2328>=</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#cf222e>complex128</span><span style=color:#1f2328>,</span> <span style=color:#cf222e>struct</span><span style=color:#1f2328>{</span><span style=color:#1f2328>f</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>}](</span><span style=color:#0550ae>3</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>1</span><span style=color:#0550ae>+</span><span style=color:#0550ae>1i</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>那么编译其会实例化<strong>一个</strong>函数，这个函数的第一个参数是一个字典。同时会有多个字典，每个字典包含一些运行时需要的信息，传入的字典内容由调用点生成和传入:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>pos1CallSiteDictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#0550ae>...</span> <span style=color:#1f2328>runtime</span><span style=color:#1f2328>.</span><span style=color:#1f2328>_type</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>pos2CallSiteDictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#0550ae>...</span> <span style=color:#1f2328>runtime</span><span style=color:#1f2328>.</span><span style=color:#1f2328>_type</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#6639ba>f</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>type_info</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>x</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#1f2328>T1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T2</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><h4 id=dictionary-包含的信息>dictionary 包含的信息</h4><p>对于形如 <code>f [T1, T2]</code> 的泛型函数，所需要的信息如下:</p><h5 id=instantiated-types>Instantiated types</h5><p>首先需要包含函数签名上的类型，可能以如下形式进行存储</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>dictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>T1</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>runtime</span><span style=color:#1f2328>.</span><span style=color:#1f2328>_type</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>T2</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>runtime</span><span style=color:#1f2328>.</span><span style=color:#1f2328>_type</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>出于打印栈的目的，字典中需要包含未被使用的类型，即即使 T2 没有在函数中用到也需要保存 T2 的类型 (为啥不禁止未使用的泛型类型呢…)。</p><h5 id=derived-types>Derived types</h5><p>除了函数签名上的类型，字典中还需要保存函数中派生出的类型，比如泛型函数中如果定义了如下类型:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>X</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span> <span style=color:#1f2328>x</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>;</span> <span style=color:#1f2328>y</span> <span style=color:#1f2328>T1</span> <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>m</span> <span style=color:#0550ae>:=</span> <span style=color:#cf222e>map</span><span style=color:#1f2328>[</span><span style=color:#cf222e>string</span><span style=color:#1f2328>]</span> <span style=color:#1f2328>T1</span><span style=color:#1f2328>{}</span>
</span></span></code></pre></div><p>那么需要保存派生出来的类型:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>dictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>D1</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>runtime</span><span style=color:#1f2328>.</span><span style=color:#1f2328>_type</span> <span style=color:#57606a>// struct { x int; y T1 }</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>D2</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>runtime</span><span style=color:#1f2328>.</span><span style=color:#1f2328>_type</span> <span style=color:#57606a>// map[string] T1</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><h5 id=subdictionaries>Subdictionaries</h5><p>如果泛型中函数调用了其他的泛型函数，还需要保存对应泛型函数的字典。这样才能接着传递 dictionary 参数，调用对应的泛型函数，提案中称之为子字典:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#57606a>//  func g[T](g T) { ... }</span>
</span></span><span style=display:flex><span><span style=color:#57606a>//  in f[T1]: g[T1] (y)</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>dictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>S1</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>dictionary</span> <span style=color:#57606a>// SubDictionary for call to g</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><h5 id=helper-methods>Helper methods</h5><p>字典中还需要保存泛型类型的操作符，比如对于如下运算:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#1f2328>y2</span> <span style=color:#0550ae>:=</span> <span style=color:#1f2328>y</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>1</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>if</span> <span style=color:#1f2328>y2</span> <span style=color:#1f2328>&gt;</span> <span style=color:#1f2328>y</span> <span style=color:#1f2328>{</span> <span style=color:#f6f8fa;background-color:#82071e>…</span> <span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>为了表达泛型操作，需要将其中的 <code>+</code> 和 <code>></code> 抽象出来变成一种方法保存到字典中:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>dictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>plus</span> <span style=color:#cf222e>func</span><span style=color:#1f2328>(</span><span style=color:#1f2328>z</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>x</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>T1</span><span style=color:#1f2328>)</span>      <span style=color:#57606a>// does *z = *x+*y</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>greater</span> <span style=color:#cf222e>func</span><span style=color:#1f2328>(</span><span style=color:#1f2328>x</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>T1</span><span style=color:#1f2328>)</span> <span style=color:#cf222e>bool</span> <span style=color:#57606a>// computes *x&gt;*y</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><h5 id=stack-layout>Stack layout</h5><p>因为类型不确定，字典中还需要保存函数中所有非指针类型临时变量的占用空间，用于分配栈空间。而之前提到过，字典是由调用点传入的，因为只有调用点才知道所有的类型，所以在调用点需要计算所需要的栈空间。然后字典中还需要保存每个临时对象在栈内的地址。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>dictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>frameSize</span> <span style=color:#cf222e>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>stackObjects</span> <span style=color:#1f2328>[]</span><span style=color:#1f2328>stackObject</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>stackObject</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>offset</span> <span style=color:#cf222e>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>typ</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>runtime</span><span style=color:#1f2328>.</span><span style=color:#1f2328>_type</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>对于泛型函数的嵌套调用也需要特殊处理。对于如下函数调用:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#1f2328>T1</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>T2</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>](</span><span style=color:#1f2328>x</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#1f2328>T1</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>h</span> <span style=color:#cf222e>func</span><span style=color:#1f2328>(</span><span style=color:#1f2328>x</span> <span style=color:#1f2328>T1</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>y</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>z</span> <span style=color:#1f2328>T2</span><span style=color:#1f2328>)</span> <span style=color:#cf222e>int</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T2</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>var</span> <span style=color:#1f2328>z</span> <span style=color:#1f2328>T2</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span><span style=color:#1f2328>.</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>r</span> <span style=color:#0550ae>:=</span> <span style=color:#6639ba>h</span><span style=color:#1f2328>(</span><span style=color:#1f2328>y</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>x</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>z</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>提案中提出了两种方法:</p><ol><li>逐个参数处理</li></ol><p>逐个处理参数，将参数复制到栈上正确的位置:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#1f2328>argPtr</span> <span style=color:#1f2328>=</span> <span style=color:#1f2328>SP</span>
</span></span><span style=display:flex><span><span style=color:#6639ba>memmove</span><span style=color:#1f2328>(</span><span style=color:#1f2328>argPtr</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>&amp;</span><span style=color:#1f2328>y</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>T1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>size</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>argPtr</span> <span style=color:#0550ae>+=</span> <span style=color:#1f2328>T1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>size</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>argPtr</span> <span style=color:#1f2328>=</span> <span style=color:#6639ba>roundUp</span><span style=color:#1f2328>(</span><span style=color:#1f2328>argPtr</span><span style=color:#1f2328>,</span> <span style=color:#6639ba>alignof</span><span style=color:#1f2328>(</span><span style=color:#cf222e>int</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>*</span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span><span style=color:#cf222e>int</span><span style=color:#1f2328>)</span><span style=color:#1f2328>argPtr</span> <span style=color:#1f2328>=</span> <span style=color:#1f2328>x</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>argPtr</span> <span style=color:#0550ae>+=</span> <span style=color:#6639ba>sizeof</span><span style=color:#1f2328>(</span><span style=color:#cf222e>int</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#6639ba>memmove</span><span style=color:#1f2328>(</span><span style=color:#1f2328>argPtr</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>&amp;</span><span style=color:#1f2328>z</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>T2</span><span style=color:#1f2328>.</span><span style=color:#1f2328>size</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>argPtr</span> <span style=color:#0550ae>+=</span> <span style=color:#1f2328>T2</span><span style=color:#1f2328>.</span><span style=color:#1f2328>size</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>call</span> <span style=color:#1f2328>h</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>argPtr</span> <span style=color:#1f2328>=</span> <span style=color:#6639ba>roundUp</span><span style=color:#1f2328>(</span><span style=color:#1f2328>argPtr</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>8</span><span style=color:#1f2328>)</span> <span style=color:#57606a>// alignment of return value start</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>r</span> <span style=color:#1f2328>=</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span><span style=color:#cf222e>int</span><span style=color:#1f2328>)</span><span style=color:#1f2328>argPtr</span>
</span></span></code></pre></div><ol start=2><li>使用字典存储偏移量</li></ol><p>或者提前计算出调用函数的入参出参在栈上的偏移量，然后保存到字典中，使用的时候根据偏移量复制参数:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6639ba>memmove</span><span style=color:#1f2328>(</span><span style=color:#1f2328>SP</span> <span style=color:#0550ae>+</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>callsite1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>arg1offset</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>&amp;</span><span style=color:#1f2328>y</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>T1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>size</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>*</span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span><span style=color:#cf222e>int</span><span style=color:#1f2328>)(</span><span style=color:#1f2328>SP</span> <span style=color:#0550ae>+</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>callsite1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>arg2offset</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>=</span> <span style=color:#1f2328>x</span>
</span></span><span style=display:flex><span><span style=color:#6639ba>memmove</span><span style=color:#1f2328>(</span><span style=color:#1f2328>SP</span> <span style=color:#0550ae>+</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>callsite1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>arg3offset</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>&amp;</span><span style=color:#1f2328>z</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>T2</span><span style=color:#1f2328>.</span><span style=color:#1f2328>size</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>call</span> <span style=color:#1f2328>h</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>r</span> <span style=color:#1f2328>=</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span><span style=color:#cf222e>int</span><span style=color:#1f2328>)(</span><span style=color:#1f2328>SP</span> <span style=color:#0550ae>+</span> <span style=color:#1f2328>dictionary</span><span style=color:#1f2328>.</span><span style=color:#1f2328>callsite1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>ret1offset</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><h5 id=pointer-maps>Pointer maps</h5><p>需要一个 bitMap 存储入参出参的空间大小和是否是指针类型。用于调用者分配空间入参和出参空间。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>dictionary</span> <span style=color:#cf222e>struct</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>argPointerMap</span> <span style=color:#1f2328>bitMap</span> <span style=color:#57606a>// arg size and ptr/nonptr bitmap</span>
</span></span><span style=display:flex><span>    <span style=color:#0550ae>...</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><h4 id=问题-1>问题</h4><p>提案中提到了虽然采用字典方法减少了代码的生成，但是占用的内存变多了（从上面也可以看出一个泛型示例要存储多少信息）。这也出现了 data cache misses 和 instruction cache misses 的替换。需要找一种折中的方法。</p><p>还有提案中提到使用字典方法也有可能导致性能的下降，比如当泛型方法中具体类型为 int 的情况，<code>x=y</code> 的操作在使用蜡印方法可以优化成一次寄存器复制的操作，而使用字典的方法，由于需要处理不同类型的数据，只能使用 <code>memmove</code> 操作复制数据，这无疑是一种额外的开销。</p><h3 id=gc-shape-stenciling>GC Shape Stenciling</h3><p><strong>！本节的分析基于提案和 go 1.18，部分信息可能和高版本的 go 有所不同，请注意区分。</strong></p><p><a href=https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-gcshape.md>Generics implementation - GC Shape Stenciling</a></p><p><a href=https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md>proposal/design/generics-implementation-dictionaries-go1.18.md at master · golang/proposal · GitHub</a></p><p>GC Shape Stenciling 是 go 的真正泛型实现。它是 Stenciling 和 Dictionaries 的折中实现。GC Shape 在提案中的解释是:</p><blockquote><p>The <em>GC shape</em> of a type means how that type appears to the allocator / garbage collector.</p></blockquote><p>举例来说 <code>int</code> 和 <code>type IntAlias = int</code> 是属于一个 GC Shape，比较特别的是对于所有的指针类型属于一个 GC Shape，使用虚表进行方法的调用。</p><p>对于每一个 GC Shape，go 会实例化一个具体的代码，具体来说，对于如下</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>package</span> <span style=color:#1f2328>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#1f2328>T</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>]</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>t</span> <span style=color:#1f2328>T</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#cf222e>var</span> <span style=color:#1f2328>x</span> <span style=color:#1f2328>T</span>
</span></span><span style=display:flex><span>	<span style=color:#cf222e>return</span> <span style=color:#1f2328>x</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>MyInt</span> <span style=color:#cf222e>int</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>IntAlias</span> <span style=color:#1f2328>=</span> <span style=color:#cf222e>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#6639ba>main</span><span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#cf222e>int</span><span style=color:#1f2328>](</span><span style=color:#0550ae>5</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#1f2328>MyInt</span><span style=color:#1f2328>](</span><span style=color:#0550ae>5</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#1f2328>IntAlias</span><span style=color:#1f2328>](</span><span style=color:#0550ae>5</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#0550ae>*</span><span style=color:#cf222e>int</span><span style=color:#1f2328>](</span><span style=color:#cf222e>nil</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#0550ae>*</span><span style=color:#1f2328>MyInt</span><span style=color:#1f2328>](</span><span style=color:#cf222e>nil</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>[</span><span style=color:#cf222e>interface</span><span style=color:#1f2328>{}](</span><span style=color:#cf222e>nil</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><h2 id=正文>正文</h2><p>下面终于来到 <a href=https://github.com/golang/go/issues/49085>issue</a> 分析环节。</p><p>首先是有人提出由于 go 的泛型不支持 <code>parameterized methods</code>，所以如下代码无法编译:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>si</span> <span style=color:#0550ae>*</span><span style=color:#1f2328>stream</span><span style=color:#1f2328>[</span><span style=color:#1f2328>IN</span><span style=color:#1f2328>])</span> <span style=color:#1f2328>Map</span><span style=color:#1f2328>[</span><span style=color:#1f2328>OUT</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>](</span><span style=color:#1f2328>f</span> <span style=color:#cf222e>func</span><span style=color:#1f2328>(</span><span style=color:#1f2328>IN</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>OUT</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>stream</span><span style=color:#1f2328>[</span><span style=color:#1f2328>OUT</span><span style=color:#1f2328>]</span>
</span></span></code></pre></div><p>这就导致了在 go 中无法实现常规的流式处理方法。提问人也提出如果 go 能支持 <code>parameterized methods</code>，那么某些领域在构造代码的时候会更加简便，例如(举的例子奇奇怪怪的，看着也没用到 <code>parameterized methods</code>):</p><ol><li>testing (?): <code>Assert(actual).ToBe(expected)</code></li><li>mocking (?): <code>On(obj.Sum).WithArgs(7, 8).ThenReturn(15)</code></li></ol><h3 id=原因>原因</h3><p>之后有人贴出 go 不支持 <code>parameterized methods</code> 的原因: <a href=https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods>parameterized methods Proposal</a>。考虑如下代码:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>package</span> <span style=color:#1f2328>p1</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>S</span> <span style=color:#cf222e>struct</span><span style=color:#1f2328>{}</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>S</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>Identity</span><span style=color:#1f2328>[</span><span style=color:#1f2328>T</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>]</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>v</span> <span style=color:#1f2328>T</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T</span> <span style=color:#1f2328>{</span> <span style=color:#cf222e>return</span> <span style=color:#1f2328>v</span> <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>package</span> <span style=color:#1f2328>p2</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>HasIdentity</span> <span style=color:#cf222e>interface</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>Identity</span><span style=color:#1f2328>[</span><span style=color:#1f2328>T</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>]</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>T</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>package</span> <span style=color:#1f2328>p3</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>import</span> <span style=color:#0a3069>&#34;p2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#6639ba>CheckIdentity</span><span style=color:#1f2328>(</span><span style=color:#1f2328>v</span> <span style=color:#cf222e>interface</span><span style=color:#1f2328>{})</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#cf222e>if</span> <span style=color:#1f2328>vi</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>ok</span> <span style=color:#0550ae>:=</span> <span style=color:#1f2328>v</span><span style=color:#1f2328>.(</span><span style=color:#1f2328>p2</span><span style=color:#1f2328>.</span><span style=color:#1f2328>HasIdentity</span><span style=color:#1f2328>);</span> <span style=color:#1f2328>ok</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>		<span style=color:#cf222e>if</span> <span style=color:#1f2328>got</span> <span style=color:#0550ae>:=</span> <span style=color:#1f2328>vi</span><span style=color:#1f2328>.</span><span style=color:#1f2328>Identity</span><span style=color:#1f2328>[</span><span style=color:#cf222e>int</span><span style=color:#1f2328>]</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>0</span><span style=color:#1f2328>);</span> <span style=color:#1f2328>got</span> <span style=color:#0550ae>!=</span> <span style=color:#0550ae>0</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>			<span style=color:#6639ba>panic</span><span style=color:#1f2328>(</span><span style=color:#1f2328>got</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>		<span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>package</span> <span style=color:#1f2328>p4</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>import</span> <span style=color:#1f2328>(</span>
</span></span><span style=display:flex><span>	<span style=color:#0a3069>&#34;p1&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#0a3069>&#34;p3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#6639ba>CheckSIdentity</span><span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>p3</span><span style=color:#1f2328>.</span><span style=color:#6639ba>CheckIdentity</span><span style=color:#1f2328>(</span><span style=color:#1f2328>p1</span><span style=color:#1f2328>.</span><span style=color:#1f2328>S</span><span style=color:#1f2328>{})</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>在上面的代码中，p1 中的 S 实现了 p2 中的 <code>HasIdentity</code> 接口，在 p3 中有一个函数实现了将入参断言为 <code>HasIdentity</code> 并调用其中的函数的功能。在 p4 中调用了 p3 中的函数并传入了 p1 中定义的 S。</p><p>看着还挺合理，但是问题来了，在 p3 中的 <code>CheckIdentity</code> 在断言完入参后，调用了一个类型为 <code>int</code> 的 <code>Identity</code> 函数。根据上面函数的调用链我们可以知道，它其实是在调用 <code>p1.S.Identity[int]</code>，只需要实例化一个 <code>p1.S.Identity[int]</code> 代码块即可。然而，由于 go 的<strong>大道至简</strong>，类型只有通过 import 才可见，也就是说 p3 是无法感知到 p1.S 这个类型的，所以实例化 <code>p1.S.Identity[int]</code> 也就无从说起了。</p><p>之后提案中给出了三个方案:</p><ol><li>编译器努努力，根据函数的调用链实例化对应的函数。然而由于 go 中的<strong>反射</strong>的存在，在编译期实际上无法确定所有的函数调用链 。(<strong>这个也是我感觉 go 支持 <code>parameterized methods</code> 里最难受的地方</strong>)</li><li>学习 java or C#，运行时实例化，这就导致了 go 需要支持某种 JIT，或者使用基于反射的方法，这些实现起来都十分复杂，而且会导致运行时速度变慢。</li><li>约束 interface 中禁用 <code>parameterized methods</code> ，因为无法感知类型的原因就是 interface 将实际类型信息隐藏了，不过还是存在反射的问题(直接禁止反射调用泛型函数?)：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span> <span style=color:#1f2328>S</span> <span style=color:#cf222e>struct</span><span style=color:#1f2328>{}</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>S</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>Identity</span><span style=color:#1f2328>[</span><span style=color:#1f2328>T</span> <span style=color:#cf222e>any</span><span style=color:#1f2328>]</span> <span style=color:#1f2328>(</span><span style=color:#1f2328>v</span> <span style=color:#1f2328>T</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>T</span> <span style=color:#1f2328>{</span> <span style=color:#cf222e>return</span> <span style=color:#1f2328>v</span> <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>func</span> <span style=color:#6639ba>main</span><span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>,</span> <span style=color:#1f2328>_</span> <span style=color:#0550ae>:=</span> <span style=color:#1f2328>reflect</span><span style=color:#1f2328>.</span><span style=color:#6639ba>TypeOf</span><span style=color:#1f2328>(</span><span style=color:#1f2328>S</span><span style=color:#1f2328>{}).</span><span style=color:#6639ba>MethodByName</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;Identity&#34;</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>f</span><span style=color:#1f2328>.</span><span style=color:#1f2328>Func</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Call</span><span style=color:#1f2328>([]</span><span style=color:#1f2328>reflect</span><span style=color:#1f2328>.</span><span style=color:#1f2328>Value</span><span style=color:#1f2328>{</span><span style=color:#1f2328>reflect</span><span style=color:#1f2328>.</span><span style=color:#6639ba>ValueOf</span><span style=color:#1f2328>(</span><span style=color:#1f2328>S</span><span style=color:#1f2328>{}),</span> <span style=color:#1f2328>reflect</span><span style=color:#1f2328>.</span><span style=color:#6639ba>ValueOf</span><span style=color:#1f2328>(</span><span style=color:#0550ae>0</span><span style=color:#1f2328>)})</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>在这里我想讲一讲第三点，提案给出的原文是:</p><blockquote><p>Or, we could decide that parameterized methods do not, in fact, implement interfaces, <em>but then it&rsquo;s much less clear why we need methods at all. If we disregard interfaces, any parameterized method can be implemented as a parameterized function.</em></p></blockquote><p>后面这一段真的是迷惑发言(issue 里有些人也对这段提出疑问)，提案作者认为如果 <code>parameterized methods</code> 不参与 interface 的实现（相当于在 interface 中禁用 <code>parameterized methods</code> 了）, 那为啥还需要 <code>parameterized method</code>，因为所有的 <code>parameterized method</code> 都可以用 <code>parameterized function</code> 实现？？？？</p><p>难不成作者认为 <code>func (S[T]) F[ M, U] ( M ) U</code> 可以简单等效为 <code>func F[T, M, U] (T, M) U</code> ，所以调用方式 <code>x.f(y).g(z)</code> 和 <code>g(f(x,y),z)</code> 没区别 🤔？那 go 语言写起来那么啰嗦的原因找到了(。 具体来说请看这个<a href=https://github.com/golang/go/issues/49085#issuecomment-995993517>评论</a> 和这个<a href=https://github.com/golang/go/issues/49085#issuecomment-1144311517>评论</a>。</p><p>后面作者的补充也很迷惑: <a href=https://github.com/golang/go/issues/49085#issuecomment-1291237249>proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub</a>，不予置评了。</p><h3 id=讨论>讨论</h3><p>由于之后的关于解决泛型方法的问题讨论太长，所以接下来省略部分评论(有些不是关于泛型的讨论)并且根据 issue 里提出的不同解决方案进行分类。</p><h4 id=gava派>gava派</h4><blockquote><p>I think that the example issue can be approached the same way as Java does: using <code>interface{}</code> behind the scenes and panic if the customer did a bad assignment (also the compiler could warn about the unsafe operation). &ndash;<a href=https://github.com/golang/go/issues/49085#issuecomment-986056824>link</a></p></blockquote><blockquote><p>How about using type erasure to handle the generic method issue? &ndash;<a href=https://github.com/golang/go/issues/49085#issuecomment-1857277699>link</a></p></blockquote><p>interface 代表一切！不过显然 gava 和 anygo 是不行滴。</p><h4 id=语法糖派投降派>语法糖派(投降派)</h4><blockquote><p>Maybe add some syntactic sugar like extension methods in C#. &ndash;<a href=https://github.com/golang/go/issues/49085#issuecomment-1064889791>link</a></p></blockquote><blockquote><p>Something similar that&rsquo;s been proposed before and is more explicit and thus feels, at least to me, more Go-like is to add a new operator, such as <code>-></code> or <code>|></code>, that chains functions such that <code>a -> f(b, c)</code> is equivalent to <code>f(a, b, c)</code>. That would allow the benefit of a method-like ordering to the execution without needing to actually support methods with extra types or method implementations for interface types. &ndash;<a href=https://github.com/golang/go/issues/49085#issuecomment-1278630794>link</a></p></blockquote><blockquote><p>For the solution <a href=https://github.com/golang/go/issues/49085#issuecomment-1464887534>#49085 (comment)</a>, the problem is that functions with <code>infix</code> are different from normal functions, and it may requires to write a function twice to provide both forms. I&rsquo;d like to have a new way to call a function at the right position of a value, like <a href=https://pkg.go.dev/text/template#hdr-Examples>using <code>|</code></a> in <code>template</code>. So I propose following: &ndash;<a href=https://github.com/golang/go/issues/49085#issuecomment-1600571377>link</a></p></blockquote><p>这一派对 go 语言的泛型彻底的妥协，不要求改变目前的泛型现状，只要求添加一个中缀调用的语法糖(不过这个也老早被 go 团队打了回去)。</p><p>在之前提到过，虽然不支持泛型方法 ， <code>func (S[T]) F[ M, U] ( M ) U</code> 也可以由 <code>func F[T, M, U] (T, M) U</code> 替换，但是随之而来的是深层次的调用嵌套，由原本的 <code>x.f(y).g(z)</code> 变成了 <code>g(f(x, y), z)</code> 。如果有一种中缀语法糖 <code>x -> f(y)</code> 表达 <code>f(x,y)</code>，那么 <code>g(f(x, y), z)</code> 就能变成 <code>x -> f(y) -> g(z)</code>，调用嵌套就没有了，流式调用看起来也能写了。(这很难评，加这种晦涩的函数式语法糖不如改进一下泛型)</p><h4 id=xx派想不出名字了>xx派(想不出名字了)</h4><p>首先因为 go 团队的 less is more 理念，让编译器做分析调用链这么重的活也不太现实（这里也辩解一下，即使调用链分析也无法覆盖反射、传 interface 调用、<a href=https://pkg.go.dev/plugin>插件模式</a>等场景，所以调用链分析是不现实的）。</p><p>但是禁用整个泛型方法也太过极端了，如果只禁用 interface 中的 <code>parameterized methods</code> ，而放过成员方法的 <code>parameterized methods</code> ，我认为有几点好处吧:</p><ol><li>最重要的一点是向下兼容，这种修改没有对 go 的语义有重大改变，同时是大范围约束到小范围约束的过程，不会影响以前的代码运行。</li><li><strong>可以用上 monad and stream call</strong> 。众所周知，合理地使用函数式能够减少临时变量和冗长的代码。有较大概率能减少下图中的代码(什么时候才能看到这张图不吐槽呢。。。)
<img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img/20231224210233.png alt></li><li>实现起来相对的不是特别复杂(相较于分析调用链来说)，因为泛型结构本身是可以具有方法的，也许可能再支持一个泛型方法相对来说没那么困难?</li></ol><p>以上为笔者个人观点。实际上，这一派为 issue 中大多数人的观点，其中有几位有较深入的讨论，下面对他们的讨论做下分析:</p><h6 id=一>一</h6><blockquote><p>I think this solution makes the most sense. They could then (under the hood) be treated a regular function. The reason why this would be useful is that methods do not only serve the purpose of implementing interfaces; methods also serve as a means of organization for functions that operate on particular structures.
It may be a bit of a challenge about how type-parameterized methods would appear in <code>"reflect"</code>, though. &ndash; <a href=https://github.com/golang/go/issues/49085#issuecomment-948108705>link</a></p></blockquote><p>把这段话放到第一个的原因是这是第一个提出这一派观点的人，还顺便吐槽了下提案中的 &ldquo;any parameterized method can be implemented as a parameterized function&rdquo;😚。</p><h5 id=二>二</h5><blockquote><p>I propose two constraints:</p><ol><li>Generic interfaces must be made &ldquo;concrete&rdquo; when used in a type assertion, within a type switch, and when invoking associated methods. By concrete, I mean that all type parameters on the generic interface are specified.</li><li>Types having generic method(s) cannot be typecast to <code>interface{}</code> or a generic interface unless it is an &ldquo;instantiated generic type&rdquo;. By instantiated generic type, I mean a type that has one or more generic method instantiations. &ndash; <a href=https://github.com/golang/go/issues/49085#issuecomment-1186380446>link</a></li></ol></blockquote><p>对于提案中提出的问题，这位提出了两个约束:</p><ol><li>泛型 interface 断言的时候必须指定具体类型。</li><li>具有泛型方法的类型除非</li></ol><p>在这段讨论中还对反射处理有所补充:</p><blockquote><p>On the reflect package, I propose we simply add a new &ldquo;<a href=https://go.dev/blog/laws-of-reflection>law of reflection</a>&rdquo; that says that any compile-time uninstantiated type realizations are unavailable at run-time. &ndash;<a href=https://github.com/golang/go/issues/49085#issuecomment-1186380446>link</a></p></blockquote><p>非常简单，就是检查泛型函数是否实例化，没有实例化的函数就是一调一个不吱声(panic 就完事了)。</p><h4 id=反对派>反对派</h4><p><a href=https://github.com/golang/go/issues/49085#issuecomment-948191212>proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href=https://github.com/golang/go/issues/49085#issuecomment-952701440>proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href=https://github.com/golang/go/issues/49085#issuecomment-1280087495>proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href=https://github.com/golang/go/issues/49085#issuecomment-1281552328>proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href=https://github.com/golang/go/issues/49085#issuecomment-1290043476>proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><h2 id=总结>总结</h2><p>考虑到 go 语言团队已经在泛型实现上已经<a href=https://github.com/golang/go/issues/49085#issuecomment-1290106303>考虑了 10 年</a>达到如今的成就，那么希望 go 团队能在不违反"<a href=https://github.com/golang/go/issues/49085#issuecomment-1291237249>泛型方法在 interface 中的正交性</a>🤗&ldquo;的约束下在下个 10 年实现泛型方法吧。在此之前，如果各位看官想使用泛型方法，请看下面评论(</p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240228131110.png alt></p></div><div class="row middle-xs"><div class=col-xs-12><div class=post-tags><a href=/categories/blog/>/blog</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer></div></div></div></article><script src=/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script></body></html>