<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.147.7"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://booiris.space/posts/sicp/sicp-%E7%AB%A0%E8%8A%821/"><link rel=canonical href=https://booiris.space/posts/sicp/sicp-%E7%AB%A0%E8%8A%821/><link rel=apple-touch-icon href=/avatar.svg><link rel=icon href=/avatar.svg><link rel=shortcut href=/avatar.svg><link rel=alternate type=application/atom+xml href=https://booiris.space/index.xml title><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/booiris.space\/"},"articleSection":"posts","name":"sicp 章节1","headline":"sicp 章节1","description":" 题解: SICP-learning\/exercise_1 at master · booiris\/SICP-learning · GitHub\n1. Building Abstractions With Procedures sicp 前面部分介绍的内容还是比较基础的，具体是在介绍程序是什么。\nWe are about to study the idea of a computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program.\n\u0026ndash; computational process (即计算过程) 是操作数据的过程，这一过程的实现由一组定义的规则(程序)完成。\n从中可以看出编写的计算机程序有两个重要的元素:\n数据 操作数据的行为 笔者认为我们编写的程序就是处理数据的过程，是对数据的各种加工变换(这就是为啥一个好的类型系统那么重要，土法炼钢不可取，此处@某一个大道至简的语言😚为啥 go 不支持泛型方法)。\n","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2024","datePublished":"2024-06-15 13:46:41 \u002b0000 UTC","dateModified":"2024-06-15 13:46:41 \u002b0000 UTC","url":"https:\/\/booiris.space\/posts\/sicp\/sicp-%E7%AB%A0%E8%8A%821\/","keywords":["sicp"]}</script><title>sicp 章节1</title><meta property="og:title" content="sicp 章节1"><meta property="og:type" content="article"><meta property="og:description" content=" 题解: SICP-learning/exercise_1 at master · booiris/SICP-learning · GitHub
1. Building Abstractions With Procedures sicp 前面部分介绍的内容还是比较基础的，具体是在介绍程序是什么。
We are about to study the idea of a computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program.
&ndash; computational process (即计算过程) 是操作数据的过程，这一过程的实现由一组定义的规则(程序)完成。
从中可以看出编写的计算机程序有两个重要的元素:
数据 操作数据的行为 笔者认为我们编写的程序就是处理数据的过程，是对数据的各种加工变换(这就是为啥一个好的类型系统那么重要，土法炼钢不可取，此处@某一个大道至简的语言😚为啥 go 不支持泛型方法)。
"><meta name=description content=" 题解: SICP-learning/exercise_1 at master · booiris/SICP-learning · GitHub
1. Building Abstractions With Procedures sicp 前面部分介绍的内容还是比较基础的，具体是在介绍程序是什么。
We are about to study the idea of a computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program.
&ndash; computational process (即计算过程) 是操作数据的过程，这一过程的实现由一组定义的规则(程序)完成。
从中可以看出编写的计算机程序有两个重要的元素:
数据 操作数据的行为 笔者认为我们编写的程序就是处理数据的过程，是对数据的各种加工变换(这就是为啥一个好的类型系统那么重要，土法炼钢不可取，此处@某一个大道至简的语言😚为啥 go 不支持泛型方法)。
"><meta property="og:locale" content="cn"><meta property="og:image" content="/avatar.svg"><link rel=stylesheet href=/css/index.min.css><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.min.css><link href=/%20index.xml rel=alternate type=application/rss+xml title><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css></head><body><article class="post cn" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>HELLO WORLD</a></div><div class=header-subtitle>Live long and prosper.</div></header><div class="row end-md header-items"><div class=header-item><a href=/about>About</a></div><div class=header-item><a href=https://github.com/booiris target=_blank>Github</a></div><div class=header-item><a href=/memos>Memos</a></div></div><div class=row></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>sicp 章节1</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2024-06-15 13:46:41 UTC">15 Jun 2024</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><blockquote><p>题解: <a href=https://github.com/booiris/SICP-learning/tree/master/exercise_1>SICP-learning/exercise_1 at master · booiris/SICP-learning · GitHub</a></p></blockquote><h2 id=1-building-abstractions-with-procedures>1. Building Abstractions With Procedures</h2><p>sicp 前面部分介绍的内容还是比较基础的，具体是在介绍程序是什么。</p><blockquote><p>We are about to study the idea of a <em>computational process</em>. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called <em>data</em>. The evolution of a process is directed by a pattern of rules called a <em>program</em>.</p><p>&ndash; <em>computational process</em> (即计算过程) 是操作数据的过程，这一过程的实现由一组定义的规则(程序)完成。</p></blockquote><p>从中可以看出编写的计算机程序有两个重要的元素:</p><ol><li>数据</li><li>操作数据的行为</li></ol><p>笔者认为我们编写的程序就是处理数据的过程，是对数据的各种加工变换(这就是为啥一个好的类型系统那么重要，土法炼钢不可取，此处@某一个大道至简的语言😚<a href=/posts/blog/%E4%B8%BA%E5%95%A5-go-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/>为啥 go 不支持泛型方法</a>)。</p><h3 id=11-the-elements-of-programming>1.1 The elements of Programming</h3><p>本节开始又到了最喜欢的概念定义环节，一个成熟的语言需要以下三种结构：</p><ol><li><strong>primitive expressions</strong>, which represent the simplest entities the language is concerned with,</li><li><strong>means of combination</strong>, by which compound elements are built from simpler ones, and</li><li><strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.</li></ol><p>具体来说就是需要</p><ol><li>基本表达式，表示语言中的一些基础的实体，比如变量和基本类型等</li><li>组合算子，能够从简单的元素构建出复杂的运算，比如运算符和函数调用等</li><li>抽象方式，能够将一组过程或者数据类型封装合并为一个单元，比如变量定义、函数定义和抽象数据类型的定义</li></ol><p>之后，文中再次强调了程序中最重要的两个元素，过程和数据(但实际上过程也可以认为是一种数据(有没有函数是一等公民的即视感) )：</p><blockquote><p>In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distinct.)</p></blockquote><h4 id=111-expressions>1.1.1 Expressions</h4><p>基本上是在通过介绍 lisp 中的一些语法来阐释 expressions 这一概念（不过 lisp 是前缀表达式还真是反直觉👾，当然把运算符当成函数调用看能好一点，也确实能更好表达函数复合等概念，但还是难受🤖）。</p><p>一些表达式例子:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#0550ae>123</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>1</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>1</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span> <span style=color:#0550ae>4</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>后面带运算符的表达式被称为组合式。</p><h4 id=112-naming-and-the-environment>1.1.2 Naming and the Environment</h4><p>介绍了 lisp 的变量定义方式，还捎带讲了下变量作用域的概念。</p><h4 id=113-evaluating-combinations>1.1.3 Evaluating Combinations</h4><p>介绍了 lisp 计算组合式的方式：</p><ol><li>计算组合式需要首先计算所有子表达式，是一个递归计算的过程。</li><li>自左向右计算值。</li></ol><p>计算组合式的过程构成了一个多叉树，计算组合式的过程就是计算一个个基本表达式的过程，而构成基本表达式的规则为：</p><ol><li>数值的值就是它们所代表的数字本身 (有点怪怪的，应该指的是 数值是最基本的元素，参与运算的实际上是具体的数值。比如计算 x=2， + x 1 时，实际上是计算 + 2 1，在计算的过程中变量已经替换为具体的值了)。</li><li>表达式中有一些基本内置运算符，对应着完成相应操作的机器指令。</li><li>表达式中还存在着一些变量，这些变量指向当前作用域中的一个特定对象。所以变量不能脱离作用域，单纯的 (+ x 1) 是无意义的，无法计算出它的值。</li></ol><h4 id=114-compound-procedures>1.1.4 Compound Procedures</h4><p>这一章介绍的是 lisp 中函数的定义方法，在文中被称为 &ldquo;<em>compound procedure</em>"。</p><p>lisp 的函数定义语法形式为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span> <span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>&lt;name&gt;</span> <span style=color:#953800>&lt;formal</span> <span style=color:#953800>parameters&gt;</span><span style=color:#1f2328>)</span> <span style=color:#953800>&lt;body&gt;</span> <span style=color:#1f2328>)</span>
</span></span></code></pre></div><h4 id=115-the-substitution-model-for-procedure-application>1.1.5 The Substitution Model for Procedure Application</h4><p>本章讲的是 lisp 计算自定函数的过程，和 <a href=/posts/sicp/sicp-%E7%AB%A0%E8%8A%821/#1.1.3%20Evaluating%20Combinations>1.1.3 Evaluating Combinations</a> 中计算组合式的过程类似。在本章中使用了 &ldquo;<em>substitution model</em>&rdquo; (替换)来解释运算过程。</p><p>例:</p><p>对于如下函数</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>square</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#953800>x</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>sum-of-squares</span> <span style=color:#953800>x</span> <span style=color:#953800>y</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#953800>square</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#953800>square</span> <span style=color:#953800>y</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>f</span> <span style=color:#953800>a</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>(</span><span style=color:#953800>sum-of-squares</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>a</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#953800>a</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>计算 <code>(f 5)</code> 的过程如下:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>f</span> <span style=color:#0550ae>5</span><span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>sum-of-squares</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>sum-of-squares</span> <span style=color:#0550ae>6</span> <span style=color:#0550ae>10</span><span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#953800>square</span> <span style=color:#0550ae>6</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#953800>square</span> <span style=color:#0550ae>10</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#0550ae>6</span> <span style=color:#0550ae>6</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#0550ae>10</span> <span style=color:#0550ae>10</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>36</span> <span style=color:#0550ae>100</span><span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>136</span>
</span></span></code></pre></div><p><em>substitution model</em> 就是将实际的运算式替换函数名的过程。但这并不是lisp 的实际运算过程。在后续 3、4、5 章会更详细地讲述这一过程。</p><h5 id=计算表达式的顺序>计算表达式的顺序</h5><p>在上面举例计算 <code>(f 5)</code> 的过程中可以发现，我们是在遇到可计算的基本表达式时就直接计算出对应的值。然而还有另一种计算的方式，就是在计算表达式的过程中只展开表达式，而不计算值，当整个表达式被展开成只由基本表达式组成时，再计算出值。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>f</span> <span style=color:#0550ae>5</span><span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>sum-of-squares</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#953800>square</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>))</span> <span style=color:#1f2328>(</span><span style=color:#953800>square</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#0550ae>5</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span> <span style=color:#953800>-&gt;</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>136</span>
</span></span></code></pre></div><p>这种完全展开的计算过程被称为 <em>normal-order evaluation</em> (正则序求值)，先求值再代入函数调用的被称为 <em>applicative-order evaluation</em> (应用序求值)。</p><p>lisp 中采用的是后面一种计算方式，部分原因在于其能够避免对表达式的重复求值。对于人类来说，完全展开然后计算从直觉上感觉就十分麻烦，但其也有特殊用处，可以用于处理无法求值的表达式，第三章讨论了使用正则式定义的流式过程，用于处理无限数据结构。</p><h4 id=116-conditional-expressions-and-predicates>1.1.6 Conditional Expressions and Predicates</h4><p>这一章介绍了 lisp 中的分支语法，语法形式为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>cond</span> <span style=color:#1f2328>(</span><span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>p</span><span style=color:#f6f8fa;background-color:#82071e>₁⟩</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>e</span><span style=color:#f6f8fa;background-color:#82071e>₁⟩</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>      <span style=color:#1f2328>(</span><span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>p</span><span style=color:#f6f8fa;background-color:#82071e>₂⟩</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>e</span><span style=color:#f6f8fa;background-color:#82071e>₂⟩</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f6f8fa;background-color:#82071e>…</span>
</span></span><span style=display:flex><span>      <span style=color:#1f2328>(</span><span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>pₙ</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>eₙ</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span><span style=color:#1f2328>))</span>
</span></span></code></pre></div><p>还有个 <code>if</code> 语法糖，语法形式为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>predicate</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>consequent</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>alternative</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>分支语法关联的逻辑运算符为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>and</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>e</span><span style=color:#f6f8fa;background-color:#82071e>₁⟩</span> <span style=color:#f6f8fa;background-color:#82071e>…</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>eₙ</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>or</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>e</span><span style=color:#f6f8fa;background-color:#82071e>₁⟩</span> <span style=color:#f6f8fa;background-color:#82071e>…</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>eₙ</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#6639ba>not</span> <span style=color:#f6f8fa;background-color:#82071e>⟨</span><span style=color:#953800>e</span><span style=color:#f6f8fa;background-color:#82071e>⟩</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><h4 id=117-example-square-roots-by-newtons-method>1.1.7 Example: Square Roots by Newton’s Method</h4><p>首先，如 <a href=/posts/sicp/sicp-%E7%AB%A0%E8%8A%821/#1.%20Building%20Abstractions%20With%20Procedures>1. Building Abstractions With Procedures</a> 中所言，<em>procedures</em> 是操作数据的过程，这很像常规的数学函数，通过输出一些值，经过一些运算然后得到一些值。但和数学上的函数不一样的点在于，程序中的函数必须是可行的。</p><p>以计算平方根为例，在数学上定义平方根 $y$ 为</p><p>$$ y = \sqrt{x} , \quad where \quad y \geq 0 \quad and \quad y^2 = x $$</p><p>非常的清晰，但也非常的抽象，这个函数只给出了什么是平方根函数(平方的逆函数)，但并没有给出怎么计算一个值的平方根。在书中提到这反映了说明性描述和过程性描述的区别，即使给出了一个函数的定义，但推出它的具体实现也是很困难的。</p><p>最常用的计算平方根的方法为牛顿迭代法，其过程用如下代码表示：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>sqrt-iter</span> <span style=color:#953800>guess</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#953800>good-enough?</span> <span style=color:#953800>guess</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>		<span style=color:#953800>guess</span>
</span></span><span style=display:flex><span>		<span style=color:#1f2328>(</span><span style=color:#953800>sqrt-iter</span> <span style=color:#1f2328>(</span><span style=color:#953800>improve</span> <span style=color:#953800>guess</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span> <span style=color:#953800>x</span><span style=color:#1f2328>)))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>improve</span> <span style=color:#953800>guess</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>(</span><span style=color:#953800>average</span> <span style=color:#953800>guess</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>/</span> <span style=color:#953800>x</span> <span style=color:#953800>guess</span><span style=color:#1f2328>)))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>average</span> <span style=color:#953800>x</span> <span style=color:#953800>y</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>(</span><span style=color:#6639ba>/</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>x</span> <span style=color:#953800>y</span><span style=color:#1f2328>)</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>good-enough?</span> <span style=color:#953800>guess</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>(</span><span style=color:#6639ba>&lt;</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>abs</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>-</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#953800>guess</span> <span style=color:#953800>guess</span><span style=color:#1f2328>)</span> <span style=color:#953800>x</span><span style=color:#1f2328>))</span> <span style=color:#0550ae>0.001</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>sqrt</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>	<span style=color:#1f2328>(</span><span style=color:#953800>sqrt-iter</span> <span style=color:#0550ae>1.0</span> <span style=color:#953800>x</span><span style=color:#1f2328>))</span>
</span></span></code></pre></div><p>文字描述为不断使用一种方法猜测一个数，计算它的平方，使得平方值不断逼近给定的被开方数。</p><h4 id=118-procedures-as-black-box-abstractions>1.1.8 Procedures as Black-Box Abstractions</h4><p>这一章讲述了将程序作为黑箱抽象的重要性。这个没啥好说的，好是很好，但不恰当地执行就容易变得更加抽象🤣。</p><ul><li><strong>接口和实现分离</strong>：程序的接口（输入输出）和实现（内部细节）是分离的。用户通过接口使用程序，而不需要了解实现细节。</li><li><strong>信息隐藏</strong>：通过隐藏不必要的实现细节，可以减少认知负担，使程序更易于理解和使用。</li><li><strong>模块化设计</strong>：通过将程序分解为独立的模块，每个模块实现特定的功能，可以提高程序的可维护性和可扩展性。</li></ul><h3 id=12-procedures-and-the-processes-they-generate>1.2 Procedures and the Processes They Generate</h3><p>在第一节讲述了什么是程序，但并没有讲该怎么写程序。这就相当于我们了解了下棋的规则，但还是不知道下棋的策略。这一节就是通过一些算法介绍一些常见的程序结构。(说实在的 sicp 的精华都在后几章，前面的太基础有点想跳过了…)</p><h4 id=121-linear-recursion-and-iteration>1.2.1 Linear Recursion and Iteration</h4><p>这一小节通过计算阶乘介绍什么是递归和迭代结构。</p><p>定义阶乘:</p><p>$$ n! = n \times (n-1) \times (n-2) \times \dots \times 2 \times 1 $$</p><h5 id=递归结构>递归结构</h5><p>根据数学定义，能够很容易地写出计算程序为:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>factorial</span> <span style=color:#953800>n</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span> <span style=color:#6639ba>=</span> <span style=color:#953800>n</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#0550ae>1</span> <span style=color:#1f2328>(</span> <span style=color:#6639ba>*</span> <span style=color:#953800>n</span> <span style=color:#1f2328>(</span><span style=color:#953800>factorial</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>-</span> <span style=color:#953800>n</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)))</span> <span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>根据 <a href=/posts/sicp/sicp-%E7%AB%A0%E8%8A%821/#1.1.5%20The%20Substitution%20Model%20for%20Procedure%20Application>1.1.5 The Substitution Model for Procedure Application</a> 中所讲的，上述程序展开的计算过程为如下图:</p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/%E6%88%AA%E5%B1%8F2024-08-11%2015.12.37.png alt></p><h5 id=迭代结构>迭代结构</h5><p>我们可以换个顺序计算阶乘, 从 $1$ 开始乘，直到乘到 $n$ ，计算的程序为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>factorial</span> <span style=color:#953800>n</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#953800>factorial-iter</span> <span style=color:#0550ae>1</span> <span style=color:#0550ae>1</span> <span style=color:#953800>n</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>factorial-iter</span> <span style=color:#953800>res</span> <span style=color:#953800>now</span> <span style=color:#953800>max-iter-count</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>=</span> <span style=color:#953800>now</span> <span style=color:#953800>max-iter-count</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#953800>res</span> <span style=color:#953800>now</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span> <span style=color:#953800>factorial-iter</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#953800>res</span> <span style=color:#953800>now</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>now</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#953800>max-iter-count</span> <span style=color:#1f2328>)</span> <span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>这个程序的展开计算过程为:</p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240811152242.png alt></p><p>可以看出，计算同一个数学公式，上面两种的计算过程完全不同。</p><p>对于递归结构，它的表现是一种展开又收缩的过程，展开表现为程序构建了一系列的 &ldquo;deferred operations&rdquo;，收缩表现为在完全展开后这些运算的实际计算过程，解释器在计算的时候需要存储这些运算过程。在计算 $n!$ 的时候，存储的表达式随着 $n$ 线性增长，这被称为线性递归结构。</p><p>与之相对应的，第二种计算过程为迭代计算结构，可看出，解释器并不需要保存运算的过程，需要保存的是变量 <code>res now max-iter-count</code> 。一般来说，<strong>迭代计算过程就是那种可以使用固定变量表达计算状态的过程，同时它还有一个从当前状态转移到下一个状态的过程，还有一个表达式表达这个计算过程何时终止</strong>。在计算 $n!$ 的时候，计算的表达式随着 $n$ 线性增长，这种被称为线性迭代结构。</p><p>tips: 本章练习可以使用 <a href=https://docs.racket-lang.org/reference/debugging.html#%28part._.Tracing%29>trace</a> 打印计算过程。</p><h4 id=122-tree-recursion>1.2.2 Tree Recursion</h4><p>本小节通过计算斐波那契数列介绍树形递归结构，斐波那契数列为如下数列:</p><p>$$ 0,1,1,2,3,5,8,\dots $$</p><p>满足如下定义:</p><p>$$ \begin{aligned}
F_0 &= 0 \
F_1 &= 1 \
F_n &= F_{n-1} + F_{n-2} (n \ge 2 )
\end{aligned}
$$</p><p>它的对应程序为</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>fib</span> <span style=color:#953800>n</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#6639ba>cond</span>
</span></span><span style=display:flex><span>    <span style=color:#953800>[</span><span style=color:#1f2328>(</span><span style=color:#6639ba>=</span> <span style=color:#953800>n</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>)</span> <span style=color:#953800>0]</span>
</span></span><span style=display:flex><span>    <span style=color:#953800>[</span><span style=color:#1f2328>(</span><span style=color:#6639ba>=</span> <span style=color:#953800>n</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#953800>1]</span>
</span></span><span style=display:flex><span>    <span style=color:#953800>[else</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#953800>fib</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>-</span> <span style=color:#953800>n</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>))</span> <span style=color:#1f2328>(</span><span style=color:#953800>fib</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>-</span> <span style=color:#953800>n</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)))</span><span style=color:#953800>]</span><span style=color:#1f2328>))</span>
</span></span></code></pre></div><p>它的对应计算过程为:</p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240811164246.png alt></p><p>从计算图中可以看出，树形递归结构有许多冗余的计算，像 fib 2 就计算了三次。为了减少这种计算，我们可以使用一些变量存储当前计算的状态，下面的计算斐波那契数列的迭代结构:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>fib</span> <span style=color:#953800>n</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#953800>fib-iter</span> <span style=color:#0550ae>0</span> <span style=color:#0550ae>1</span> <span style=color:#953800>n</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>fib-iter</span> <span style=color:#953800>now</span> <span style=color:#953800>next</span> <span style=color:#6639ba>count</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>=</span> <span style=color:#6639ba>count</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>)</span> <span style=color:#953800>now</span> <span style=color:#1f2328>(</span><span style=color:#953800>fib-iter</span> <span style=color:#953800>next</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>now</span> <span style=color:#953800>next</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>-</span> <span style=color:#6639ba>count</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>))))</span>
</span></span></code></pre></div><p>显然，这种方式计算 fib n 的时间复杂度是 O(n) 的。尽管后一种结构相较于第一种结构速度更优，但第一种是最直观的，迭代法 (动态规划) 的关键在于找到能够代表当前状态的一组变量，这往往是比较难想到的，书中之后就给了个分钱币的例子，使用树形递归能够很容易写出问题的递归形式，但迭代形式却相对困难，书中作为思考题。<a href=https://github.com/tianyicui/pack/blob/master/V2.pdf>背包问题</a>太基础了就不说了，跳过。</p><h4 id=123-orders-of-growth>1.2.3 Orders of Growth</h4><p>这章讲的是什么是时间复杂度，跳过吧</p><p><img src=https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240818152308.png alt></p><p>后面几节基本是在介绍一些基础的算法。</p><h4 id=124-exponentiation>1.2.4 Exponentiation</h4><p>介绍快速幂，跳了</p><h4 id=125-greatest-common-divisors>1,2.5 Greatest Common Divisors</h4><p>介绍计算最大公约数的方法，经典的 Euclid&rsquo;s Algorithm，其中简略地提到了时间复杂度的证明方法：</p><h4 id=126-example-testing-for-primality>1.2.6 Example: Testing for Primality</h4><p>介绍素数检测的方法，根号下遍历 和 费马测试(这玩意写不写呢…)，</p><h3 id=13-formulating-abstractions-with-higher-order-procedures>1.3 Formulating Abstractions with Higher-Order Procedures</h3><p>在经过了一系列算法的洗礼后，我们需要换换口味，来了解一些更加偏向 <a href=https://en.wikipedia.org/wiki/Programming_language_theory>pl</a> 的知识。本节介绍的是对过程使用高阶函数进行抽象。(高阶函数本质就是能够接受函数作为参数的函数)</p><h4 id=131-procedures-as-arguments>1.3.1 Procedures as Arguments</h4><p>本节首先提出了一个场景: 计算 从 a 到 b 的和、平方和、指定序列和。常规来说可以写出如下代码:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>sum-integers</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>&gt;</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span> 
</span></span><span style=display:flex><span>      <span style=color:#0550ae>0</span> 
</span></span><span style=display:flex><span>      <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>a</span> <span style=color:#1f2328>(</span><span style=color:#953800>sum-integers</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>a</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#953800>b</span><span style=color:#1f2328>))))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>sum-cubes</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>&gt;</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span> 
</span></span><span style=display:flex><span>      <span style=color:#0550ae>0</span> 
</span></span><span style=display:flex><span>      <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#953800>cube</span> <span style=color:#953800>a</span><span style=color:#1f2328>)</span> 
</span></span><span style=display:flex><span>         <span style=color:#1f2328>(</span><span style=color:#953800>sum-cubes</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>a</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>)</span> <span style=color:#953800>b</span><span style=color:#1f2328>))))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>pi-sum</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>&gt;</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>      <span style=color:#0550ae>0</span>
</span></span><span style=display:flex><span>      <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>/</span> <span style=color:#0550ae>1.0</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>*</span> <span style=color:#953800>a</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>a</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)))</span> 
</span></span><span style=display:flex><span>         <span style=color:#1f2328>(</span><span style=color:#953800>pi-sum</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>a</span> <span style=color:#0550ae>4</span><span style=color:#1f2328>)</span> <span style=color:#953800>b</span><span style=color:#1f2328>))))</span>
</span></span></code></pre></div><p>显然，这些代码除了函数名和内部计算函数不同之外，其余的几乎没有区别，我们可以从数学的角度上看待这些过程: 数学上，对于 a 到 b 的求和可以表示为</p><p>$$\sum_{n=a}^{b} f(n) = f(a) + \dots + f(b)$$</p><p>其中 f(n) 就是可以替换的函数。</p><p>对与如上的过程，我们可以写出如下的函数:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>sum</span> <span style=color:#953800>term</span> <span style=color:#953800>a</span> <span style=color:#953800>next</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>&gt;</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>      <span style=color:#0550ae>0</span>
</span></span><span style=display:flex><span>      <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#1f2328>(</span><span style=color:#953800>term</span> <span style=color:#953800>a</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>         <span style=color:#1f2328>(</span><span style=color:#953800>sum</span> <span style=color:#953800>term</span> <span style=color:#1f2328>(</span><span style=color:#953800>next</span> <span style=color:#953800>a</span><span style=color:#1f2328>)</span> <span style=color:#953800>next</span> <span style=color:#953800>b</span><span style=color:#1f2328>))))</span>
</span></span></code></pre></div><p>于是如上的过程可以被写成:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>inc</span> <span style=color:#953800>n</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>+</span> <span style=color:#953800>n</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#6639ba>identity</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span> <span style=color:#953800>x</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>sum-integers</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#953800>sum</span> <span style=color:#6639ba>identity</span> <span style=color:#953800>a</span> <span style=color:#953800>inc</span> <span style=color:#953800>b</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#953800>define</span> <span style=color:#1f2328>(</span><span style=color:#953800>sum-cubes</span> <span style=color:#953800>a</span> <span style=color:#953800>b</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>(</span><span style=color:#953800>sum</span> <span style=color:#953800>cube</span> <span style=color:#953800>a</span> <span style=color:#953800>inc</span> <span style=color:#953800>b</span><span style=color:#1f2328>))</span>
</span></span></code></pre></div><h4 id=132-constructing-procedures-usinglambda>1.3.2 Constructing Procedures Using <code>Lambda</code></h4><p>介绍 lisp 匿名函数还有使用 let 创建局部变量，用于简化高阶函数的输入。</p><h4 id=133-procedures-as-general-methods>1.3.3 Procedures as General Methods</h4><h4 id=134-procedures-as-returned-values>1.3.4 Procedures as Returned Values</h4></div><div class="row middle-xs"><div class=col-xs-12><div class=post-tags><a href=/categories/sicp/>/sicp</a></div><div class=post-tags><a href=/tags/sicp/>sicp</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer></div></div></div></article><script src=/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script></body></html>