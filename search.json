[{"title":"é‡‘å­—å¡”åŸç†","path":"/pages/read_notes/é‡‘å­—å¡”åŸç†.html","content":"æ¦‚è¿° æœ¬ä¹¦åˆ†ä¸º4ä¸ªéƒ¨åˆ†ã€‚ ç¬¬1ç¯‡ã€€è¡¨è¾¾çš„é€»è¾‘ã€€ä»‹ç»äº†é‡‘å­—å¡”åŸç†çš„åŸºæœ¬æ¦‚å¿µï¼Œä»¥åŠå¦‚ä½•åˆ©ç”¨è¿™ä¸€åŸç†æ„å»ºåŸºæœ¬çš„é‡‘å­—å¡”ç»“æ„ã€‚æœ¬ç¯‡çš„å†…å®¹è¶³ä»¥ä½¿ä½ ç†è§£å’Œåº”ç”¨ç®€å•çš„å…¬æ–‡å†™ä½œæŠ€å·§ã€‚ ç¬¬2ç¯‡ã€€æ€è€ƒçš„é€»è¾‘ã€€ä»‹ç»äº†å¦‚ä½•æ·±å…¥ç»†è‡´åœ°æŠŠæ¡æ€ç»´çš„ç»†èŠ‚ï¼Œä»¥ä¿è¯ä½ ä½¿ç”¨çš„è¯­å¥çœŸå®ã€æ˜ç¡®åœ°å‘ˆç°ä½ å¸Œæœ›è¡¨è¾¾çš„æ€æƒ³ã€‚æœ¬ç¯‡ä¸¾äº†è®¸å¤šæ¡ˆä¾‹ï¼Œçªå‡ºäº†è¿«ä½¿è‡ªå·±è¿›è¡Œâ€œå†·é™æ€è€ƒâ€å¯¹æ˜ç¡®é˜è¿°æ€æƒ³çš„é‡è¦æ€§ã€‚ ç¬¬3ç¯‡ã€€è§£å†³é—®é¢˜çš„é€»è¾‘ã€€è¯»è€…å¯¹è±¡æ˜¯éœ€è¦å†™ç ”ç©¶æŠ¥å‘Šçš„äººï¼Œä»¥åŠéœ€è¦åˆ†æå¤æ‚é—®é¢˜ã€æå‡ºç»“è®ºä»¥ä½œå‡ºå†³ç­–çš„äººã€‚æœ¬ç¯‡ä»‹ç»äº†å¦‚ä½•åœ¨è§£å†³é—®é¢˜è¿‡ç¨‹çš„ä¸åŒé˜¶æ®µï¼Œä½¿ç”¨å¤šç§æ¡†æ¶ç»„ç»‡åˆ†æè¿‡ç¨‹ï¼Œä½¿ä½ çš„æ€è·¯å®é™…ä¸Šè¿›è¡Œäº†é¢„å…ˆç»„ç»‡ï¼Œä»è€Œå¯ä»¥æ›´æ–¹ä¾¿åœ°åº”ç”¨é‡‘å­—å¡”åŸç†ã€‚ ç¬¬4ç¯‡ã€€æ¼”ç¤ºçš„é€»è¾‘ã€€ä»‹ç»äº†è®¾è®¡ PowerPoint æ¼”ç¤ºå¹»ç¯ç‰‡çš„æŠ€å·§ï¼Œå¯ä»¥å¸®åŠ©ä½ åœ¨ç”¨æ¼”ç¤ºæ–‡ç¨¿å‘ˆç°å…·æœ‰é‡‘å­—å¡”ç»“æ„çš„æ€æƒ³æ—¶ï¼Œä½¿è¯»è€…æˆ–è§‚ä¼—æ„Ÿå—åˆ°é‡‘å­—å¡”ç»“æ„ã€‚ (ç”¨ä¸åˆ°å…ˆä¸çœ‹äº†) ç¬¬ä¸€ç¯‡ è¡¨è¾¾çš„é€»è¾‘ ç¬¬ä¸€ç¯‡ä¸»è¦æ‰€å†™çš„æ˜¯å¦‚ä½•è®©æ–‡ç« æ›´æ˜“ç†è§£çš„æ–¹æ³•è®ºã€‚æ–¹æ³•è®ºçš„é˜é‡Šå¾€å¾€éœ€è¦è¾…ä»¥å…·ä½“äº‹ä¾‹ï¼Œæ–‡ä¸­ä¹Ÿä¸¾ä¾‹äº†ä¸€äº›äº‹ä¾‹è¿›è¡Œè¯´æ˜ã€‚ä½†æœ¬ç« æ—¢ç„¶æ˜¯è®²è¿°å†™ä½œçš„æ–¹æ³•è®ºï¼Œé‚£ä¹ˆä¸å¦‚ç›´æ¥ä»¥åŸæ–‡ç« çš„è¡Œæ–‡é¡ºåºåšä¾‹å­ï¼Œçœ‹çœ‹åŸæ–‡æ˜¯å¦å®ç°äº†è‡ªå·±æå‡ºçš„æ–¹æ³•è®ºçš„è‡ªä¸¾( ã€‚ æ ¸å¿ƒè§‚ç‚¹ å¯¹å—ä¼—ï¼ˆåŒ…æ‹¬è¯»è€…ã€å¬ä¼—ã€è§‚ä¼—æˆ–å­¦å‘˜ï¼‰æ¥è¯´ï¼Œæœ€å®¹æ˜“ç†è§£çš„é¡ºåºæ˜¯ï¼šå…ˆäº†è§£ä¸»è¦çš„ã€æŠ½è±¡çš„æ€æƒ³ï¼Œç„¶åäº†è§£æ¬¡è¦çš„ã€ä¸ºä¸»è¦æ€æƒ³æä¾›æ”¯æŒçš„æ€æƒ³ã€‚å› ä¸ºä¸»è¦æ€æƒ³æ€»æ˜¯ä»æ¬¡è¦æ€æƒ³æ¦‚æ‹¬æ€»ç»“å¾—å‡ºï¼Œæ–‡ç« ä¸­æ‰€æœ‰æ€æƒ³çš„ç†æƒ³ç»„ç»‡ç»“æ„ä¹Ÿå¿…å®šæ˜¯ä¸€ä¸ªé‡‘å­—å¡”ç»“æ„â€”â€”ç”±ä¸€ä¸ªæ€»çš„æ€æƒ³ç»Ÿé¢†å¤šç»„æ€æƒ³ã€‚ åœ¨æœ¬ç¯‡å¼€å¤´ï¼Œä¸€å †å¼•è¨€ç»“æŸåä½œè€…æå‡ºäº†æœ¬ç¯‡çš„æ ¸å¿ƒè§‚ç‚¹: å†™ä½œéœ€è¦æŒ‰ç…§é‡‘å­—å¡”çš„ç»“æ„ï¼Œé¦–å…ˆæå‡ºä¸»è¦æ€æƒ³ï¼Œç„¶åä»‹ç»å¤šç»„æ¬¡è¦æ€æƒ³æ”¯æŒä¸»è¦æ€æƒ³ã€‚æ¯ç»„æ€æƒ³é—´çš„è”ç³»å¯ä»¥æ˜¯çºµå‘çš„ (å³ä¸Šå±‚æ€æƒ³æ˜¯å¯¹ä¸‹å±‚çš„æ€»ç»“)ï¼Œä¹Ÿå¯ä»¥æ˜¯æ¨ªå‘çš„ (å³å¤šä¸ªæ€æƒ³ç»„æˆåŒä¸€ä¸ªé€»è¾‘æ¨ç†è¿‡ç¨‹ï¼Œè€Œè¢«å¹¶åˆ—æ’åœ¨ä¸€èµ·)ã€‚(æ€ä¹ˆæ„Ÿè§‰åœ¨æ•™é«˜ä¸­è®®è®ºæ–‡ğŸ˜‚) #todo åŠ ä¸ªæ€ç»´å¯¼å›¾ 1.1 ä¸ºä»€ä¹ˆè¦ç”¨é‡‘å­—å¡”ç»“æ„ ç¬¬äºŒç¯‡ æ€è€ƒçš„é€»è¾‘ ç¬¬ä¸‰ç¯‡ è§£å†³é—®é¢˜çš„é€»è¾‘","categories":["read_notes"]},{"title":"sicp ç« èŠ‚1","path":"/pages/sicp/sicp ç« èŠ‚1.html","content":"é¢˜è§£: SICP-learning/exercise_1 at master Â· booiris/SICP-learning Â· GitHub 1. Building Abstractions With Procedures sicp å‰é¢éƒ¨åˆ†ä»‹ç»çš„å†…å®¹è¿˜æ˜¯æ¯”è¾ƒåŸºç¡€çš„ï¼Œå…·ä½“æ˜¯åœ¨ä»‹ç»ç¨‹åºæ˜¯ä»€ä¹ˆã€‚ We are about to study the idea of aÂ computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things calledÂ data. The evolution of a process is directed by a pattern of rules called aÂ program. â€“ computational process (å³è®¡ç®—è¿‡ç¨‹) æ˜¯æ“ä½œæ•°æ®çš„è¿‡ç¨‹ï¼Œè¿™ä¸€è¿‡ç¨‹çš„å®ç°ç”±ä¸€ç»„å®šä¹‰çš„è§„åˆ™(ç¨‹åº)å®Œæˆã€‚ ä»ä¸­å¯ä»¥çœ‹å‡ºç¼–å†™çš„è®¡ç®—æœºç¨‹åºæœ‰ä¸¤ä¸ªé‡è¦çš„å…ƒç´ : æ•°æ® æ“ä½œæ•°æ®çš„è¡Œä¸º ç¬”è€…è®¤ä¸ºæˆ‘ä»¬ç¼–å†™çš„ç¨‹åºå°±æ˜¯å¤„ç†æ•°æ®çš„è¿‡ç¨‹ï¼Œæ˜¯å¯¹æ•°æ®çš„å„ç§åŠ å·¥å˜æ¢(è¿™å°±æ˜¯ä¸ºå•¥ä¸€ä¸ªå¥½çš„ç±»å‹ç³»ç»Ÿé‚£ä¹ˆé‡è¦ï¼ŒåœŸæ³•ç‚¼é’¢ä¸å¯å–ï¼Œæ­¤å¤„@æŸä¸€ä¸ªå¤§é“è‡³ç®€çš„è¯­è¨€ğŸ˜šä¸ºå•¥ go ä¸æ”¯æŒæ³›å‹æ–¹æ³•)ã€‚ 1.1 The elements of Programming æœ¬èŠ‚å¼€å§‹åˆåˆ°äº†æœ€å–œæ¬¢çš„æ¦‚å¿µå®šä¹‰ç¯èŠ‚ï¼Œä¸€ä¸ªæˆç†Ÿçš„è¯­è¨€éœ€è¦ä»¥ä¸‹ä¸‰ç§ç»“æ„ï¼š primitive expressions, which represent the simplest entities the language is concerned with, means of combination, by which compound elements are built from simpler ones, and means of abstraction, by which compound elements can be named and manipulated as units. å…·ä½“æ¥è¯´å°±æ˜¯éœ€è¦ åŸºæœ¬è¡¨è¾¾å¼ï¼Œè¡¨ç¤ºè¯­è¨€ä¸­çš„ä¸€äº›åŸºç¡€çš„å®ä½“ï¼Œæ¯”å¦‚å˜é‡å’ŒåŸºæœ¬ç±»å‹ç­‰ ç»„åˆç®—å­ï¼Œèƒ½å¤Ÿä»ç®€å•çš„å…ƒç´ æ„å»ºå‡ºå¤æ‚çš„è¿ç®—ï¼Œæ¯”å¦‚è¿ç®—ç¬¦å’Œå‡½æ•°è°ƒç”¨ç­‰ æŠ½è±¡æ–¹å¼ï¼Œèƒ½å¤Ÿå°†ä¸€ç»„è¿‡ç¨‹æˆ–è€…æ•°æ®ç±»å‹å°è£…åˆå¹¶ä¸ºä¸€ä¸ªå•å…ƒï¼Œæ¯”å¦‚å˜é‡å®šä¹‰ã€å‡½æ•°å®šä¹‰å’ŒæŠ½è±¡æ•°æ®ç±»å‹çš„å®šä¹‰ ä¹‹åï¼Œæ–‡ä¸­å†æ¬¡å¼ºè°ƒäº†ç¨‹åºä¸­æœ€é‡è¦çš„ä¸¤ä¸ªå…ƒç´ ï¼Œè¿‡ç¨‹å’Œæ•°æ®(ä½†å®é™…ä¸Šè¿‡ç¨‹ä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ç§æ•°æ®(æœ‰æ²¡æœ‰å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘çš„å³è§†æ„Ÿ) )ï¼š In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distinct.) 1.1.1 Expressions åŸºæœ¬ä¸Šæ˜¯åœ¨é€šè¿‡ä»‹ç» lisp ä¸­çš„ä¸€äº›è¯­æ³•æ¥é˜é‡Š expressions è¿™ä¸€æ¦‚å¿µï¼ˆä¸è¿‡ lisp æ˜¯å‰ç¼€è¡¨è¾¾å¼è¿˜çœŸæ˜¯åç›´è§‰ğŸ‘¾ï¼Œå½“ç„¶æŠŠè¿ç®—ç¬¦å½“æˆå‡½æ•°è°ƒç”¨çœ‹èƒ½å¥½ä¸€ç‚¹ï¼Œä¹Ÿç¡®å®èƒ½æ›´å¥½è¡¨è¾¾å‡½æ•°å¤åˆç­‰æ¦‚å¿µï¼Œä½†è¿˜æ˜¯éš¾å—ğŸ¤–ï¼‰ã€‚ ä¸€äº›è¡¨è¾¾å¼ä¾‹å­: 123123(+ 1 2)(* (+ 1 2) 4) åé¢å¸¦è¿ç®—ç¬¦çš„è¡¨è¾¾å¼è¢«ç§°ä¸ºç»„åˆå¼ã€‚ 1.1.2 Naming and the Environment ä»‹ç»äº† lisp çš„å˜é‡å®šä¹‰æ–¹å¼ï¼Œè¿˜æå¸¦è®²äº†ä¸‹å˜é‡ä½œç”¨åŸŸçš„æ¦‚å¿µã€‚ 1.1.3 Evaluating Combinations ä»‹ç»äº† lisp è®¡ç®—ç»„åˆå¼çš„æ–¹å¼ï¼š è®¡ç®—ç»„åˆå¼éœ€è¦é¦–å…ˆè®¡ç®—æ‰€æœ‰å­è¡¨è¾¾å¼ï¼Œæ˜¯ä¸€ä¸ªé€’å½’è®¡ç®—çš„è¿‡ç¨‹ã€‚ è‡ªå·¦å‘å³è®¡ç®—å€¼ã€‚ è®¡ç®—ç»„åˆå¼çš„è¿‡ç¨‹æ„æˆäº†ä¸€ä¸ªå¤šå‰æ ‘ï¼Œè®¡ç®—ç»„åˆå¼çš„è¿‡ç¨‹å°±æ˜¯è®¡ç®—ä¸€ä¸ªä¸ªåŸºæœ¬è¡¨è¾¾å¼çš„è¿‡ç¨‹ï¼Œè€Œæ„æˆåŸºæœ¬è¡¨è¾¾å¼çš„è§„åˆ™ä¸ºï¼š æ•°å€¼çš„å€¼å°±æ˜¯å®ƒä»¬æ‰€ä»£è¡¨çš„æ•°å­—æœ¬èº« (æœ‰ç‚¹æ€ªæ€ªçš„ï¼Œåº”è¯¥æŒ‡çš„æ˜¯ æ•°å€¼æ˜¯æœ€åŸºæœ¬çš„å…ƒç´ ï¼Œå‚ä¸è¿ç®—çš„å®é™…ä¸Šæ˜¯å…·ä½“çš„æ•°å€¼ã€‚æ¯”å¦‚è®¡ç®— x=2ï¼Œ + x 1 æ—¶ï¼Œå®é™…ä¸Šæ˜¯è®¡ç®— + 2 1ï¼Œåœ¨è®¡ç®—çš„è¿‡ç¨‹ä¸­å˜é‡å·²ç»æ›¿æ¢ä¸ºå…·ä½“çš„å€¼äº†)ã€‚ è¡¨è¾¾å¼ä¸­æœ‰ä¸€äº›åŸºæœ¬å†…ç½®è¿ç®—ç¬¦ï¼Œå¯¹åº”ç€å®Œæˆç›¸åº”æ“ä½œçš„æœºå™¨æŒ‡ä»¤ã€‚ è¡¨è¾¾å¼ä¸­è¿˜å­˜åœ¨ç€ä¸€äº›å˜é‡ï¼Œè¿™äº›å˜é‡æŒ‡å‘å½“å‰ä½œç”¨åŸŸä¸­çš„ä¸€ä¸ªç‰¹å®šå¯¹è±¡ã€‚æ‰€ä»¥å˜é‡ä¸èƒ½è„±ç¦»ä½œç”¨åŸŸï¼Œå•çº¯çš„ (+ x 1) æ˜¯æ— æ„ä¹‰çš„ï¼Œæ— æ³•è®¡ç®—å‡ºå®ƒçš„å€¼ã€‚ 1.1.4 Compound Procedures è¿™ä¸€ç« ä»‹ç»çš„æ˜¯ lisp ä¸­å‡½æ•°çš„å®šä¹‰æ–¹æ³•ï¼Œåœ¨æ–‡ä¸­è¢«ç§°ä¸º â€œcompound procedureâ€ã€‚ lisp çš„å‡½æ•°å®šä¹‰è¯­æ³•å½¢å¼ä¸ºï¼š 1( define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt; ) 1.1.5 The Substitution Model for Procedure Application æœ¬ç« è®²çš„æ˜¯ lisp è®¡ç®—è‡ªå®šå‡½æ•°çš„è¿‡ç¨‹ï¼Œå’Œ 1.1.3 Evaluating Combinations ä¸­è®¡ç®—ç»„åˆå¼çš„è¿‡ç¨‹ç±»ä¼¼ã€‚åœ¨æœ¬ç« ä¸­ä½¿ç”¨äº† â€œsubstitution modelâ€ (æ›¿æ¢)æ¥è§£é‡Šè¿ç®—è¿‡ç¨‹ã€‚ ä¾‹: å¯¹äºå¦‚ä¸‹å‡½æ•° 12345(define (square x) (* x x) )(define (sum-of-squares x y)\t(+ (square x) (square y) ) )(define (f a)\t(sum-of-squares (+ a 1) (* a 2) ) ) è®¡ç®— (f 5) çš„è¿‡ç¨‹å¦‚ä¸‹: 1234567(f 5) -&gt;(sum-of-squares (+ 5 1) (* 5 2) ) -&gt;(sum-of-squares 6 10) -&gt;(+ (square 6) (square 10) ) -&gt;(+ (* 6 6) (* 10 10) ) -&gt;(+ 36 100) -&gt;136 substitution model å°±æ˜¯å°†å®é™…çš„è¿ç®—å¼æ›¿æ¢å‡½æ•°åçš„è¿‡ç¨‹ã€‚ä½†è¿™å¹¶ä¸æ˜¯lisp çš„å®é™…è¿ç®—è¿‡ç¨‹ã€‚åœ¨åç»­ 3ã€4ã€5 ç« ä¼šæ›´è¯¦ç»†åœ°è®²è¿°è¿™ä¸€è¿‡ç¨‹ã€‚ è®¡ç®—è¡¨è¾¾å¼çš„é¡ºåº åœ¨ä¸Šé¢ä¸¾ä¾‹è®¡ç®— (f 5) çš„è¿‡ç¨‹ä¸­å¯ä»¥å‘ç°ï¼Œæˆ‘ä»¬æ˜¯åœ¨é‡åˆ°å¯è®¡ç®—çš„åŸºæœ¬è¡¨è¾¾å¼æ—¶å°±ç›´æ¥è®¡ç®—å‡ºå¯¹åº”çš„å€¼ã€‚ç„¶è€Œè¿˜æœ‰å¦ä¸€ç§è®¡ç®—çš„æ–¹å¼ï¼Œå°±æ˜¯åœ¨è®¡ç®—è¡¨è¾¾å¼çš„è¿‡ç¨‹ä¸­åªå±•å¼€è¡¨è¾¾å¼ï¼Œè€Œä¸è®¡ç®—å€¼ï¼Œå½“æ•´ä¸ªè¡¨è¾¾å¼è¢«å±•å¼€æˆåªç”±åŸºæœ¬è¡¨è¾¾å¼ç»„æˆæ—¶ï¼Œå†è®¡ç®—å‡ºå€¼ã€‚ 12345(f 5) -&gt;(sum-of-squares (+ 5 1) (* 5 2) ) -&gt;(+ (square (+ 5 1)) (square (* 5 2) ) ) -&gt;(+ (* (+ 5 1) (+ 5 1) ) (* (* 5 2) (* 5 2) ) ) -&gt;136 è¿™ç§å®Œå…¨å±•å¼€çš„è®¡ç®—è¿‡ç¨‹è¢«ç§°ä¸º normal-order evaluation (æ­£åˆ™åºæ±‚å€¼)ï¼Œå…ˆæ±‚å€¼å†ä»£å…¥å‡½æ•°è°ƒç”¨çš„è¢«ç§°ä¸º applicative-order evaluation (åº”ç”¨åºæ±‚å€¼)ã€‚ lisp ä¸­é‡‡ç”¨çš„æ˜¯åé¢ä¸€ç§è®¡ç®—æ–¹å¼ï¼Œéƒ¨åˆ†åŸå› åœ¨äºå…¶èƒ½å¤Ÿé¿å…å¯¹è¡¨è¾¾å¼çš„é‡å¤æ±‚å€¼ã€‚å¯¹äºäººç±»æ¥è¯´ï¼Œå®Œå…¨å±•å¼€ç„¶åè®¡ç®—ä»ç›´è§‰ä¸Šæ„Ÿè§‰å°±ååˆ†éº»çƒ¦ï¼Œä½†å…¶ä¹Ÿæœ‰ç‰¹æ®Šç”¨å¤„ï¼Œå¯ä»¥ç”¨äºå¤„ç†æ— æ³•æ±‚å€¼çš„è¡¨è¾¾å¼ï¼Œç¬¬ä¸‰ç« è®¨è®ºäº†ä½¿ç”¨æ­£åˆ™å¼å®šä¹‰çš„æµå¼è¿‡ç¨‹ï¼Œç”¨äºå¤„ç†æ— é™æ•°æ®ç»“æ„ã€‚ 1.1.6 Conditional Expressions and Predicates è¿™ä¸€ç« ä»‹ç»äº† lisp ä¸­çš„åˆ†æ”¯è¯­æ³•ï¼Œè¯­æ³•å½¢å¼ä¸ºï¼š 1234(cond (âŸ¨pâ‚âŸ© âŸ¨eâ‚âŸ©) (âŸ¨pâ‚‚âŸ© âŸ¨eâ‚‚âŸ©) â€¦ (âŸ¨pâ‚™âŸ© âŸ¨eâ‚™âŸ©)) è¿˜æœ‰ä¸ª if è¯­æ³•ç³–ï¼Œè¯­æ³•å½¢å¼ä¸ºï¼š 1(if âŸ¨predicateâŸ© âŸ¨consequentâŸ© âŸ¨alternativeâŸ©) åˆ†æ”¯è¯­æ³•å…³è”çš„é€»è¾‘è¿ç®—ç¬¦ä¸ºï¼š 123(and âŸ¨eâ‚âŸ©Â â€¦Â âŸ¨eâ‚™âŸ©)(or âŸ¨eâ‚âŸ©Â â€¦Â âŸ¨eâ‚™âŸ©)(not âŸ¨eâŸ©) 1.1.7 Example: Square Roots by Newtonâ€™s Method é¦–å…ˆï¼Œå¦‚ 1. Building Abstractions With Procedures ä¸­æ‰€è¨€ï¼Œprocedures æ˜¯æ“ä½œæ•°æ®çš„è¿‡ç¨‹ï¼Œè¿™å¾ˆåƒå¸¸è§„çš„æ•°å­¦å‡½æ•°ï¼Œé€šè¿‡è¾“å‡ºä¸€äº›å€¼ï¼Œç»è¿‡ä¸€äº›è¿ç®—ç„¶åå¾—åˆ°ä¸€äº›å€¼ã€‚ä½†å’Œæ•°å­¦ä¸Šçš„å‡½æ•°ä¸ä¸€æ ·çš„ç‚¹åœ¨äºï¼Œç¨‹åºä¸­çš„å‡½æ•°å¿…é¡»æ˜¯å¯è¡Œçš„ã€‚ ä»¥è®¡ç®—å¹³æ–¹æ ¹ä¸ºä¾‹ï¼Œåœ¨æ•°å­¦ä¸Šå®šä¹‰å¹³æ–¹æ ¹ yyy ä¸º y=x,whereyâ‰¥0andy2=xy = \\sqrt{x} , \\quad where \\quad y \\geq 0 \\quad and \\quad y^2 = x y=xâ€‹,whereyâ‰¥0andy2=x éå¸¸çš„æ¸…æ™°ï¼Œä½†ä¹Ÿéå¸¸çš„æŠ½è±¡ï¼Œè¿™ä¸ªå‡½æ•°åªç»™å‡ºäº†ä»€ä¹ˆæ˜¯å¹³æ–¹æ ¹å‡½æ•°(å¹³æ–¹çš„é€†å‡½æ•°)ï¼Œä½†å¹¶æ²¡æœ‰ç»™å‡ºæ€ä¹ˆè®¡ç®—ä¸€ä¸ªå€¼çš„å¹³æ–¹æ ¹ã€‚åœ¨ä¹¦ä¸­æåˆ°è¿™åæ˜ äº†è¯´æ˜æ€§æè¿°å’Œè¿‡ç¨‹æ€§æè¿°çš„åŒºåˆ«ï¼Œå³ä½¿ç»™å‡ºäº†ä¸€ä¸ªå‡½æ•°çš„å®šä¹‰ï¼Œä½†æ¨å‡ºå®ƒçš„å…·ä½“å®ç°ä¹Ÿæ˜¯å¾ˆå›°éš¾çš„ã€‚ æœ€å¸¸ç”¨çš„è®¡ç®—å¹³æ–¹æ ¹çš„æ–¹æ³•ä¸ºç‰›é¡¿è¿­ä»£æ³•ï¼Œå…¶è¿‡ç¨‹ç”¨å¦‚ä¸‹ä»£ç è¡¨ç¤ºï¼š 12345678910111213141516(define (sqrt-iter guess x)\t(if (good-enough? guess x) guess (sqrt-iter (improve guess x) x)))(define (improve guess x)\t(average guess (/ x guess)))(define (average x y)\t(/ (+ x y) 2))(define (good-enough? guess x)\t(&lt; (abs (- (* guess guess) x)) 0.001))(define (sqrt x)\t(sqrt-iter 1.0 x)) æ–‡å­—æè¿°ä¸ºä¸æ–­ä½¿ç”¨ä¸€ç§æ–¹æ³•çŒœæµ‹ä¸€ä¸ªæ•°ï¼Œè®¡ç®—å®ƒçš„å¹³æ–¹ï¼Œä½¿å¾—å¹³æ–¹å€¼ä¸æ–­é€¼è¿‘ç»™å®šçš„è¢«å¼€æ–¹æ•°ã€‚ 1.1.8 Procedures as Black-Box Abstractions è¿™ä¸€ç« è®²è¿°äº†å°†ç¨‹åºä½œä¸ºé»‘ç®±æŠ½è±¡çš„é‡è¦æ€§ã€‚è¿™ä¸ªæ²¡å•¥å¥½è¯´çš„ï¼Œå¥½æ˜¯å¾ˆå¥½ï¼Œä½†ä¸æ°å½“åœ°æ‰§è¡Œå°±å®¹æ˜“å˜å¾—æ›´åŠ æŠ½è±¡ğŸ¤£ã€‚ æ¥å£å’Œå®ç°åˆ†ç¦»ï¼šç¨‹åºçš„æ¥å£ï¼ˆè¾“å…¥è¾“å‡ºï¼‰å’Œå®ç°ï¼ˆå†…éƒ¨ç»†èŠ‚ï¼‰æ˜¯åˆ†ç¦»çš„ã€‚ç”¨æˆ·é€šè¿‡æ¥å£ä½¿ç”¨ç¨‹åºï¼Œè€Œä¸éœ€è¦äº†è§£å®ç°ç»†èŠ‚ã€‚ ä¿¡æ¯éšè—ï¼šé€šè¿‡éšè—ä¸å¿…è¦çš„å®ç°ç»†èŠ‚ï¼Œå¯ä»¥å‡å°‘è®¤çŸ¥è´Ÿæ‹…ï¼Œä½¿ç¨‹åºæ›´æ˜“äºç†è§£å’Œä½¿ç”¨ã€‚ æ¨¡å—åŒ–è®¾è®¡ï¼šé€šè¿‡å°†ç¨‹åºåˆ†è§£ä¸ºç‹¬ç«‹çš„æ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—å®ç°ç‰¹å®šçš„åŠŸèƒ½ï¼Œå¯ä»¥æé«˜ç¨‹åºçš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ã€‚ 1.2 Procedures and the Processes They Generate åœ¨ç¬¬ä¸€èŠ‚è®²è¿°äº†ä»€ä¹ˆæ˜¯ç¨‹åºï¼Œä½†å¹¶æ²¡æœ‰è®²è¯¥æ€ä¹ˆå†™ç¨‹åºã€‚è¿™å°±ç›¸å½“äºæˆ‘ä»¬äº†è§£äº†ä¸‹æ£‹çš„è§„åˆ™ï¼Œä½†è¿˜æ˜¯ä¸çŸ¥é“ä¸‹æ£‹çš„ç­–ç•¥ã€‚è¿™ä¸€èŠ‚å°±æ˜¯é€šè¿‡ä¸€äº›ç®—æ³•ä»‹ç»ä¸€äº›å¸¸è§çš„ç¨‹åºç»“æ„ã€‚(è¯´å®åœ¨çš„ sicp çš„ç²¾åéƒ½åœ¨åå‡ ç« ï¼Œå‰é¢çš„å¤ªåŸºç¡€æœ‰ç‚¹æƒ³è·³è¿‡äº†â€¦) 1.2.1 Linear Recursion and Iteration è¿™ä¸€å°èŠ‚é€šè¿‡è®¡ç®—é˜¶ä¹˜ä»‹ç»ä»€ä¹ˆæ˜¯é€’å½’å’Œè¿­ä»£ç»“æ„ã€‚ å®šä¹‰é˜¶ä¹˜: n!=nÃ—(nâˆ’1)Ã—(nâˆ’2)Ã—â‹¯Ã—2Ã—1n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 2 \\times 1 n!=nÃ—(nâˆ’1)Ã—(nâˆ’2)Ã—â‹¯Ã—2Ã—1 é€’å½’ç»“æ„ æ ¹æ®æ•°å­¦å®šä¹‰ï¼Œèƒ½å¤Ÿå¾ˆå®¹æ˜“åœ°å†™å‡ºè®¡ç®—ç¨‹åºä¸º: 123(define (factorial n) (if ( = n 1) 1 ( * n (factorial (- n 1))) ) ) æ ¹æ® 1.1.5 The Substitution Model for Procedure Application ä¸­æ‰€è®²çš„ï¼Œä¸Šè¿°ç¨‹åºå±•å¼€çš„è®¡ç®—è¿‡ç¨‹ä¸ºå¦‚ä¸‹å›¾: è¿­ä»£ç»“æ„ æˆ‘ä»¬å¯ä»¥æ¢ä¸ªé¡ºåºè®¡ç®—é˜¶ä¹˜, ä» 111 å¼€å§‹ä¹˜ï¼Œç›´åˆ°ä¹˜åˆ° nnn ï¼Œè®¡ç®—çš„ç¨‹åºä¸ºï¼š 1234567(define (factorial n) (factorial-iter 1 1 n) )(define (factorial-iter res now max-iter-count) (if (= now max-iter-count) (* res now) ( factorial-iter (* res now) (+ now 1) max-iter-count ) ) ) è¿™ä¸ªç¨‹åºçš„å±•å¼€è®¡ç®—è¿‡ç¨‹ä¸º: å¯ä»¥çœ‹å‡ºï¼Œè®¡ç®—åŒä¸€ä¸ªæ•°å­¦å…¬å¼ï¼Œä¸Šé¢ä¸¤ç§çš„è®¡ç®—è¿‡ç¨‹å®Œå…¨ä¸åŒã€‚ å¯¹äºé€’å½’ç»“æ„ï¼Œå®ƒçš„è¡¨ç°æ˜¯ä¸€ç§å±•å¼€åˆæ”¶ç¼©çš„è¿‡ç¨‹ï¼Œå±•å¼€è¡¨ç°ä¸ºç¨‹åºæ„å»ºäº†ä¸€ç³»åˆ—çš„ â€œdeferred operationsâ€ï¼Œæ”¶ç¼©è¡¨ç°ä¸ºåœ¨å®Œå…¨å±•å¼€åè¿™äº›è¿ç®—çš„å®é™…è®¡ç®—è¿‡ç¨‹ï¼Œè§£é‡Šå™¨åœ¨è®¡ç®—çš„æ—¶å€™éœ€è¦å­˜å‚¨è¿™äº›è¿ç®—è¿‡ç¨‹ã€‚åœ¨è®¡ç®— n!n!n! çš„æ—¶å€™ï¼Œå­˜å‚¨çš„è¡¨è¾¾å¼éšç€ nnn çº¿æ€§å¢é•¿ï¼Œè¿™è¢«ç§°ä¸ºçº¿æ€§é€’å½’ç»“æ„ã€‚ ä¸ä¹‹ç›¸å¯¹åº”çš„ï¼Œç¬¬äºŒç§è®¡ç®—è¿‡ç¨‹ä¸ºè¿­ä»£è®¡ç®—ç»“æ„ï¼Œå¯çœ‹å‡ºï¼Œè§£é‡Šå™¨å¹¶ä¸éœ€è¦ä¿å­˜è¿ç®—çš„è¿‡ç¨‹ï¼Œéœ€è¦ä¿å­˜çš„æ˜¯å˜é‡ res now max-iter-count ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¿­ä»£è®¡ç®—è¿‡ç¨‹å°±æ˜¯é‚£ç§å¯ä»¥ä½¿ç”¨å›ºå®šå˜é‡è¡¨è¾¾è®¡ç®—çŠ¶æ€çš„è¿‡ç¨‹ï¼ŒåŒæ—¶å®ƒè¿˜æœ‰ä¸€ä¸ªä»å½“å‰çŠ¶æ€è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€çš„è¿‡ç¨‹ï¼Œè¿˜æœ‰ä¸€ä¸ªè¡¨è¾¾å¼è¡¨è¾¾è¿™ä¸ªè®¡ç®—è¿‡ç¨‹ä½•æ—¶ç»ˆæ­¢ã€‚åœ¨è®¡ç®— n!n!n! çš„æ—¶å€™ï¼Œè®¡ç®—çš„è¡¨è¾¾å¼éšç€ nnn çº¿æ€§å¢é•¿ï¼Œè¿™ç§è¢«ç§°ä¸ºçº¿æ€§è¿­ä»£ç»“æ„ã€‚ tips: æœ¬ç« ç»ƒä¹ å¯ä»¥ä½¿ç”¨ trace æ‰“å°è®¡ç®—è¿‡ç¨‹ã€‚ 1.2.2 Tree Recursion æœ¬å°èŠ‚é€šè¿‡è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—ä»‹ç»æ ‘å½¢é€’å½’ç»“æ„ï¼Œæ–æ³¢é‚£å¥‘æ•°åˆ—ä¸ºå¦‚ä¸‹æ•°åˆ—: 0,1,1,2,3,5,8,â€¦0,1,1,2,3,5,8,\\dots 0,1,1,2,3,5,8,â€¦ æ»¡è¶³å¦‚ä¸‹å®šä¹‰: F0=0F1=1Fn=Fnâˆ’1+Fnâˆ’2(nâ‰¥2) \\begin{aligned} F_0 &amp;= 0 \\\\ F_1 &amp;= 1 \\\\ F_n &amp;= F_{n-1} + F_{n-2} (n \\ge 2 ) \\end{aligned} F0â€‹F1â€‹Fnâ€‹â€‹=0=1=Fnâˆ’1â€‹+Fnâˆ’2â€‹(nâ‰¥2)â€‹ å®ƒçš„å¯¹åº”ç¨‹åºä¸º 12345(define (fib n) (cond [(= n 0) 0] [(= n 1) 1] [else (+ (fib (- n 1)) (fib (- n 2)))])) å®ƒçš„å¯¹åº”è®¡ç®—è¿‡ç¨‹ä¸º: ä»è®¡ç®—å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œæ ‘å½¢é€’å½’ç»“æ„æœ‰è®¸å¤šå†—ä½™çš„è®¡ç®—ï¼Œåƒ fib 2 å°±è®¡ç®—äº†ä¸‰æ¬¡ã€‚ä¸ºäº†å‡å°‘è¿™ç§è®¡ç®—ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€äº›å˜é‡å­˜å‚¨å½“å‰è®¡ç®—çš„çŠ¶æ€ï¼Œä¸‹é¢çš„è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„è¿­ä»£ç»“æ„: 12345(define (fib n) (fib-iter 0 1 n))(define (fib-iter now next count) (if (= count 0) now (fib-iter next (+ now next) (- count 1)))) æ˜¾ç„¶ï¼Œè¿™ç§æ–¹å¼è®¡ç®— fib n çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n) çš„ã€‚å°½ç®¡åä¸€ç§ç»“æ„ç›¸è¾ƒäºç¬¬ä¸€ç§ç»“æ„é€Ÿåº¦æ›´ä¼˜ï¼Œä½†ç¬¬ä¸€ç§æ˜¯æœ€ç›´è§‚çš„ï¼Œè¿­ä»£æ³• (åŠ¨æ€è§„åˆ’) çš„å…³é”®åœ¨äºæ‰¾åˆ°èƒ½å¤Ÿä»£è¡¨å½“å‰çŠ¶æ€çš„ä¸€ç»„å˜é‡ï¼Œè¿™å¾€å¾€æ˜¯æ¯”è¾ƒéš¾æƒ³åˆ°çš„ï¼Œä¹¦ä¸­ä¹‹åå°±ç»™äº†ä¸ªåˆ†é’±å¸çš„ä¾‹å­ï¼Œä½¿ç”¨æ ‘å½¢é€’å½’èƒ½å¤Ÿå¾ˆå®¹æ˜“å†™å‡ºé—®é¢˜çš„é€’å½’å½¢å¼ï¼Œä½†è¿­ä»£å½¢å¼å´ç›¸å¯¹å›°éš¾ï¼Œä¹¦ä¸­ä½œä¸ºæ€è€ƒé¢˜ã€‚èƒŒåŒ…é—®é¢˜å¤ªåŸºç¡€äº†å°±ä¸è¯´äº†ï¼Œè·³è¿‡ã€‚ 1.2.3 Orders of Growth è¿™ç« è®²çš„æ˜¯ä»€ä¹ˆæ˜¯æ—¶é—´å¤æ‚åº¦ï¼Œè·³è¿‡å§ åé¢å‡ èŠ‚åŸºæœ¬æ˜¯åœ¨ä»‹ç»ä¸€äº›åŸºç¡€çš„ç®—æ³•ã€‚ 1.2.4 Exponentiation ä»‹ç»å¿«é€Ÿå¹‚ï¼Œè·³äº† 1,2.5 Greatest Common Divisors ä»‹ç»è®¡ç®—æœ€å¤§å…¬çº¦æ•°çš„æ–¹æ³•ï¼Œç»å…¸çš„ Euclidâ€™s Algorithmï¼Œå…¶ä¸­ç®€ç•¥åœ°æåˆ°äº†æ—¶é—´å¤æ‚åº¦çš„è¯æ˜æ–¹æ³•ï¼š 1.2.6 Example: Testing for Primality ä»‹ç»ç´ æ•°æ£€æµ‹çš„æ–¹æ³•ï¼Œæ ¹å·ä¸‹éå† å’Œ è´¹é©¬æµ‹è¯•(è¿™ç©æ„å†™ä¸å†™å‘¢â€¦)ï¼Œ 1.3 Formulating Abstractions with Higher-Order Procedures åœ¨ç»è¿‡äº†ä¸€ç³»åˆ—ç®—æ³•çš„æ´—ç¤¼åï¼Œæˆ‘ä»¬éœ€è¦æ¢æ¢å£å‘³ï¼Œæ¥äº†è§£ä¸€äº›æ›´åŠ åå‘ pl çš„çŸ¥è¯†ã€‚æœ¬èŠ‚ä»‹ç»çš„æ˜¯å¯¹è¿‡ç¨‹ä½¿ç”¨é«˜é˜¶å‡½æ•°è¿›è¡ŒæŠ½è±¡ã€‚(é«˜é˜¶å‡½æ•°æœ¬è´¨å°±æ˜¯èƒ½å¤Ÿæ¥å—å‡½æ•°ä½œä¸ºå‚æ•°çš„å‡½æ•°) 1.3.1 Procedures as Arguments æœ¬èŠ‚é¦–å…ˆæå‡ºäº†ä¸€ä¸ªåœºæ™¯: è®¡ç®— ä» a åˆ° b çš„å’Œã€å¹³æ–¹å’Œã€æŒ‡å®šåºåˆ—å’Œã€‚å¸¸è§„æ¥è¯´å¯ä»¥å†™å‡ºå¦‚ä¸‹ä»£ç : 12345678910111213141516(define (sum-integers a b) (if (&gt; a b) 0 (+ a (sum-integers (+ a 1) b))))(define (sum-cubes a b) (if (&gt; a b) 0 (+ (cube a) (sum-cubes (+ a 1) b))))(define (pi-sum a b) (if (&gt; a b) 0 (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b)))) æ˜¾ç„¶ï¼Œè¿™äº›ä»£ç é™¤äº†å‡½æ•°åå’Œå†…éƒ¨è®¡ç®—å‡½æ•°ä¸åŒä¹‹å¤–ï¼Œå…¶ä½™çš„å‡ ä¹æ²¡æœ‰åŒºåˆ«ï¼Œæˆ‘ä»¬å¯ä»¥ä»æ•°å­¦çš„è§’åº¦ä¸Šçœ‹å¾…è¿™äº›è¿‡ç¨‹: æ•°å­¦ä¸Šï¼Œå¯¹äº a åˆ° b çš„æ±‚å’Œå¯ä»¥è¡¨ç¤ºä¸º âˆ‘n=abf(n)=f(a)+â‹¯+f(b)\\sum_{n=a}^{b} f(n) = f(a) + \\dots + f(b) n=aâˆ‘bâ€‹f(n)=f(a)+â‹¯+f(b) å…¶ä¸­ f(n) å°±æ˜¯å¯ä»¥æ›¿æ¢çš„å‡½æ•°ã€‚ å¯¹ä¸å¦‚ä¸Šçš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå¦‚ä¸‹çš„å‡½æ•°: 12345(define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b)))) äºæ˜¯å¦‚ä¸Šçš„è¿‡ç¨‹å¯ä»¥è¢«å†™æˆ: 12345678910(define (inc n) (+ n 1))(define (identity x) x)(define (sum-integers a b) (sum identity a inc b))(define (sum-cubes a b) (sum cube a inc b)) 1.3.2 Constructing Procedures UsingÂ Lambda ä»‹ç» lisp åŒ¿åå‡½æ•°è¿˜æœ‰ä½¿ç”¨ let åˆ›å»ºå±€éƒ¨å˜é‡ï¼Œç”¨äºç®€åŒ–é«˜é˜¶å‡½æ•°çš„è¾“å…¥ã€‚ 1.3.3 Procedures as General Methods 1.3.4 Procedures as Returned Values","tags":["sicp"],"categories":["sicp"]},{"title":"rust ååºåˆ—åŒ–æ—¶çš„ zero copy","path":"/pages/blog/rust ååºåˆ—åŒ–æ—¶çš„ zero copy.html","content":"Not a Yoking Matter (Zero-Copy #1) - In Pursuit of Laziness","categories":["blog"]},{"title":"ä½¿ç”¨ rust æ¸¸ç© cf çš„å§¿åŠ¿","path":"/pages/blog/ä½¿ç”¨ rust æ¸¸ç© cf çš„å§¿åŠ¿.html","content":"cf æ˜¯ä»€ä¹ˆ å…·ä½“æ¥è¯´å°±æ˜¯ ç©¿è¶Šç«çº¿æ˜¯ä¸€æ¬¾éå¸¸å—æ¬¢è¿çš„ç¬¬ä¸€äººç§°å°„å‡»ç½‘ç»œæ¸¸æˆï¼Œå®ƒä¹Ÿè¢«ç§°ä½œ&quot;CrossFire&quot;ã€‚å®ƒæœ€æ—©ç”±éŸ©å›½SmileGateå…¬å¸å¼€å‘ï¼Œåæ¥åœ¨ä¸­å›½ç”±è…¾è®¯å…¬å¸è¿è¥ã€‚è¿™ä¸ªæ¸¸æˆåœ¨ä¸­å›½æœ‰ç€åºå¤§çš„ç©å®¶åŸºç¡€ï¼Œåœ¨äºšæ´²å…¶ä»–åœ°åŒºä»¥åŠå…¨çƒä¹Ÿæœ‰ç›¸å½“å¤šçš„ç²‰ä¸ã€‚ æ¸¸æˆæä¾›äº†å¤šç§æ¨¡å¼ï¼ŒåŒ…æ‹¬ç»å…¸çš„å›¢é˜Ÿå¯¹æˆ˜ã€çˆ†ç ´æ¨¡å¼ã€ç”ŸåŒ–æ¨¡å¼ç­‰ã€‚ç©å®¶èƒ½é€‰æ‹©æˆä¸ºå…¨çƒåæç²¾è‹±çš„ä¸€å‘˜ï¼Œæˆ–è€…åŠ å…¥ææ€–åˆ†å­é˜µè¥ã€‚åœ¨æ¸¸æˆä¸­ï¼Œç©å®¶å¯ä»¥è´­ä¹°å’Œå‡çº§å„ç§æ­¦å™¨è£…å¤‡ï¼Œä¸é˜Ÿå‹ååŒä½œæˆ˜ï¼Œå®Œæˆä¸åŒçš„ä»»åŠ¡å’ŒæŒ‘æˆ˜ã€‚ Codeforces æ˜¯ä¸€ä¸ªåœ¨çº¿ç¼–ç¨‹å’Œç®—æ³•ç«èµ›å¹³å°ï¼Œå¹¿å—å…¨çƒç¨‹åºå‘˜å’Œç®—æ³•çˆ±å¥½è€…çš„æ¬¢è¿ã€‚å®ƒæä¾›äº†ä¸€ä¸ªå¹³å°ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡å‚åŠ å®šæœŸä¸¾åŠçš„ç¼–ç¨‹æ¯”èµ›æ¥æé«˜è‡ªå·±çš„ç¼–ç¨‹æŠ€èƒ½å’Œç®—æ³•çŸ¥è¯†ã€‚è¿™äº›æ¯”èµ›é€šå¸¸åˆ†ä¸ºå‡ ä¸ªä¸åŒçš„éš¾åº¦ç­‰çº§ï¼Œé€‚åˆä»åˆå­¦è€…åˆ°é«˜çº§ç¨‹åºå‘˜çš„å„ä¸ªæ°´å¹³ã€‚ åœ¨Codeforcesä¸Šï¼Œå‚èµ›è€…éœ€è¦åœ¨é™å®šæ—¶é—´å†…è§£å†³ä¸€ç³»åˆ—ç¼–ç¨‹é—®é¢˜ã€‚è¿™äº›é—®é¢˜è¦†ç›–äº†æ•°æ®ç»“æ„ã€ç®—æ³•ã€æ•°å­¦ã€å­—ç¬¦ä¸²å¤„ç†ã€å›¾è®ºç­‰ä¼—å¤šé¢†åŸŸã€‚å‚èµ›è€…çš„è¡¨ç°æ ¹æ®è§£å†³é—®é¢˜çš„é€Ÿåº¦å’Œæ­£ç¡®æ€§æ¥è¯„åˆ†ï¼Œå¹¶åœ¨å…¨çƒèŒƒå›´å†…è¿›è¡Œæ’åã€‚ â€“ chatgpt ç”Ÿæˆ ç½‘ç«™: Codeforces rust æ˜¯ä»€ä¹ˆ å…·ä½“æ¥è¯´å°±æ˜¯ ã€ŠRustã€‹æ˜¯ä¸€æ¬¾å¤šäººç”Ÿå­˜æ¸¸æˆï¼Œç©å®¶éœ€æ”¶é›†èµ„æºï¼Œå»ºé€ åº‡æŠ¤æ‰€ï¼Œä¸ç¯å¢ƒå’Œå…¶ä»–ç©å®¶äº’åŠ¨ä»¥æ±‚ç”Ÿå­˜ã€‚æ¸¸æˆä»¥å…¶å¼€æ”¾ä¸–ç•Œã€çœŸå®çš„ç”Ÿå­˜æŒ‘æˆ˜å’Œç©å®¶ä¹‹é—´çš„å¤æ‚äº’åŠ¨é—»åã€‚ Rustæ˜¯ä¸€ç§å¼€æºçš„ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œä»¥å®‰å…¨æ€§ã€é€Ÿåº¦å’Œå¹¶å‘æ€§ä¸ºè®¾è®¡ç›®æ ‡ã€‚å®ƒæ—¨åœ¨å¸®åŠ©å¼€å‘è€…æ„å»ºé«˜æ•ˆã€å¯é çš„è½¯ä»¶ï¼ŒåŒæ—¶é¿å…å¸¸è§çš„å†…å­˜å®‰å…¨é”™è¯¯ï¼Œå¦‚ç¼“å†²åŒºæº¢å‡ºã€‚Rusté€šè¿‡ä¸€å¥—ä¸¥æ ¼çš„ç¼–è¯‘æ—¶æ£€æŸ¥æœºåˆ¶å®ç°è¿™äº›ç›®æ ‡ï¼Œè€Œæ— éœ€ä¾èµ–äºä¼ ç»Ÿçš„åƒåœ¾å›æ”¶æœºåˆ¶æˆ–å¤§é‡çš„è¿è¡Œæ—¶æ£€æŸ¥ã€‚ Rustçš„è®¾è®¡å……åˆ†è€ƒè™‘äº†ç°ä»£ç¡¬ä»¶çš„ç‰¹æ€§ï¼Œæä¾›äº†é›¶æˆæœ¬æŠ½è±¡ã€å®‰å…¨çš„å¹¶å‘ç¼–ç¨‹æ¨¡å‹ï¼Œä»¥åŠå¯¹å†…å­˜å¸ƒå±€çš„ç²¾ç»†æ§åˆ¶ã€‚è¿™äº›ç‰¹æ€§ä½¿Rustæˆä¸ºå¼€å‘æ“ä½œç³»ç»Ÿã€æ¸¸æˆå¼•æ“ã€æµè§ˆå™¨ç»„ä»¶ä»¥åŠéœ€è¦é«˜æ€§èƒ½å’Œé«˜å¯é æ€§çš„åº”ç”¨ç¨‹åºçš„ç†æƒ³é€‰æ‹©ã€‚ â€“ chatgpt ç”Ÿæˆ ç½‘ç«™: Rust Programming Language æ­£æ–‡ rust æ ‡å‡†åº“åªæä¾›äº†ä¸€äº›åŸºæœ¬å’Œå¸¸ç”¨çš„æ•°æ®ç»“æ„å’Œä¸€å¥—&quot;æŠ½è±¡ç‰¹æ€§&quot;(æˆ–è€…è¯´è§„èŒƒ)ï¼Œæ‰€ä»¥å¯èƒ½éœ€è¦æ‰‹åŠ¨é€ ä¸€äº›è½®å­ï¼Œæ¯”å¦‚å¤„ç†è¾“å…¥å’Œéšæœºæ•°ç”Ÿæˆç­‰ç­‰ï¼Œä¸‹é¢å°†ä»‹ç»å¯¹åº”çš„å®ç°ä»£ç ã€‚ å¤„ç†è¾“å…¥ ç›¸è¾ƒäº c++ çš„ scanf ã€cin ï¼Œrust çš„æ ‡å‡†åº“ä¸­ç¼ºå°‘ä¸€ç§æ–¹ä¾¿åœ°ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–å¹¶æ„é€ æ•°æ®çš„æ–¹æ³•ï¼Œç½‘ä¸Šä¹Ÿå­˜åœ¨ä¸€äº›è®¨è®º: Why is it so difficult to get user input in Rust? - help - The Rust Programming Language Forum Why is it so painful to read user inputs in Rust æ‰€ä»¥ä½¿ç”¨ rust è§£å†³ codeforces ä¸­çš„é—®é¢˜æ‰€é‡åˆ°çš„ç¬¬ä¸€ä¸ªå›°éš¾å°±æ˜¯å¦‚ä½•å¤„ç†è¾“å…¥ï¼Œæ‰€å¹¸çš„æ˜¯è¿™ä¸ªé—®é¢˜åœ¨è¿™é‡Œæœ‰æ‰€è®¨è®ºï¼Œå…·ä½“çš„è§£å†³æ–¹æ³•å‚è€ƒè¿™ä¸ªå›å¤ã€‚æ ¹æ®è®¨è®ºä¸­çš„ä»£ç ä¿®æ”¹ï¼Œç¬”è€…ä½¿ç”¨çš„æ¨¡æ¿ä»£ç å¦‚ä¸‹: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pub struct Scanner&lt;B&gt; &#123; reader: B, buf_str: Vec&lt;u8&gt;, buf_iter: std::str::SplitWhitespace&lt;&#x27;static&gt;,&#125;impl&lt;B: BufRead&gt; Scanner&lt;B&gt; &#123; pub fn new(reader: B) -&gt; Self &#123; Self &#123; reader, buf_str: Vec::new(), buf_iter: &quot;&quot;.split_whitespace(), &#125; &#125; pub fn sc&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T &#123; loop &#123; if let Some(token) = self.buf_iter.next() &#123; return token.parse().ok().expect(&quot;Failed parse&quot;); &#125; self.buf_str.clear(); self.reader .read_until(b&#x27; &#x27;, &amp;mut self.buf_str) .expect(&quot;Failed read&quot;); self.buf_iter = unsafe &#123; let slice = std::str::from_utf8_unchecked(&amp;self.buf_str); std::mem::transmute(slice.split_whitespace()) &#125; &#125; &#125;&#125;static mut IN: *mut Scanner&lt;StdinLock&lt;&#x27;static&gt;&gt; = std::ptr::null_mut();#[allow(unused_macros)]macro_rules! i &#123; () =&gt; &#123;&#123; i!(i32) &#125;&#125;; ($t:ty) =&gt; &#123;&#123; unsafe &#123; (*IN).sc::&lt;$t&gt;() &#125; &#125;&#125;;&#125;// ä½¿ç”¨æ–¹æ³•fn main() &#123;\t// éœ€è¦é¦–å…ˆåˆå§‹åŒ–å…¨å±€çš„è¯»å…¥å™¨ã€‚ unsafe &#123; IN = Box::leak(Box::new(Scanner::new(io::stdin().lock()))) as *mut Scanner&lt;StdinLock&lt;&#x27;_&gt;&gt;; &#125;\tlet t = i!(String); // ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å…¥ä¸€ä¸ª stringã€‚\tlet a = i!(); // é»˜è®¤è¯»å…¥çš„ç±»å‹ä¸º i32ã€‚&#125; ä¸‹é¢å¤§è‡´è§£é‡Šä¸€ä¸‹ä»£ç çš„å®ç°ï¼Œé¦–å…ˆæ ¸å¿ƒçš„æ˜¯ä¸€ä¸ªåä¸º Scanner çš„ç»“æ„ä½“ï¼Œå…¶ä¸­çš„ Reader ä¿å­˜äº†æ•°æ®çš„æ¥æºï¼Œå®ƒæ˜¯ä¸€ä¸ª trait ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ä»»æ„å®ç°äº† std::io::BufRead è¿™ä¸€&quot;è§„èŒƒ&quot;çš„ç»“æ„ä½“ã€‚å…·ä½“åˆ°æœ¬ä»£ç åˆ™ä¸ºæ ‡å‡†è¾“å…¥æµã€‚buf_str åˆ™æ˜¯ç”¨äºå‚¨å­˜ä» reader ä¸­è·å–çš„æ•°æ®(æ¯æ¬¡ä»¥è¡Œä¸ºå•ä½è¯»å–æ•°æ®)ã€‚buf_iter ç”¨äºè§£æå’Œè¿­ä»£éå†è¡Œå†…çš„æ•°æ®ã€‚ ä¸€ä¸ªè¯»å…¥çš„è¿‡ç¨‹ä¸º: ä» Reader ä¸­æ ¹æ®æ¢è¡Œç¬¦ä¸ºåˆ†éš”è¯»å–æ•°æ®ï¼Œä¿å­˜åˆ° buf_str ä¸­ï¼Œç„¶åæ ¹æ®ç©ºç™½ç¬¦åšåˆ‡åˆ†ä¿å­˜åˆ° buf_iter ä¸­ï¼Œç„¶åå¯¹æ¯ä¸€å—åšè§£æè½¬æ¢æˆéœ€è¦çš„æ ¼å¼ã€‚ åœ¨ä¹‹åæ˜¯ä¸€ä¸ªå®ï¼Œç”¨äºä¼˜åŒ–ä½¿ç”¨ä½“éªŒã€‚ç„¶è€Œä¸€å®šä¼šä½¿ç”¨åˆ°å…¨å±€å˜é‡ï¼Œrust ä¸­å¯¹äºå…¨å±€å˜é‡çš„ä½¿ç”¨è¾ƒä¸ºç¹çï¼Œè¿™é‡Œé‡‡ç”¨ä¸¤ç§æ–¹æ³•: ä½¿ç”¨å…¨å±€è£¸æŒ‡é’ˆï¼Œä½¿ç”¨ box::leak å°†è¯»å–å™¨å†…å­˜æ³„æ¼ï¼Œç„¶åå°†è£¸æŒ‡é’ˆæŒ‡å‘è¿™å—å†…å­˜è¿›è¡Œè°ƒç”¨ï¼Œä¸è¿‡è¿™ä¸ªéœ€è¦ç”¨åˆ° unsafe ï¼Œç”±äº codeforces ç®—æ³•éƒ½ä¸ºå•çº¿ç¨‹ï¼Œæ‰€ä»¥ä¸ç”¨è€ƒè™‘å¹¶å‘é—®é¢˜ï¼Œæ‰€ä»¥è¿™ä¸ª unsafe æ˜¯å¯æ§çš„ã€‚ ä½¿ç”¨ RefCell è·å–å†…éƒ¨å¯å˜æ€§ã€‚ é€šå¸¸æ¥è¯´ï¼Œåº”è¯¥æ˜¯ä½¿ç”¨å…¨å±€è£¸æŒ‡é’ˆæ€§èƒ½æ›´å¥½ï¼Œå› ä¸º RefCell ä¼šåœ¨è¿è¡ŒæœŸè¿›è¡Œå€Ÿç”¨æ£€æµ‹ã€‚ä½†ç»æµ‹è¯•ä¸¤è€…çš„æ€§èƒ½å·®è·ä¸æ˜æ˜¾ï¼Œæ‰€ä»¥è¯»è€…è‡ªè¡Œé€‰æ‹©ã€‚ å…¨å±€è¯»å–å™¨ä½¿ç”¨è£¸æŒ‡é’ˆå’Œ refcell æ€§èƒ½æµ‹è¯• Â· GitHub 1234567891011121314151617// RefCell æ–¹å¼çš„å…¨å±€å˜é‡thread_local! &#123; pub static STDIN: std::cell::RefCell&lt;Scanner&lt;StdinLock&lt;&#x27;static&gt;&gt;&gt; = std::cell::RefCell::new(Scanner::new(io::stdin().lock()));&#125;#[allow(unused_macros)]macro_rules! safe_i &#123; () =&gt; &#123;&#123; safe_i!(i32) &#125;&#125;; ($t:ty) =&gt; &#123; STDIN.with(|r| &#123; let mut r = r.borrow_mut(); r.sc::&lt;$t&gt;() &#125;) &#125;;&#125; é™¤äº†ä¸Šé¢çš„è§£å†³æ–¹å¼ä¹‹å¤–ï¼Œè®¨è®ºä¸­è¿˜å‡ºç°äº†ä¸€ç§è§£å†³æ–¹å¼ï¼Œå…·ä½“å®ç°åŸç†åŸºæœ¬ä¸Šå’Œ c++ çš„å¿«è¯»æ–¹å¼ç›¸ä¼¼ï¼Œç„¶åé€šè¿‡æŠŠå¿«è¯»å°è£…æˆ traitï¼Œç»™åŸºæœ¬ç±»å‹ä½¿ç”¨å®å®ç°å¿«è¯»çš„ trait å®ç°æ•°æ®çš„è¯»å…¥ã€‚ç†è®ºä¸Šè¿™ç§è¯»å–æ–¹å¼åº”è¯¥æ›´å¿«ï¼Œè¯·è¯»è€…è‡ªè¡Œå–ç”¨ã€‚ å¤„ç†è¾“å‡º å¯¹äºè¾“å‡ºä¹Ÿéœ€è¦ç‰¹æ®Šå¤„ç†ä¸€ä¸‹ï¼Œä½¿ç”¨æ™®é€šçš„ println! å®å¯èƒ½ä¼šå¯¼è‡´è¾“å‡ºæ—¶é—´è¿‡é•¿å¯¼è‡´è¶…æ—¶ã€‚åŸå› æ˜¯æ¯æ¬¡è°ƒç”¨ println! çš„æ—¶å€™éƒ½ä¼šç»™æ ‡å‡†è¾“å‡ºä¸Šé”ã€‚é‡åˆ°éœ€è¦è®¸å¤šè¾“å‡ºçš„é¢˜ç›®å¯èƒ½ä¼šå› ä¸ºé¢‘ç¹ä¸Šé”è§£é”å¯¼è‡´è¾“å‡ºæ—¶é—´è¿‡é•¿ã€‚ println! çš„æ³¨é‡Šä¸­ä¹Ÿæåˆ°å¯ä»¥ä½¿ç”¨ writeln! å®è¿›è¡Œè¾“å‡ºã€‚å¯¹äºè¾“å‡ºåŠ é”å¯¼è‡´å˜æ…¢çš„é—®é¢˜å¯ä»¥ä½¿ç”¨ç¼“å†²åŒºè§£å†³ã€‚å°†è¾“å‡ºä¿å­˜åˆ°ç¼“å†²åŒºä¸­ï¼Œæœ€åè°ƒç”¨ flush! å°†ç¼“å†²åŒºçš„å†…å®¹å†™å…¥è¾“å‡ºæµï¼Œè¿™æ ·å°±å‡å°‘äº†åŠ é”è§£é”çš„æ—¶é—´ï¼Œå®ç°äº†å¿«é€Ÿè¾“å‡ºã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041static mut OUT: *mut std::io::BufWriter&lt;std::io::StdoutLock&lt;&#x27;_&gt;&gt; = std::ptr::null_mut();#[allow(unused_macros)]macro_rules! w &#123; ($fmt:expr) =&gt; &#123; unsafe&#123; write!(*OUT, &quot;&#123;&#125;&quot;, $fmt);&#125; &#125;; ($fmt:expr, $($args:tt)*) =&gt; &#123; unsafe&#123; write!(*OUT, $fmt, $($args)*);&#125; &#125;;&#125;#[allow(unused_macros)]macro_rules! wln &#123; () =&gt; &#123; unsafe&#123; writeln!(*OUT);&#125; &#125;; ($fmt:expr) =&gt; &#123; unsafe&#123; writeln!(*OUT, &quot;&#123;&#125;&quot;, $fmt);&#125; &#125;; ($fmt:expr, $($args:tt)*) =&gt; &#123; unsafe&#123; writeln!(*OUT, $fmt, $($args)*);&#125; &#125;;&#125;#[allow(unused_macros)]macro_rules! flush &#123; () =&gt; &#123; unsafe &#123; (*OUT).flush(); &#125; &#125;;&#125;fn main()&#123; OUT = Box::leak(Box::new(io::BufWriter::new(io::stdout().lock()))) as *mut std::io::BufWriter&lt;std::io::StdoutLock&lt;&#x27;_&gt;&gt;; let a: i32 = 1; wln!(); // è¾“å‡º wln!(a); // è¾“å‡º 1 w!(a); // è¾“å‡º 1 wln!(&quot;test: &#123;&#125;&quot;,a); // è¾“å‡º test: 1 flush!(); // å› ä¸ºå…¨å±€å˜é‡å·²ç»ä¸»åŠ¨æ³„éœ²ï¼Œæ‰€ä»¥æœ€åä¸ä¼šè‡ªåŠ¨ drop ï¼Œæœ€åéœ€è¦æ‰‹åŠ¨è°ƒç”¨ flush å°†æ•°æ®ç”±ç¼“å†²åŒºè¾“å…¥åˆ°æ ‡å‡†è¾“å‡ºæµ&#125; åŒæ ·çš„ï¼Œå¯¹åº”è¾“å‡ºå™¨çš„å…¨å±€å˜é‡ä¹Ÿæœ‰ä¸¤ç§å†™æ³•ï¼Œä¸€ç§ static mut çš„å…¨å±€å˜é‡ï¼Œä¸€ç§æ˜¯ Refcell ï¼Œè¿™é‡Œä½œä¸ºæ€è€ƒé¢˜è¯·è¯»è€…è‡ªè¡Œå®ç°ã€‚ å¤„ç†éšæœºæ•° åŒæ ·çš„ï¼Œrust çš„ std ä¸­æ²¡æœ‰éšæœºæ•°åº“ï¼Œéœ€è¦è‡ªå·±æ‰‹åŠ¨é€ ä¸€ä¸‹è½®å­ã€‚ä»£ç æ¥æºä¸å¯è€ƒäº†ï¼Œè´´ä¸€ä¸‹åŸå§‹çš„è®ºæ–‡å§ï¼š vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf 123456789101112131415161718192021222324252627282930313233343536373839404142#[derive(Debug, Clone, PartialEq, Eq)]struct Rand &#123; s: [u64; 4],&#125;impl Rand &#123; pub fn new(mut state: u64) -&gt; Self &#123; const PHI: u64 = 0x9e3779b97f4a7c15; let mut seed = &lt;[u64; 4]&gt;::default(); for chunk in &amp;mut seed &#123; state = state.wrapping_add(PHI); let mut z = state; z = (z ^ (z &gt;&gt; 30)).wrapping_mul(0xbf58476d1ce4e5b9); z = (z ^ (z &gt;&gt; 27)).wrapping_mul(0x94d049bb133111eb); z = z ^ (z &gt;&gt; 31); *chunk = z; &#125; Self &#123; s: seed &#125; &#125; #[inline] pub fn next_u32(&amp;mut self) -&gt; u32 &#123; (self.next_u64() &gt;&gt; 32) as u32 &#125; #[inline] pub fn next_u64(&amp;mut self) -&gt; u64 &#123; let result_plusplus = self.s[0] .wrapping_add(self.s[3]) .rotate_left(23) .wrapping_add(self.s[0]); let t = self.s[1] &lt;&lt; 17; self.s[2] ^= self.s[0]; self.s[3] ^= self.s[1]; self.s[1] ^= self.s[2]; self.s[0] ^= self.s[3]; self.s[2] ^= t; self.s[3] = self.s[3].rotate_left(45); result_plusplus &#125;&#125; ä½¿ç”¨éšæœºåŒ–ç®—æ³•çš„é¢˜ç›®ä¸æ˜¯ç‰¹åˆ«å¤šï¼Œå…·ä½“ä½¿ç”¨æ–¹æ³•è¯·çœ‹å¦‚ä¸‹ç¤ºä¾‹: Submission #252682933 - Codeforces å›¾æ¨¡æ¿ å›¾çš„è¡¨ç¤ºä¸€èˆ¬ä¸ºé‚»æ¥è¡¨å’Œé‚»æ¥çŸ©é˜µã€‚å¯¹äºé‚»æ¥çŸ©é˜µæ³¨æ„å¦‚æœèƒ½ç”¨å®šé•¿æ•°ç»„å°±ç”¨å®šé•¿æ•°ç»„ã€‚è€Œå¯¹äºé‚»æ¥è¡¨çš„æ•°æ®å­˜å‚¨å¯ä»¥æœ‰ä¸¤ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯æ”¾åœ¨ struct ä¸­ï¼Œæ¯æ¬¡åˆ›å»ºçš„æ—¶å€™éƒ½åˆ†é…ä¸€æ¬¡å†…å­˜ï¼Œæˆ–è€…å°†æ•°æ®å­˜å‚¨å†å…¨å±€å˜é‡ä¸­ï¼ŒåŠ¨æ€åœ°æ‰©å±•é•¿åº¦ã€‚ä»æ€§èƒ½æµ‹è¯•çš„ç»“æœä¹Ÿèƒ½çœ‹å‡ºåé¢ä¸€ç§æ–¹å¼æ˜¯æ›´å¿«çš„ï¼Œç”±äºç®—æ³•é¢˜ä¸­ä¸æ¶‰åŠåˆ°å¹¶å‘é—®é¢˜ï¼Œæ‰€ä»¥æ“ä½œå…¨å±€å˜é‡æ˜¯å®‰å…¨çš„ï¼Œæ‰€ä»¥è¯·å°½æƒ…åœ°ä½¿ç”¨ unsafe å§( å›¾ç»“æ„æ€§èƒ½æµ‹è¯• Â· GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct PathType &#123; from: usize, to: usize, v: i64,&#125;impl fmt::Display for PathType &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; write!(f, &quot;(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;, self.from, self.to, self.v) &#125;&#125;static mut PATHS: Vec&lt;PathType&gt; = vec![];static mut POINT: Vec&lt;Vec&lt;usize&gt;&gt; = vec![];struct Graph &#123; pub start_from: usize,&#125;#[allow(dead_code)]impl Graph &#123; pub fn new(p_size: usize, start_from: usize) -&gt; Graph &#123; unsafe &#123; PATHS.clear(); POINT.reserve((p_size + start_from).saturating_sub(POINT.capacity())); POINT.clear(); POINT.resize_with(p_size + start_from, || vec![]); &#125; Graph &#123; start_from &#125; &#125; pub fn add_path(&amp;mut self, from: usize, to: usize, v: i64) &#123; unsafe &#123; POINT[from].push(PATHS.len()); PATHS.push(PathType &#123; from, to, v &#125;); &#125; &#125; pub fn add_bi_path(&amp;mut self, from: usize, to: usize, v: i64) &#123; unsafe &#123; POINT[from].push(PATHS.len()); PATHS.push(PathType &#123; from, to, v &#125;); POINT[to].push(PATHS.len()); PATHS.push(PathType &#123; from: to, to: from, v, &#125;); &#125; &#125; pub fn get(&amp;self, now_p: usize) -&gt; impl Iterator&lt;Item = &amp;&#x27;_ PathType&gt; &#123; unsafe &#123; POINT[now_p].iter().map(move |x| PATHS.get_unchecked(*x)) &#125; &#125;&#125;impl fmt::Display for Graph &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; unsafe &#123; for now_p in self.start_from..POINT.len() &#123; write!(f, &quot;&#123;&#125; -- &quot;, now_p); for path in self.get(now_p) &#123; write!(f, &quot;&#123;&#125; &quot;, path)? &#125; writeln!(f)? &#125; &#125; Ok(()) &#125;&#125; ä½¿ç”¨æ–¹æ³•å‚è§: Submission #252942104 - Codeforces æŸ¯é‡ŒåŒ– æŸ¯é‡ŒåŒ–åœ¨ç®—æ³•é¢˜ä¸­ä½¿ç”¨ä¸å¤šï¼Œå¤§éƒ¨åˆ†ä½œç”¨éƒ½æ˜¯ä¸ºäº†ä¿å­˜å±€éƒ¨å˜é‡ï¼Œç”¨äºä¼ é€’ç»™å‡½æ•°(ç”±äº rust ä¸é¼“åŠ±ä½¿ç”¨å…¨å±€å˜é‡ï¼Œæ‰€ä»¥å®¹æ˜“å¯¼è‡´ä¼ é€’è¾ƒå¤šçš„å˜é‡)ã€‚å½“ç„¶è¿™ç§åŠŸèƒ½ä¹Ÿèƒ½ä½¿ç”¨é—­åŒ…å®ç°ï¼Œå°±è¯·è¯»è€…è‡ªè¡Œå–ç”¨å§ã€‚ä½¿ç”¨æ–¹æ³•å‚è§: Submission #252806831 - Codeforces 123456789101112131415#[allow(unused_macros)]macro_rules! curry2 ( ($f:expr) =&gt; &#123; |a| move |b| $f(a, b) &#125;;);#[allow(unused_macros)]macro_rules! curry3 ( ($f:expr) =&gt; &#123; |a| move |b| move |c| $f(a, b, c) &#125;;);// æºè‡ª Rust å¦‚ä½•å®ç°æŸ¯é‡ŒåŒ–ï¼Ÿ - Sporeçš„å›ç­” - çŸ¥ä¹// https://www.zhihu.com/question/437123518/answer/1655807344 è‡³æ­¤ï¼Œè¯·æ„‰å¿«åœ°ä½¿ç”¨ rust å—è‹¦ç©è€å§(","categories":["blog"]},{"title":"ä¸ºå•¥ go ä¸æ”¯æŒæ³›å‹æ–¹æ³•","path":"/pages/blog/ä¸ºå•¥ go ä¸æ”¯æŒæ³›å‹æ–¹æ³•.html","content":"å¼•è¨€ ä¼—æ‰€å‘¨çŸ¥ï¼Œ go çš„æ³›å‹å¹¶ä¸å®Œå–„ï¼Œç”±äºå…¶ä¸æ”¯æŒ parameterized methods (æ³›å‹æ–¹æ³•)ï¼Œå¯¼è‡´å…¶æ— æ³•å®ç° monadã€æµå¼è°ƒç”¨ç­‰ç­‰æ“ä½œã€‚åœ¨è¿™ä¸ª issue ä¸­ proposal: spec: allow parameterized methods in methods Â· Issue #49085 Â· golang/go Â· GitHub æœ‰ç€å……åˆ†çš„è®¨è®ºï¼Œæœ¬æ–‡æ—¨åœ¨å¯¹å…¶ä¸­çš„è®¨è®ºè¿›è¡Œæ€»ç»“(åŠ ä¸€ç‚¹æŒ‡æŒ‡ç‚¹ç‚¹)ï¼Œæ‰¾å‡º go æ˜¯ xx çš„åŸå› ï¼Œå¦‚æœ‰é”™è¯¯æ³è¯·æ–§æ­£ã€‚ æœ‰ç‚¹é•¿çš„å‰ç½®çŸ¥è¯†â€¦ åœ¨çœ‹ issue ä¹‹å‰ï¼Œé¦–å…ˆä»‹ç»ä¸€ä¸‹æ³›å‹çš„é€šå¸¸å®ç°æ–¹å¼ï¼Œä¸€èˆ¬æœ‰å¦‚ä¸‹å‡ ç§æ–¹å¼ ç±»å‹æ“¦é™¤+è™šå‡½æ•°è¡¨: è¿™æ˜¯ Java æ³›å‹çš„å®ç°æ–¹å¼ã€‚åœ¨ç¼–è¯‘æ—¶ï¼Œæ³›å‹ç±»å‹ä¿¡æ¯ä¼šè¢«æ“¦é™¤ï¼Œæ‰€æœ‰çš„æ³›å‹è¢«è½¬æ¢ä¸ºåŸºç±» Object (åœ¨ go ä¸­ç›¸å½“äºå°†æ‰€æœ‰çš„ç±»å‹å˜æˆ interface{} )ï¼Œç¼–è¯‘å™¨åŒæ—¶ä¼šåœ¨å¿…è¦æ—¶æ’å…¥ç±»å‹è½¬æ¢ä»£ç æ¥ç¡®ä¿ç±»å‹å®‰å…¨ã€‚ æ¨¡æ¿å®ä¾‹åŒ–: C++ ä½¿ç”¨æ¨¡æ¿æ¥å®ç°æ³›å‹ã€‚åœ¨ç¼–è¯‘æ—¶ï¼Œæ¨¡æ¿ä¼šç”Ÿæˆå¯¹åº”äºæ¯ç§å…·ä½“ç±»å‹çš„å®ä¾‹åŒ–ä»£ç ã€‚å¦‚ T add(T a, T b) çš„æ³›å‹æ–¹æ³•ï¼Œå¯¹äº add(1,2) å’Œ add(1.0,2.0) ä¼šç”Ÿæˆä¸¤ä¸ªå‡½æ•° int add(int a, int b) å’Œ double add( double a, double b) ã€‚ å³æ—¶ç¼–è¯‘: How Generics Differ in Java and C# | HackerNoon, C#æ³›å‹è¯¦è§£ - çŸ¥ä¹, c# - What is reification? - Stack Overflowï¼Œä»è¿™äº›é“¾æ¥å¯ä»¥å¤§è‡´çœ‹å‡ºï¼Œc# çš„æ³›å‹å®ç°æ˜¯ç¼–è¯‘æ—¶ä½¿ç”¨å ä½ç¬¦è¡¨ç¤ºæ³›å‹ç±»å‹ï¼Œç„¶ååœ¨è¿è¡Œæ—¶åŠ¨æ€å®ä¾‹åŒ–å„ç§ç±»å‹ã€‚ å›åˆ° go çš„æ³›å‹ï¼Œå®é™…ä¸Š go çš„æ³›å‹å®ç°æ–¹å¼æœ‰ä¸‰ç§ææ¡ˆï¼Œä¸‹é¢åˆ†åˆ«ä»‹ç»è¿™ä¸‰ç§ææ¡ˆï¼Œæœ‰åŠ©äºåç»­å¯¹ issue ä¸­çš„è®¨è®ºè¿›è¡Œåˆ†æã€‚(æœ¬æ¥æƒ³ç®€å•å†™å†™çš„ï¼Œå†™ç€å†™ç€å¤ªé•¿äº†ï¼Œä¸æƒ³çœ‹çš„è¯·è·³è‡³ æ­£æ–‡ éƒ¨åˆ†) Stenciling Generics implementation - Stenciling é¦–å…ˆæ˜¯è¢«ç§°ä¸ºèœ¡å°(Stenciling) çš„å®ç°ï¼Œå®é™…ä¸Šè¿™ä¸ª c++ã€rust çš„æ³›å‹å®ç°æ–¹æ³•å¾ˆç›¸ä¼¼ï¼Œéƒ½æ˜¯åœ¨ç¼–è¯‘å®ä¾‹åŒ–æ‰€æœ‰çš„ç±»å‹ï¼Œç”Ÿæˆå¤šä¸ªå¯¹åº”ç±»å‹çš„å‡½æ•°ã€‚ å¯¹äºå¦‚ä¸‹æ³›å‹å‡½æ•°: 123func f[T1, T2 any](x int, y T1) T2 &#123; ...&#125; å­˜åœ¨å¦‚ä¸‹ä¸¤ä¸ªè°ƒç”¨: 12var a float64 = f[int, float64](7, 8.0)var b struct&#123;f int&#125; = f[complex128, struct&#123;f int&#125;](3, 1+1i) ä½¿ç”¨ Stenciling æ–¹æ³•ä¼šå®ä¾‹åŒ–ä¸¤ä¸ªç±»å‹å‡½æ•°ç”¨äºè°ƒç”¨: 123456func f1(x int, y int) float64 &#123; ... identical bodies ...&#125;func f2(x int, y complex128) struct&#123;f int&#125; &#123; ... identical bodies ...&#125; ç”±äºä¸æ˜¯ go æ³›å‹çš„å®é™…å®ç°ï¼Œæ‰€ä»¥å…¶ä¸­æ‰€æåˆ°çš„å‘½åå®ç°ã€å®ä¾‹åŒ–æ–¹æ³•ã€ç±»å‹çº¦æŸå’Œé‡å¤å®ä¾‹åŒ–ä»£ç å¤„ç†å°±ä¸ç»†è¯´äº†ã€‚å…·ä½“æä¸€ä¸‹å…¶ä¸­çš„é—®é¢˜éƒ¨åˆ†ã€‚ é—®é¢˜ å¯¹äº Stenciling æ–¹æ³•ï¼Œææ¡ˆæå‡ºä¸¤ä¸ªé—®é¢˜: ç¼–è¯‘æœŸå®ä¾‹åŒ–æ³›å‹å¯¼è‡´ç¼–è¯‘æ—¶é—´å˜é•¿ ç¼–è¯‘æœŸå®ä¾‹åŒ–æ³›å‹å¯¼è‡´ç”Ÿæˆçš„ä»£ç å˜å¤šï¼Œç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶å˜å¤§ï¼Œæœ‰å¯èƒ½å¯¼è‡´ instruction cache miss å’Œ åˆ†æ”¯é¢„æµ‹å¤±æ•ˆ(ä¸ºå•¥?)ç­‰é—®é¢˜ã€‚ ææ¡ˆæœ«å°¾ä¸­å¤§è‡´æå‡ºäº†ä½¿ç”¨å¢é‡ç¼–è¯‘å‡å°‘ç¼–è¯‘æ—¶é—´ã€å¤šæ¬¡è°ƒç”¨ç¼–è¯‘å™¨æ¥å»é™¤é‡å¤çš„å®ä¾‹åŒ–ä»£ç (å› ä¸º go æ˜¯ä»¥åŒ…ç»´åº¦è¿›è¡Œç¼–è¯‘çš„)ç­‰æ–¹æ¡ˆã€‚ä¸è¿‡è¿™äº›éƒ½ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯ææ¡ˆä¸­çš„ä¸€æ®µè¯: I suspect there will be lots of cases where sharing is possible, if the underlying types are indistinguishable w.r.t. the garbage collector (same size and ptr/nonptr layout) ææ¡ˆè®¤ä¸ºå°½ç®¡ç±»å‹å¯ä»¥æœ‰å¾ˆå¤šä¸ª(å¦‚ int ã€type IntAlias = int )ï¼Œä½†å®é™…ä¸Šå†…å­˜å¸ƒå±€éƒ½æ˜¯ç›¸åŒçš„ï¼Œç›¸åŒå†…å­˜å¸ƒå±€çš„å€¼ç±»å‹å¯ä»¥å…±äº«ä»£ç ï¼Œè¿™å°±å‡å°‘äº†ç”Ÿæˆçš„ä»£ç å¤§å°åŒæ—¶ä¹ŸåŠ å¿«äº†ç¼–è¯‘æ—¶é—´ã€‚å®é™…ä¸Šè¿™å°±æ˜¯ go å®é™…çš„æ³›å‹å®ç°(GC Shape Stenciling) ã€‚ Dictionaries Generics implementation - Dictionaries å­—å…¸(Dictionaries)æ–¹å¼çš„å®ç°æ–¹å¼æ­£å¦‚å…¶åï¼Œå¯¹äºå¦‚ä¸‹æ³›å‹å‡½æ•°: 123func f[T1, T2 any](x int, y T1) T2 &#123; ...&#125; å­˜åœ¨å¦‚ä¸‹ä¸¤ä¸ªè°ƒç”¨: 12var a float64 = f[int, float64](7, 8.0)var b struct&#123;f int&#125; = f[complex128, struct&#123;f int&#125;](3, 1+1i) é‚£ä¹ˆç¼–è¯‘å…¶ä¼šå®ä¾‹åŒ–ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—å…¸ã€‚åŒæ—¶ä¼šæœ‰å¤šä¸ªå­—å…¸ï¼Œæ¯ä¸ªå­—å…¸åŒ…å«ä¸€äº›è¿è¡Œæ—¶éœ€è¦çš„ä¿¡æ¯ï¼Œä¼ å…¥çš„å­—å…¸å†…å®¹ç”±è°ƒç”¨ç‚¹ç”Ÿæˆå’Œä¼ å…¥: 1234567891011type pos1CallSiteDictionary struct &#123;\t... runtime._type&#125;type pos2CallSiteDictionary struct &#123;\t... runtime._type&#125;func f (type_info dictionary, x int, y T1) T2 &#123; ...&#125; dictionary åŒ…å«çš„ä¿¡æ¯ å¯¹äºå½¢å¦‚ f [T1, T2] çš„æ³›å‹å‡½æ•°ï¼Œæ‰€éœ€è¦çš„ä¿¡æ¯å¦‚ä¸‹: Instantiated types é¦–å…ˆéœ€è¦åŒ…å«å‡½æ•°ç­¾åä¸Šçš„ç±»å‹ï¼Œå¯èƒ½ä»¥å¦‚ä¸‹å½¢å¼è¿›è¡Œå­˜å‚¨ 12345type dictionary struct &#123; T1 *runtime._type T2 *runtime._type ...&#125; å‡ºäºæ‰“å°æ ˆçš„ç›®çš„ï¼Œå­—å…¸ä¸­éœ€è¦åŒ…å«æœªè¢«ä½¿ç”¨çš„ç±»å‹ï¼Œå³å³ä½¿ T2 æ²¡æœ‰åœ¨å‡½æ•°ä¸­ç”¨åˆ°ä¹Ÿéœ€è¦ä¿å­˜ T2 çš„ç±»å‹ (ä¸ºå•¥ä¸ç¦æ­¢æœªä½¿ç”¨çš„æ³›å‹ç±»å‹å‘¢â€¦)ã€‚ Derived types é™¤äº†å‡½æ•°ç­¾åä¸Šçš„ç±»å‹ï¼Œå­—å…¸ä¸­è¿˜éœ€è¦ä¿å­˜å‡½æ•°ä¸­æ´¾ç”Ÿå‡ºçš„ç±»å‹ï¼Œæ¯”å¦‚æ³›å‹å‡½æ•°ä¸­å¦‚æœå®šä¹‰äº†å¦‚ä¸‹ç±»å‹: 12type X struct &#123; x int; y T1 &#125;m := map[string] T1&#123;&#125; é‚£ä¹ˆéœ€è¦ä¿å­˜æ´¾ç”Ÿå‡ºæ¥çš„ç±»å‹: 123456type dictionary struct &#123; ... D1 *runtime._type // struct &#123; x int; y T1 &#125; D2 *runtime._type // map[string] T1 ...&#125; Subdictionaries å¦‚æœæ³›å‹ä¸­å‡½æ•°è°ƒç”¨äº†å…¶ä»–çš„æ³›å‹å‡½æ•°ï¼Œè¿˜éœ€è¦ä¿å­˜å¯¹åº”æ³›å‹å‡½æ•°çš„å­—å…¸ã€‚è¿™æ ·æ‰èƒ½æ¥ç€ä¼ é€’ dictionary å‚æ•°ï¼Œè°ƒç”¨å¯¹åº”çš„æ³›å‹å‡½æ•°ï¼Œææ¡ˆä¸­ç§°ä¹‹ä¸ºå­å­—å…¸: 1234567// func g[T](g T) &#123; ... &#125;// in f[T1]: g[T1] (y)type dictionary struct &#123; ... S1 *dictionary // SubDictionary for call to g ...&#125; Helper methods å­—å…¸ä¸­è¿˜éœ€è¦ä¿å­˜æ³›å‹ç±»å‹çš„æ“ä½œç¬¦ï¼Œæ¯”å¦‚å¯¹äºå¦‚ä¸‹è¿ç®—: 12y2 := y + 1if y2 &gt; y &#123; â€¦ &#125; ä¸ºäº†è¡¨è¾¾æ³›å‹æ“ä½œï¼Œéœ€è¦å°†å…¶ä¸­çš„ + å’Œ &gt; æŠ½è±¡å‡ºæ¥å˜æˆä¸€ç§æ–¹æ³•ä¿å­˜åˆ°å­—å…¸ä¸­: 123456type dictionary struct &#123; ... plus func(z, x, y *T1) // does *z = *x+*y greater func(x, y *T1) bool // computes *x&gt;*y ...&#125; Stack layout å› ä¸ºç±»å‹ä¸ç¡®å®šï¼Œå­—å…¸ä¸­è¿˜éœ€è¦ä¿å­˜å‡½æ•°ä¸­æ‰€æœ‰éæŒ‡é’ˆç±»å‹ä¸´æ—¶å˜é‡çš„å ç”¨ç©ºé—´ï¼Œç”¨äºåˆ†é…æ ˆç©ºé—´ã€‚è€Œä¹‹å‰æåˆ°è¿‡ï¼Œå­—å…¸æ˜¯ç”±è°ƒç”¨ç‚¹ä¼ å…¥çš„ï¼Œå› ä¸ºåªæœ‰è°ƒç”¨ç‚¹æ‰çŸ¥é“æ‰€æœ‰çš„ç±»å‹ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨ç‚¹éœ€è¦è®¡ç®—æ‰€éœ€è¦çš„æ ˆç©ºé—´ã€‚ç„¶åå­—å…¸ä¸­è¿˜éœ€è¦ä¿å­˜æ¯ä¸ªä¸´æ—¶å¯¹è±¡åœ¨æ ˆå†…çš„åœ°å€ã€‚ 12345678910type dictionary struct &#123; ... frameSize uintptr stackObjects []stackObject ...&#125;type stackObject struct &#123; offset uintptr typ *runtime._type&#125; å¯¹äºæ³›å‹å‡½æ•°çš„åµŒå¥—è°ƒç”¨ä¹Ÿéœ€è¦ç‰¹æ®Šå¤„ç†ã€‚å¯¹äºå¦‚ä¸‹å‡½æ•°è°ƒç”¨: 12345func f[T1, T2 any](x int, y T1, h func(x T1, y int, z T2) int) T2 &#123; var z T2 .... r := h(y, x, z)&#125; ææ¡ˆä¸­æå‡ºäº†ä¸¤ç§æ–¹æ³•: é€ä¸ªå‚æ•°å¤„ç† é€ä¸ªå¤„ç†å‚æ•°ï¼Œå°†å‚æ•°å¤åˆ¶åˆ°æ ˆä¸Šæ­£ç¡®çš„ä½ç½®: 1234567891011argPtr = SPmemmove(argPtr, &amp;y, dictionary.T1.size)argPtr += T1.sizeargPtr = roundUp(argPtr, alignof(int))*(*int)argPtr = xargPtr += sizeof(int)memmove(argPtr, &amp;z, dictionary.T2.size)argPtr += T2.sizecall hargPtr = roundUp(argPtr, 8) // alignment of return value startr = *(*int)argPtr ä½¿ç”¨å­—å…¸å­˜å‚¨åç§»é‡ æˆ–è€…æå‰è®¡ç®—å‡ºè°ƒç”¨å‡½æ•°çš„å…¥å‚å‡ºå‚åœ¨æ ˆä¸Šçš„åç§»é‡ï¼Œç„¶åä¿å­˜åˆ°å­—å…¸ä¸­ï¼Œä½¿ç”¨çš„æ—¶å€™æ ¹æ®åç§»é‡å¤åˆ¶å‚æ•°: 12345memmove(SP + dictionary.callsite1.arg1offset, &amp;y, dictionary.T1.size)*(*int)(SP + dictionary.callsite1.arg2offset) = xmemmove(SP + dictionary.callsite1.arg3offset, &amp;z, dictionary.T2.size)call hr = *(*int)(SP + dictionary.callsite1.ret1offset) Pointer maps éœ€è¦ä¸€ä¸ª bitMap å­˜å‚¨å…¥å‚å‡ºå‚çš„ç©ºé—´å¤§å°å’Œæ˜¯å¦æ˜¯æŒ‡é’ˆç±»å‹ã€‚ç”¨äºè°ƒç”¨è€…åˆ†é…ç©ºé—´å…¥å‚å’Œå‡ºå‚ç©ºé—´ã€‚ 12345type dictionary struct &#123; ... argPointerMap bitMap // arg size and ptr/nonptr bitmap ...&#125; é—®é¢˜ ææ¡ˆä¸­æåˆ°äº†è™½ç„¶é‡‡ç”¨å­—å…¸æ–¹æ³•å‡å°‘äº†ä»£ç çš„ç”Ÿæˆï¼Œä½†æ˜¯å ç”¨çš„å†…å­˜å˜å¤šäº†ï¼ˆä»ä¸Šé¢ä¹Ÿå¯ä»¥çœ‹å‡ºä¸€ä¸ªæ³›å‹ç¤ºä¾‹è¦å­˜å‚¨å¤šå°‘ä¿¡æ¯ï¼‰ã€‚è¿™ä¹Ÿå‡ºç°äº† data cache misses å’Œ instruction cache misses çš„æ›¿æ¢ã€‚éœ€è¦æ‰¾ä¸€ç§æŠ˜ä¸­çš„æ–¹æ³•ã€‚ è¿˜æœ‰ææ¡ˆä¸­æåˆ°ä½¿ç”¨å­—å…¸æ–¹æ³•ä¹Ÿæœ‰å¯èƒ½å¯¼è‡´æ€§èƒ½çš„ä¸‹é™ï¼Œæ¯”å¦‚å½“æ³›å‹æ–¹æ³•ä¸­å…·ä½“ç±»å‹ä¸º int çš„æƒ…å†µï¼Œx=y çš„æ“ä½œåœ¨ä½¿ç”¨èœ¡å°æ–¹æ³•å¯ä»¥ä¼˜åŒ–æˆä¸€æ¬¡å¯„å­˜å™¨å¤åˆ¶çš„æ“ä½œï¼Œè€Œä½¿ç”¨å­—å…¸çš„æ–¹æ³•ï¼Œç”±äºéœ€è¦å¤„ç†ä¸åŒç±»å‹çš„æ•°æ®ï¼Œåªèƒ½ä½¿ç”¨ memmove æ“ä½œå¤åˆ¶æ•°æ®ï¼Œè¿™æ— ç–‘æ˜¯ä¸€ç§é¢å¤–çš„å¼€é”€ã€‚ GC Shape Stenciling ï¼æœ¬èŠ‚çš„åˆ†æåŸºäºææ¡ˆå’Œ go 1.18ï¼Œéƒ¨åˆ†ä¿¡æ¯å¯èƒ½å’Œé«˜ç‰ˆæœ¬çš„ go æœ‰æ‰€ä¸åŒï¼Œè¯·æ³¨æ„åŒºåˆ†ã€‚ Generics implementation - GC Shape Stenciling proposal/design/generics-implementation-dictionaries-go1.18.md at master Â· golang/proposal Â· GitHub GC Shape Stenciling æ˜¯ go çš„çœŸæ­£æ³›å‹å®ç°ã€‚å®ƒæ˜¯ Stenciling å’Œ Dictionaries çš„æŠ˜ä¸­å®ç°ã€‚GC Shape åœ¨ææ¡ˆä¸­çš„è§£é‡Šæ˜¯: TheÂ GC shapeÂ of a type means how that type appears to the allocator / garbage collector. ä¸¾ä¾‹æ¥è¯´ int å’Œ type IntAlias = int æ˜¯å±äºä¸€ä¸ª GC Shapeï¼Œæ¯”è¾ƒç‰¹åˆ«çš„æ˜¯å¯¹äºæ‰€æœ‰çš„æŒ‡é’ˆç±»å‹å±äºä¸€ä¸ª GC Shapeï¼Œä½¿ç”¨è™šè¡¨è¿›è¡Œæ–¹æ³•çš„è°ƒç”¨ã€‚ å¯¹äºæ¯ä¸€ä¸ª GC Shapeï¼Œgo ä¼šå®ä¾‹åŒ–ä¸€ä¸ªå…·ä½“çš„ä»£ç ï¼Œå…·ä½“æ¥è¯´ï¼Œå¯¹äºå¦‚ä¸‹ 12345678910111213141516171819package mainfunc f[T any] (t T) T &#123;\tvar x T\treturn x&#125;type MyInt inttype IntAlias = intfunc main() &#123;\tf[int](5)\tf[MyInt](5)\tf[IntAlias](5)\tf[*int](nil)\tf[*MyInt](nil)\tf[interface&#123;&#125;](nil)&#125; æ­£æ–‡ ä¸‹é¢ç»ˆäºæ¥åˆ° issue åˆ†æç¯èŠ‚ã€‚ é¦–å…ˆæ˜¯æœ‰äººæå‡ºç”±äº go çš„æ³›å‹ä¸æ”¯æŒ parameterized methodsï¼Œæ‰€ä»¥å¦‚ä¸‹ä»£ç æ— æ³•ç¼–è¯‘: 1func (si *stream[IN]) Map[OUT any](f func(IN) OUT) stream[OUT] è¿™å°±å¯¼è‡´äº†åœ¨ go ä¸­æ— æ³•å®ç°å¸¸è§„çš„æµå¼å¤„ç†æ–¹æ³•ã€‚æé—®äººä¹Ÿæå‡ºå¦‚æœ go èƒ½æ”¯æŒ parameterized methodsï¼Œé‚£ä¹ˆæŸäº›é¢†åŸŸåœ¨æ„é€ ä»£ç çš„æ—¶å€™ä¼šæ›´åŠ ç®€ä¾¿ï¼Œä¾‹å¦‚(ä¸¾çš„ä¾‹å­å¥‡å¥‡æ€ªæ€ªçš„ï¼Œçœ‹ç€ä¹Ÿæ²¡ç”¨åˆ° parameterized methods): testing (?): Assert(actual).ToBe(expected) mocking (?): On(obj.Sum).WithArgs(7, 8).ThenReturn(15) åŸå›  ä¹‹åæœ‰äººè´´å‡º go ä¸æ”¯æŒ parameterized methods çš„åŸå› : parameterized methods Proposalã€‚è€ƒè™‘å¦‚ä¸‹ä»£ç : 123456789101112131415161718192021222324252627package p1type S struct&#123;&#125;func (S) Identity[T any] (v T) T &#123; return v &#125;package p2type HasIdentity interface &#123;\tIdentity[T any] (T) T&#125;package p3import &quot;p2&quot;func CheckIdentity(v interface&#123;&#125;) &#123;\tif vi, ok := v.(p2.HasIdentity); ok &#123; if got := vi.Identity[int] (0); got != 0 &#123; panic(got) &#125;\t&#125;&#125;package p4import (\t&quot;p1&quot;\t&quot;p3&quot;)func CheckSIdentity() &#123;\tp3.CheckIdentity(p1.S&#123;&#125;)&#125; åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œp1 ä¸­çš„ S å®ç°äº† p2 ä¸­çš„ HasIdentity æ¥å£ï¼Œåœ¨ p3 ä¸­æœ‰ä¸€ä¸ªå‡½æ•°å®ç°äº†å°†å…¥å‚æ–­è¨€ä¸º HasIdentity å¹¶è°ƒç”¨å…¶ä¸­çš„å‡½æ•°çš„åŠŸèƒ½ã€‚åœ¨ p4 ä¸­è°ƒç”¨äº† p3 ä¸­çš„å‡½æ•°å¹¶ä¼ å…¥äº† p1 ä¸­å®šä¹‰çš„ Sã€‚ çœ‹ç€è¿˜æŒºåˆç†ï¼Œä½†æ˜¯é—®é¢˜æ¥äº†ï¼Œåœ¨ p3 ä¸­çš„ CheckIdentity åœ¨æ–­è¨€å®Œå…¥å‚åï¼Œè°ƒç”¨äº†ä¸€ä¸ªç±»å‹ä¸º int çš„ Identity å‡½æ•°ã€‚æ ¹æ®ä¸Šé¢å‡½æ•°çš„è°ƒç”¨é“¾æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå®ƒå…¶å®æ˜¯åœ¨è°ƒç”¨ p1.S.Identity[int]ï¼Œåªéœ€è¦å®ä¾‹åŒ–ä¸€ä¸ª p1.S.Identity[int] ä»£ç å—å³å¯ã€‚ç„¶è€Œï¼Œç”±äº go çš„å¤§é“è‡³ç®€ï¼Œç±»å‹åªæœ‰é€šè¿‡ import æ‰å¯è§ï¼Œä¹Ÿå°±æ˜¯è¯´ p3 æ˜¯æ— æ³•æ„ŸçŸ¥åˆ° p1.S è¿™ä¸ªç±»å‹çš„ï¼Œæ‰€ä»¥å®ä¾‹åŒ– p1.S.Identity[int] ä¹Ÿå°±æ— ä»è¯´èµ·äº†ã€‚ ä¹‹åææ¡ˆä¸­ç»™å‡ºäº†ä¸‰ä¸ªæ–¹æ¡ˆ: ç¼–è¯‘å™¨åŠªåŠªåŠ›ï¼Œæ ¹æ®å‡½æ•°çš„è°ƒç”¨é“¾å®ä¾‹åŒ–å¯¹åº”çš„å‡½æ•°ã€‚ç„¶è€Œç”±äº go ä¸­çš„åå°„çš„å­˜åœ¨ï¼Œåœ¨ç¼–è¯‘æœŸå®é™…ä¸Šæ— æ³•ç¡®å®šæ‰€æœ‰çš„å‡½æ•°è°ƒç”¨é“¾ ã€‚(è¿™ä¸ªä¹Ÿæ˜¯æˆ‘æ„Ÿè§‰ go æ”¯æŒ parameterized methods é‡Œæœ€éš¾å—çš„åœ°æ–¹) å­¦ä¹  java or C#ï¼Œè¿è¡Œæ—¶å®ä¾‹åŒ–ï¼Œè¿™å°±å¯¼è‡´äº† go éœ€è¦æ”¯æŒæŸç§ JITï¼Œæˆ–è€…ä½¿ç”¨åŸºäºåå°„çš„æ–¹æ³•ï¼Œè¿™äº›å®ç°èµ·æ¥éƒ½ååˆ†å¤æ‚ï¼Œè€Œä¸”ä¼šå¯¼è‡´è¿è¡Œæ—¶é€Ÿåº¦å˜æ…¢ã€‚ çº¦æŸ interface ä¸­ç¦ç”¨ parameterized methods ï¼Œå› ä¸ºæ— æ³•æ„ŸçŸ¥ç±»å‹çš„åŸå› å°±æ˜¯ interface å°†å®é™…ç±»å‹ä¿¡æ¯éšè—äº†ï¼Œä¸è¿‡è¿˜æ˜¯å­˜åœ¨åå°„çš„é—®é¢˜(ç›´æ¥ç¦æ­¢åå°„è°ƒç”¨æ³›å‹å‡½æ•°?)ï¼š 1234567type S struct&#123;&#125;func (S) Identity[T any] (v T) T &#123; return v &#125;func main() &#123;\tf, _ := reflect.TypeOf(S&#123;&#125;).MethodByName(&quot;Identity&quot;)\tf.Func.Call([]reflect.Value&#123;reflect.ValueOf(S&#123;&#125;), reflect.ValueOf(0)&#125;)&#125; åœ¨è¿™é‡Œæˆ‘æƒ³è®²ä¸€è®²ç¬¬ä¸‰ç‚¹ï¼Œææ¡ˆç»™å‡ºçš„åŸæ–‡æ˜¯: Or, we could decide that parameterized methods do not, in fact, implement interfaces, but then itâ€™s much less clear why we need methods at all. If we disregard interfaces, any parameterized method can be implemented as a parameterized function. åé¢è¿™ä¸€æ®µçœŸçš„æ˜¯è¿·æƒ‘å‘è¨€(issue é‡Œæœ‰äº›äººä¹Ÿå¯¹è¿™æ®µæå‡ºç–‘é—®)ï¼Œææ¡ˆä½œè€…è®¤ä¸ºå¦‚æœ parameterized methods ä¸å‚ä¸ interface çš„å®ç°ï¼ˆç›¸å½“äºåœ¨ interface ä¸­ç¦ç”¨ parameterized methods äº†ï¼‰, é‚£ä¸ºå•¥è¿˜éœ€è¦ parameterized methodï¼Œå› ä¸ºæ‰€æœ‰çš„ parameterized method éƒ½å¯ä»¥ç”¨ parameterized function å®ç°ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ éš¾ä¸æˆä½œè€…è®¤ä¸º func (S[T]) F[ M, U] ( M ) U å¯ä»¥ç®€å•ç­‰æ•ˆä¸º func F[T, M, U] (T, M) U ï¼Œæ‰€ä»¥è°ƒç”¨æ–¹å¼ x.f(y).g(z) å’Œ g(f(x,y),z) æ²¡åŒºåˆ« ğŸ¤”ï¼Ÿé‚£ go è¯­è¨€å†™èµ·æ¥é‚£ä¹ˆå•°å—¦çš„åŸå› æ‰¾åˆ°äº†(ã€‚ å…·ä½“æ¥è¯´è¯·çœ‹è¿™ä¸ªè¯„è®º å’Œè¿™ä¸ªè¯„è®ºã€‚ åé¢ä½œè€…çš„è¡¥å……ä¹Ÿå¾ˆè¿·æƒ‘: proposal: spec: allow parameterized methods in methods Â· Issue #49085 Â· golang/go Â· GitHubï¼Œä¸äºˆç½®è¯„äº†ã€‚ è®¨è®º ç”±äºä¹‹åçš„å…³äºè§£å†³æ³›å‹æ–¹æ³•çš„é—®é¢˜è®¨è®ºå¤ªé•¿ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥çœç•¥éƒ¨åˆ†è¯„è®º(æœ‰äº›ä¸æ˜¯å…³äºæ³›å‹çš„è®¨è®º)å¹¶ä¸”æ ¹æ® issue é‡Œæå‡ºçš„ä¸åŒè§£å†³æ–¹æ¡ˆè¿›è¡Œåˆ†ç±»ã€‚ gavaæ´¾ I think that the example issue can be approached the same way as Java does: usingÂ interface&#123;&#125;Â behind the scenes and panic if the customer did a bad assignment (also the compiler could warn about the unsafe operation). â€“link How about using type erasure to handle the generic method issue? â€“link interface ä»£è¡¨ä¸€åˆ‡ï¼ä¸è¿‡æ˜¾ç„¶ gava å’Œ anygo æ˜¯ä¸è¡Œæ»´ã€‚ è¯­æ³•ç³–æ´¾(æŠ•é™æ´¾) Maybe add some syntactic sugar like extension methods in C#. â€“link Something similar thatâ€™s been proposed before and is more explicit and thus feels, at least to me, more Go-like is to add a new operator, such asÂ -&gt;Â orÂ |&gt;, that chains functions such thatÂ a -&gt; f(b, c)Â is equivalent toÂ f(a, b, c). That would allow the benefit of a method-like ordering to the execution without needing to actually support methods with extra types or method implementations for interface types. â€“link For the solutionÂ #49085 (comment), the problem is that functions withÂ infixÂ are different from normal functions, and it may requires to write a function twice to provide both forms. Iâ€™d like to have a new way to call a function at the right position of a value, likeÂ usingÂ |Â inÂ template. So I propose following: â€“link è¿™ä¸€æ´¾å¯¹ go è¯­è¨€çš„æ³›å‹å½»åº•çš„å¦¥åï¼Œä¸è¦æ±‚æ”¹å˜ç›®å‰çš„æ³›å‹ç°çŠ¶ï¼Œåªè¦æ±‚æ·»åŠ ä¸€ä¸ªä¸­ç¼€è°ƒç”¨çš„è¯­æ³•ç³–(ä¸è¿‡è¿™ä¸ªä¹Ÿè€æ—©è¢« go å›¢é˜Ÿæ‰“äº†å›å»)ã€‚ åœ¨ä¹‹å‰æåˆ°è¿‡ï¼Œè™½ç„¶ä¸æ”¯æŒæ³›å‹æ–¹æ³• ï¼Œ func (S[T]) F[ M, U] ( M ) U ä¹Ÿå¯ä»¥ç”± func F[T, M, U] (T, M) U æ›¿æ¢ï¼Œä½†æ˜¯éšä¹‹è€Œæ¥çš„æ˜¯æ·±å±‚æ¬¡çš„è°ƒç”¨åµŒå¥—ï¼Œç”±åŸæœ¬çš„ x.f(y).g(z) å˜æˆäº† g(f(x, y), z) ã€‚å¦‚æœæœ‰ä¸€ç§ä¸­ç¼€è¯­æ³•ç³– x -&gt; f(y) è¡¨è¾¾ f(x,y)ï¼Œé‚£ä¹ˆ g(f(x, y), z) å°±èƒ½å˜æˆ x -&gt; f(y) -&gt; g(z)ï¼Œè°ƒç”¨åµŒå¥—å°±æ²¡æœ‰äº†ï¼Œæµå¼è°ƒç”¨çœ‹èµ·æ¥ä¹Ÿèƒ½å†™äº†ã€‚(è¿™å¾ˆéš¾è¯„ï¼ŒåŠ è¿™ç§æ™¦æ¶©çš„å‡½æ•°å¼è¯­æ³•ç³–ä¸å¦‚æ”¹è¿›ä¸€ä¸‹æ³›å‹) xxæ´¾(æƒ³ä¸å‡ºåå­—äº†) é¦–å…ˆå› ä¸º go å›¢é˜Ÿçš„ less is more ç†å¿µï¼Œè®©ç¼–è¯‘å™¨åšåˆ†æè°ƒç”¨é“¾è¿™ä¹ˆé‡çš„æ´»ä¹Ÿä¸å¤ªç°å®ï¼ˆè¿™é‡Œä¹Ÿè¾©è§£ä¸€ä¸‹ï¼Œå³ä½¿è°ƒç”¨é“¾åˆ†æä¹Ÿæ— æ³•è¦†ç›–åå°„ã€ä¼  interface è°ƒç”¨ã€æ’ä»¶æ¨¡å¼ç­‰åœºæ™¯ï¼Œæ‰€ä»¥è°ƒç”¨é“¾åˆ†ææ˜¯ä¸ç°å®çš„ï¼‰ã€‚ ä½†æ˜¯ç¦ç”¨æ•´ä¸ªæ³›å‹æ–¹æ³•ä¹Ÿå¤ªè¿‡æç«¯äº†ï¼Œå¦‚æœåªç¦ç”¨ interface ä¸­çš„ parameterized methods ï¼Œè€Œæ”¾è¿‡æˆå‘˜æ–¹æ³•çš„ parameterized methods ï¼Œæˆ‘è®¤ä¸ºæœ‰å‡ ç‚¹å¥½å¤„å§: æœ€é‡è¦çš„ä¸€ç‚¹æ˜¯å‘ä¸‹å…¼å®¹ï¼Œè¿™ç§ä¿®æ”¹æ²¡æœ‰å¯¹ go çš„è¯­ä¹‰æœ‰é‡å¤§æ”¹å˜ï¼ŒåŒæ—¶æ˜¯å¤§èŒƒå›´çº¦æŸåˆ°å°èŒƒå›´çº¦æŸçš„è¿‡ç¨‹ï¼Œä¸ä¼šå½±å“ä»¥å‰çš„ä»£ç è¿è¡Œã€‚ å¯ä»¥ç”¨ä¸Š monad and stream call ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œåˆç†åœ°ä½¿ç”¨å‡½æ•°å¼èƒ½å¤Ÿå‡å°‘ä¸´æ—¶å˜é‡å’Œå†—é•¿çš„ä»£ç ã€‚æœ‰è¾ƒå¤§æ¦‚ç‡èƒ½å‡å°‘ä¸‹å›¾ä¸­çš„ä»£ç (ä»€ä¹ˆæ—¶å€™æ‰èƒ½çœ‹åˆ°è¿™å¼ å›¾ä¸åæ§½å‘¢ã€‚ã€‚ã€‚) å®ç°èµ·æ¥ç›¸å¯¹çš„ä¸æ˜¯ç‰¹åˆ«å¤æ‚(ç›¸è¾ƒäºåˆ†æè°ƒç”¨é“¾æ¥è¯´)ï¼Œå› ä¸ºæ³›å‹ç»“æ„æœ¬èº«æ˜¯å¯ä»¥å…·æœ‰æ–¹æ³•çš„ï¼Œä¹Ÿè®¸å¯èƒ½å†æ”¯æŒä¸€ä¸ªæ³›å‹æ–¹æ³•ç›¸å¯¹æ¥è¯´æ²¡é‚£ä¹ˆå›°éš¾? ä»¥ä¸Šä¸ºç¬”è€…ä¸ªäººè§‚ç‚¹ã€‚å®é™…ä¸Šï¼Œè¿™ä¸€æ´¾ä¸º issue ä¸­å¤§å¤šæ•°äººçš„è§‚ç‚¹ï¼Œå…¶ä¸­æœ‰å‡ ä½æœ‰è¾ƒæ·±å…¥çš„è®¨è®ºï¼Œä¸‹é¢å¯¹ä»–ä»¬çš„è®¨è®ºåšä¸‹åˆ†æ: ä¸€ I think this solution makes the most sense. They could then (under the hood) be treated a regular function. The reason why this would be useful is that methods do not only serve the purpose of implementing interfaces; methods also serve as a means of organization for functions that operate on particular structures. It may be a bit of a challenge about how type-parameterized methods would appear inÂ &quot;reflect&quot;, though. â€“ link æŠŠè¿™æ®µè¯æ”¾åˆ°ç¬¬ä¸€ä¸ªçš„åŸå› æ˜¯è¿™æ˜¯ç¬¬ä¸€ä¸ªæå‡ºè¿™ä¸€æ´¾è§‚ç‚¹çš„äººï¼Œè¿˜é¡ºä¾¿åæ§½äº†ä¸‹ææ¡ˆä¸­çš„ &quot;any parameterized method can be implemented as a parameterized function&quot;ğŸ˜šã€‚ äºŒ I propose two constraints: Generic interfaces must be made â€œconcreteâ€ when used in a type assertion, within a type switch, and when invoking associated methods. By concrete, I mean that all type parameters on the generic interface are specified. Types having generic method(s) cannot be typecast toÂ interface&#123;&#125;Â or a generic interface unless it is an â€œinstantiated generic typeâ€. By instantiated generic type, I mean a type that has one or more generic method instantiations. â€“ link å¯¹äºææ¡ˆä¸­æå‡ºçš„é—®é¢˜ï¼Œè¿™ä½æå‡ºäº†ä¸¤ä¸ªçº¦æŸ: æ³›å‹ interface æ–­è¨€çš„æ—¶å€™å¿…é¡»æŒ‡å®šå…·ä½“ç±»å‹ã€‚ å…·æœ‰æ³›å‹æ–¹æ³•çš„ç±»å‹é™¤é åœ¨è¿™æ®µè®¨è®ºä¸­è¿˜å¯¹åå°„å¤„ç†æœ‰æ‰€è¡¥å……: On the reflect package, I propose we simply add a new â€œlaw of reflectionâ€ that says that any compile-time uninstantiated type realizations are unavailable at run-time. â€“link éå¸¸ç®€å•ï¼Œå°±æ˜¯æ£€æŸ¥æ³›å‹å‡½æ•°æ˜¯å¦å®ä¾‹åŒ–ï¼Œæ²¡æœ‰å®ä¾‹åŒ–çš„å‡½æ•°å°±æ˜¯ä¸€è°ƒä¸€ä¸ªä¸å±å£°(panic å°±å®Œäº‹äº†)ã€‚ åå¯¹æ´¾ proposal: spec: allow type parameters in methods Â· Issue #49085 Â· golang/go Â· GitHub proposal: spec: allow type parameters in methods Â· Issue #49085 Â· golang/go Â· GitHub proposal: spec: allow type parameters in methods Â· Issue #49085 Â· golang/go Â· GitHub proposal: spec: allow type parameters in methods Â· Issue #49085 Â· golang/go Â· GitHub proposal: spec: allow type parameters in methods Â· Issue #49085 Â· golang/go Â· GitHub æ€»ç»“ è€ƒè™‘åˆ° go è¯­è¨€å›¢é˜Ÿå·²ç»åœ¨æ³›å‹å®ç°ä¸Šå·²ç»è€ƒè™‘äº† 10 å¹´è¾¾åˆ°å¦‚ä»Šçš„æˆå°±ï¼Œé‚£ä¹ˆå¸Œæœ› go å›¢é˜Ÿèƒ½åœ¨ä¸è¿å&quot;æ³›å‹æ–¹æ³•åœ¨ interface ä¸­çš„æ­£äº¤æ€§ğŸ¤—&quot;çš„çº¦æŸä¸‹åœ¨ä¸‹ä¸ª 10 å¹´å®ç°æ³›å‹æ–¹æ³•å§ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œå¦‚æœå„ä½çœ‹å®˜æƒ³ä½¿ç”¨æ³›å‹æ–¹æ³•ï¼Œè¯·çœ‹ä¸‹é¢è¯„è®º(","categories":["blog"]},{"title":"monad ç²—æµ…ä»‹ç»","path":"/pages/blog/monad ç²—æµ…ä»‹ç».html","content":"ä»€ä¹ˆæ˜¯ monad? monad(å•å­) æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ä¸€ç§æŠ½è±¡ï¼Œæœ¬æ–‡æ—¨åœ¨å¯¹ monad çš„ç²—æµ…ä»‹ç»ï¼Œæ‰€ä»¥è·³è¿‡å…¶æ•°å­¦ä¸Šçš„å®šä¹‰å’Œç»“æ„æ€§è¯æ˜(å…¶å®æ˜¯ç›®å‰ç¬”è€…ä¹Ÿä¸å¤ªæ‡‚ğŸ¤«)ï¼Œé€šè¿‡ä¸€äº›å…·ä½“çš„ä¾‹å­è¯´æ˜å®ƒçš„æ¦‚å¿µå’Œä½œç”¨ã€‚ å®šä¹‰ å°½ç®¡æ²¡æœ‰å¤ªå¤æ‚çš„æ•°å­¦æ¦‚å¿µï¼Œä½†è¿˜æ˜¯éœ€è¦ä¸€ä¸ªå®šä¹‰è¯´æ˜ä»€ä¹ˆæ ·çš„ä¸œè¥¿æ‰èƒ½ç§°ä¹‹ä¸º monadã€‚åœ¨æ¥ä¸‹æ¥çš„è¯´æ˜ä¸­ï¼Œé™¤äº†åˆ—ä¸¾å‡ºæ•°å­¦å®šä¹‰ä»¥å¤–ï¼Œè¿˜æœ‰å…¶åœ¨ go è¯­è¨€ä¸­çš„å…·ä½“è¡¨ç°å½¢å¼ã€‚åœ¨ wiki çš„å®šä¹‰ä¸­: Monad (functional programming) - Wikipedia ä¸€ä¸ª monad åŒ…å«ä¸‰ä¸ªéƒ¨åˆ†: ç±»å‹æ„é€ å­ M ã€‚ åœ¨ go ä¸­å¯ä»¥ç†è§£ä¸ºä¸€ç§åä¸º M åŒ…è£¹ç€ T çš„æ³›å‹ç»“æ„ä½“ M&lt;T&gt;&#123; val: T &#125; ç±»å‹è½¬æ¢å­ Unit :: T -&gt; M Tã€‚ åœ¨ go ä¸­å¯ä»¥ç†è§£ä¸ºç”±å€¼ T æ„é€  M çš„å‡½æ•° func Unit[T any] (val T) -&gt; M&lt;T&gt; ç»„åˆå­ &gt;&gt;= or FlatMap :: M T -&gt; ( T -&gt; M U) -&gt; M U ã€‚ åœ¨ go ä¸­å¯ä»¥ç†è§£ä¸º M&lt;T&gt;&#123; val: T &#125; è¿™ä¸ªç»“æ„ä½“å…·æœ‰ä¸€ä¸ªæˆå‘˜æ–¹æ³• func flatMap[T, U any] (func(T) -&gt; M&lt;U&gt;) -&gt; M&lt;U&gt; ï¼Œèƒ½å¤Ÿæ¥å—ä¸€ä¸ªå‡½æ•°å‚æ•°å®ç°ä» M&lt;T&gt; åˆ° M&lt;U&gt; çš„å˜æ¢ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç§°è¿™ä¸ªå…·æœ‰ FlatMap æ–¹æ³•çš„ M ä¸ºä¸€ä¸ª Monad (è¯·æ³¨æ„ä¸æ˜¯ M&lt;\\T&gt; )ã€‚ æ›´ä¸¥æ ¼çš„å®šä¹‰ ä¸€ä¸ª monad è¿˜å¿…é¡»å«æœ‰ä»¥ä¸‹ä¸‰ä¸ªçº¦æŸ: è½¬æ¢å­ Unit æ˜¯ç»„åˆå­ &gt;&gt;= çš„å·¦å•ä½å…ƒ: Unit &gt;&gt;= f &lt;-&gt; f ã€‚ åœ¨ go ä¸­å¯ä»¥ç†è§£ä¸ºï¼šå¦‚æœæœ‰ä¸€ä¸ªå‡½æ•°ä¸º F[ T, U any] (T) M U, é‚£ä¹ˆ Unit(x).FlatMap(f) çš„æ‰§è¡Œç»“æœå’Œæ‰§è¡Œ f(x) ç»“æœç›¸åŒ è½¬æ¢å­ Unit æ˜¯ç»„åˆå­ &gt;&gt;= çš„å³å•ä½å…ƒ: f &gt;&gt;= Unit &lt;-&gt; f åœ¨ go ä¸­å¯ä»¥ç†è§£ä¸ºï¼šå¦‚æœæœ‰ä¸€ä¸ªå‡½æ•°ä¸º F[ T, U any] (T) M U, F(x).FlatMap(Unit) çš„æ‰§è¡Œç»“æœç­‰äº F(x) ç»„åˆå­ &gt;&gt;= æ»¡è¶³ç»“åˆå¾‹: ma &gt;&gt;= Î»x -&gt; (f(x) &gt;&gt;= Î»y -&gt; g(y))Â &lt;-&gt;Â (ma &gt;&gt;= Î»x -&gt; f(x)) &gt;&gt;= Î»y -&gt; g(y) åœ¨ go ä¸­å¯ä»¥ç†è§£ä¸ºä»¥ä¸‹ä¸¤ä¸ªè¿‡ç¨‹æ‰§è¡Œç»“æœç›¸ç­‰ 123456func F[T, U any](x T) M&lt;U&gt; &#123; f(x) &#125; // f(x) æ˜¯å¯¹ x çš„ä¸€äº›è¡Œä¸ºfunc G[U, P any](y U) M&lt;P&gt; &#123; g(y) &#125; // g(y) æ˜¯å¯¹ y çš„ä¸€äº›è¡Œä¸ºfunc H[T, P any](x T) M&lt;P&gt; &#123; F(x).FlatMap(G) &#125; // g(f(x))res1 := M&#123;val: x&#125;.FlatMap(H) 1234func F[T, U any](x T) M&lt;U&gt; &#123; f(x) &#125; // f(x) æ˜¯å¯¹ x çš„ä¸€äº›è¡Œä¸ºfunc G[U, P any](y U) M&lt;P&gt; &#123; g(y) &#125; // g(y) æ˜¯å¯¹ y çš„ä¸€äº›è¡Œä¸ºres2 := M&#123; val: x &#125;.FlatMap(F).FlatMap(G) monad æœ‰ä»€ä¹ˆç”¨? åœ¨åˆ—ä¸¾å®Œ monad çš„å®šä¹‰åï¼Œä¸ºäº†é¿å…é™·åœ¨æŠ½è±¡çš„ä¸–ç•Œé‡Œæ— æ³•è‡ªæ‹”ï¼Œç¬”è€…åœ¨æ¥ä¸‹æ¥ä¼šå…·ä½“åˆ—ä¸¾ä¸€äº›ä¾‹å­è¯´æ˜ monad çš„ä½œç”¨ ã€‚ä»¥ç¬”è€…çš„è§‚ç‚¹æ¥è¯´ï¼Œmonad çš„ä½œç”¨å°±æ˜¯æä¾›äº†ä¸€ç§éšè—å‰¯ä½œç”¨çš„å½¢å¼ï¼Œä½¿å¾—åœ¨ç¼–å†™å¤„ç†å‡½æ•°çš„æ—¶å€™åªç”¨è€ƒè™‘é¢„æœŸçš„è¾“å…¥ï¼Œå°†å‰¯ä½œç”¨å»¶ç»­åˆ°æœ€åå¤„ç†ã€‚ å¦ä¸€ä¸ªå®‡å®™çš„ go error monad å¼•è¨€ åœ¨ go ç¼–ç¨‹ä¸­ï¼Œå¯èƒ½å¸¸è§å¦‚ä¸‹ä»£ç : 123456789101112131415161718192021222324// è·å–è¦æŸ¥è¯¢çš„IDfunc GetID (int64) (int64,error) &#123;&#125;// è·å– ID å¯¹åº”çš„ä¿¡æ¯func GetInfo (id int64) (Info,error) &#123;&#125;// è·å–ä¸Šä¸€ä¸ª Info ä¸­ uid å¯¹åº”çš„ä¿¡æ¯func GetUserInfo (Info) (UserInfo,error) &#123;&#125;func handle() error &#123;\trawID := 0\tid, err := GetID(rawID)\tif err != nil &#123; return err\t&#125;\tinfo, err := GetInfo(id)\tif err != nil &#123; return err &#125;\tuserInfo, err := GetUserInfo(info)\tif err != nil &#123; return err\t&#125;\t// use userInfo ...&#125; å¯ä»¥çœ‹åˆ° go çš„çµé­‚å‡ºç°äº†ğŸ¤— å½“ç„¶ç¬”è€…å¹¶ä¸åå¯¹ go è¿™ç§ä¸¥æ ¼å¤„ç†æ¯ä¸ªå‡½æ•°è¿”å›çš„é”™è¯¯å€¼çš„æ€æƒ³ï¼Œä¸è¿‡æœ¬æ–‡æ—¢ç„¶æ˜¯æœ‰å…³ monad çš„ä»‹ç»ï¼Œè‡ªç„¶æ˜¯æƒ³ç€æ€ä¹ˆå°† monad å¥—ç”¨åˆ° go çš„é”™è¯¯å¤„ç†ä¸­ã€‚ go ç‰ˆ monad å¼é”™è¯¯å¤„ç† å›é¡¾ monad çš„å®šä¹‰: é¦–å…ˆ monad æ˜¯ä¸€ä¸ªç»“æ„ä½“: 1234type ErrMonad[T any] struct &#123;\tResult T\tErr error&#125; ä¸Šé¢çš„ç»“æ„ä½“åŒ…å«äº†è¿”å›å€¼å’Œé”™è¯¯ã€‚ ç„¶åéœ€è¦ä¸€ä¸ªç”± T æ„é€ æˆ M T çš„å‡½æ•°: 123456func Unit[T any] (result T) ErrMonad[T] &#123;\treturn ErrMonad[T]&#123; Result: result,\t&#125;&#125; æœ‰ç»„åˆå­ FlatMap æˆå‘˜æ–¹æ³•: 123456func (h ErrMonad[T]) FlatMap[U] (mapFunc func(T) ErrMonad[U] ) ErrMonad[U] &#123;\tif h.err != nil&#123; return h\t&#125;\treturn mapFunc(h.result)&#125; æœ‰äº†ä¸Šè¿°å®ç°åï¼Œä¹‹å‰çš„æµç¨‹å°±å¯ä»¥æ”¹å†™ä¸º: 1234567891011121314151617181920// è·å–è¦æŸ¥è¯¢çš„IDfunc GetID (int64) ErrMonad[int64] &#123;&#125;// è·å– ID å¯¹åº”çš„ä¿¡æ¯func GetInfo (id int64) ErrMonad[Info] &#123;&#125;// è·å–ä¸Šä¸€ä¸ª Info ä¸­ uid å¯¹åº”çš„ä¿¡æ¯func GetUserInfo (Info) ErrMonad[UserInfo] &#123;&#125;func handle() error &#123;\trawID := Unit(int64(0))\tres := rawID. FlatMap(GetID). FlatMap(GetInfo). FlatMap(GetUserInfo)\tif res.Err != nil&#123; return res.Err\t&#125;\tuserInfo = res.Result\t// use userInfo ...&#125; å¯ä»¥çœ‹å‡ºç›¸è¾ƒäºä¹‹å‰çš„ç‰ˆæœ¬ï¼Œä»£ç æ›´ç®€æ´äº†ä¸€äº› (è‡³å°‘å°‘äº† if err != nil &#123; return err &#125;)ã€‚ ç„¶è€Œç†æƒ³æ˜¯ç¾å¥½çš„ï¼Œçœ‹ç€ monad å®ç°è¿™ä¹ˆç®€å•ï¼Œä¸ºå•¥ç¾¤å‹æ€»è¯´ go ä¸æ”¯æŒ monad å‘¢ã€‚å›çœ‹æœ¬èŠ‚æ ‡é¢˜ â€œå¦ä¸€ä¸ªå®‡å®™çš„ go error monadâ€ï¼Œéå¸¸é—æ†¾çš„æ˜¯ï¼Œç›®å‰çš„ go ä¸æ”¯æŒæ³›å‹æ–¹æ³•å‚æ•° Type Parameters Proposalï¼Œä¸ºå•¥ go ä¸æ”¯æŒæ³›å‹æ–¹æ³•ã€‚å…·ä½“æ¥è¯´å°±æ˜¯ä¸æ”¯æŒå…¥å‚æ˜¯ä¸€ä¸ªå¸¦æ³›å‹çš„æ–¹æ³•ï¼Œå³ä»¥ä¸‹å‡½æ•°éƒ½æ˜¯æ— æ³•å®ç°çš„: 12345func goIsBest( func[T any] () ) bool &#123; return false &#125;type GGGGGG[T any] struct&#123;&#125;func (GGGGGG[T]) gggggggggggg( func[U any] () ) &#123;&#125;func (GGGGGG[T]) gggggggggggg[U any] () &#123;&#125; æ‘†ä¸ª issue åšå‚è€ƒ(å¸Œæœ›æœªæ¥ä¼šæœ‰è§£å†³æ–¹æ³•å§): proposal: spec: allow type parameters in methods Â· Issue #49085 Â· golang/go Â· GitHub è¿™å°±å¯¼è‡´äº† FlatMap æ–¹æ³•æ˜¯ä¸å¯è¡Œçš„ã€‚è‡³æ­¤ï¼Œgo çš„ monad ä¹‹æ—…åˆ°æ­¤ç»“æŸã€‚ é™„ä¸€ç¯‡ç»å…¸çš„é”™è¯¯å¤„ç†æ–¹æ³• blog ( æ„Ÿè§‰å°±åƒä¸€ç§é’æ˜¥ç‰ˆçš„ monadï¼Œåœ¨æ‰€ä¸¾çš„ä¾‹å­ä¸­å­˜åœ¨ç±»å‹åªæœ‰ io.Writerï¼Œæ‰€ä»¥åªç”¨åœ¨å•ä¸ªç±»å‹é‡Œæ‰“è½¬ï¼Œçœç•¥äº†ç”± T ç±»å‹åˆ° U ç±»å‹çš„è½¬æ¢ï¼Œæ‰€ä»¥è¿™ç§å½¢å¼å¯ä»¥åœ¨ go ä¸­å®ç°: Errors are values - Thttps://go.dev/blog/errors-are-valueshe Go Programming Language if err != nil å¤ªçƒ¦ï¼ŸGo åˆ›å§‹äººæ•™ä½ å¦‚ä½•å¯¹é”™è¯¯è¿›è¡Œç¼–ç¨‹ï¼ - çŸ¥ä¹ (è¯„è®ºåŒº) monad å¦‚ä½•è§£å†³å›è°ƒåœ°ç‹± ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹çœ‹ä¸€ç‚¹è€(ä¸æ–°åˆä¸è€)çš„ä¸œè¥¿ã€‚ å¼•è¨€ å„ä½å³ä½¿æ²¡å†™è¿‡ javascriptï¼Œä¹Ÿå¯èƒ½å¬è¯´è¿‡å›è°ƒåœ°ç‹±è¿™ä¸ªæ¦‚å¿µï¼Œå…·ä½“æ¥è®²è¿™æ˜¯ä¸€ç§ javascript å¼‚æ­¥ç¼–ç¨‹ä¸­å‡ºç°çš„ä¸€ç§ç°è±¡ã€‚æ‹¿Callback Hellä¸­çš„ä¾‹å­ä¸¾ä¾‹å§: 123456789101112131415161718192021222324fs.readdir(source, function (err, files) &#123; if (err) &#123; console.log(&#x27;Error finding files: &#x27; + err) &#125; else &#123; files.forEach(function (filename, fileIndex) &#123; console.log(filename) gm(source + filename).size(function (err, values) &#123; if (err) &#123; console.log(&#x27;Error identifying file size: &#x27; + err) &#125; else &#123; console.log(filename + &#x27; : &#x27; + values) aspect = (values.width / values.height) widths.forEach(function (width, widthIndex) &#123; height = Math.round(width / aspect) console.log(&#x27;resizing &#x27; + filename + &#x27;to &#x27; + height + &#x27;x&#x27; + height) this.resize(width, height).write(dest + &#x27;w&#x27; + width + &#x27;_&#x27; + filename, function(err) &#123; if (err) console.log(&#x27;Error writing file: &#x27; + err) &#125;) &#125;.bind(this)) &#125; &#125;) &#125;) &#125;&#125;) ä¸Šé¢çš„ä»£ç å…·ä½“ä½œç”¨å°±æ˜¯å¼‚æ­¥æ‰§è¡Œå¦‚ä¸‹æ“ä½œ: é€šè¿‡ä¼ å…¥çš„ srouce è¯»å–æŒ‡å®šç›®å½•ä¸‹çš„æ–‡ä»¶åˆ—è¡¨ï¼Œç„¶åä½¿ç”¨ gm å‡½æ•°è¿›è¡Œå›¾åƒå¤„ç†ï¼Œä¿å­˜å¤„ç†åçš„å›¾åƒåˆ°ç›®æ ‡ç›®å½•ã€‚ å¯ä»¥çœ‹åˆ°ä»£ç çš„åµŒå¥—å±‚çº§éå¸¸æ·±ï¼Œè¿™å°±æ˜¯æ—©æœŸ javascript å¼‚æ­¥ç¼–ç¨‹çš„é—®é¢˜ã€‚å¯¹äºå¼‚æ­¥å‡½æ•°ï¼Œéœ€è¦ä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°è¡¨æ˜åœ¨å½“å‰çŠ¶æ€ç»“æŸå (å¦‚è¯»å–æ–‡ä»¶ç»“æŸå) åº”è¯¥ç»§ç»­æ‰§è¡Œçš„åŠ¨ä½œã€‚å¯ä»¥æƒ³è±¡ä¸€æ—¦å¼‚æ­¥å¤„ç†è¿‡ç¨‹å¤šäº†ï¼Œå¦‚æœæ²¡æœ‰åˆé€‚çš„æ–¹æ³•ï¼Œå¿…ç„¶ä¼šå¯¼è‡´æ·±å±‚æ¬¡çš„å‡½æ•°åµŒå¥—ã€‚ä¸€èˆ¬çš„åšæ³•å°±æ˜¯å°†åµŒå¥—çš„å‡½æ•°æŠ½å‡ºæ¥ï¼Œå°†å¼‚æ­¥è°ƒç”¨æ‹†è§£åˆ°æ¯ä¸ªå‡½æ•°ä¸­ï¼š 123456789101112131415161718main() &#123;\ta(value, b(value, c (value)))&#125;// -------------------------------------------------main() &#123;\ta(value, B)&#125;B(value) &#123;\t// do something\tb(value, c)&#125;c(value) &#123;\t// do something&#125; ä½†ä¸Šè¿°åšæ³•å¸¦æ¥çš„ä¸€ä¸ªå°é—®é¢˜æ˜¯å¦‚æœéœ€è¦äº†è§£æ•´ä¸ªè¿è¡Œçš„æµç¨‹ï¼Œéœ€è¦ä¸æ–­è·³è½¬å‡½æ•°æ‰èƒ½çŸ¥é“æ•´ä¸ªè¿è¡Œé€»è¾‘ï¼Œè€Œä¸èƒ½ç›´æ¥åœ¨ä¸€ä¸ª main å‡½æ•°ä¸­çŸ¥æ™“ã€‚ å¼‚æ­¥å’Œ monad ä¸Šè¿°é—®é¢˜çš„æ ¹æœ¬åŸå› åœ¨äºå¼‚æ­¥è¿‡ promise ä»‹ç» åœ¨ 2015 å¹´åï¼Œpromise çš„å‡ºç°ç¼“è§£äº† javascript åœ¨å¼‚æ­¥ç¼–ç¨‹ä¸­çš„é—®é¢˜ï¼Œé¦–å…ˆä»‹ç»ä¸€ä¸‹ä»€ä¹ˆæ˜¯ promise: promise æ˜¯ javascript ä¸­çš„ä¸€ä¸ªå¯¹è±¡ï¼Œé€šè¿‡ Promise.resolve æ–¹æ³•å¯ä»¥æ„é€ å‡ºä¸€ä¸ª promise å¯¹è±¡ã€‚ 12let x = Promise.resolve(123)console.log(x) // Promise &#123; 123 &#125; promise å†…éƒ¨æœ‰ä¸‰ç§çŠ¶æ€ pending ã€fulfilled å’Œ rejected ã€‚ä»–ä»¬çš„ä½œç”¨åœ¨è¿™é‡Œä¸æ·±ç©¶ï¼Œåªè¦ç²—ç•¥åœ°äº†è§£ï¼š fulfilled å¯ä»¥è®¤ä¸ºæ˜¯æ–¹æ³•æ‰§è¡ŒæˆåŠŸçš„çŠ¶æ€ï¼Œrejected å¯ä»¥è®¤ä¸ºæ˜¯æ–¹æ³•è¿”å› error çš„çŠ¶æ€ã€‚ promise æœ‰ä¸‰ä¸ªæˆå‘˜æ–¹æ³• then ï¼Œcatch å’Œ finallyã€‚è¿™é‡Œåªä»‹ç» then å’Œ catch æ–¹æ³•ã€‚ then æ–¹æ³•æ¥å—ä¸¤ä¸ªç±»å‹ä¸ºå‡½æ•°çš„å‚æ•°ï¼Œä¸€ä¸ªæ˜¯å½“çŠ¶æ€ä¸º fulfilled çš„æ—¶å€™è°ƒç”¨ï¼Œå¦ä¸€ä¸ªä¸º rejected çš„æ—¶å€™è°ƒç”¨ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œç¬”è€…å–œæ¬¢åªä¼ å‰ä¸€ä¸ªå‚æ•°ï¼Œç¬¬äºŒä¸ªå‚æ•°ä½¿ç”¨ç¼ºçœå€¼ï¼Œå³åªæœ‰åœ¨çŠ¶æ€ä¸ºæˆåŠŸçš„æ—¶å€™æ‰æ‰§è¡Œä¼ å…¥çš„å‡½æ•°ã€‚å…·ä½“ä»£ç ä¾‹å­å¦‚ä¸‹: 12345let x = Promise.resolve(&quot;now&quot;)x.then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;running 1&quot;) return Promise.resolve(&quot;run1&quot;)&#125;) å’Œ then ç±»ä¼¼ï¼Œcatch æ–¹æ³•æ¥å—ä¸€ä¸ªç±»å‹ä¸ºå‡½æ•°çš„å‚æ•°ï¼Œå½“çŠ¶æ€ä¸º rejected ä¼šè°ƒç”¨ï¼Œå…·ä½“ä»£ç ä¾‹å­å¦‚ä¸‹: 1234let x = Promise.reject(&quot;now&quot;)x.catch((reason) =&gt; &#123; console.log(&quot;break at &quot; + reason)&#125;) promise å’Œ monad åœ¨äº†è§£äº† promise çš„æ¦‚å¿µåï¼Œå¯ä»¥çœ‹å‡º promise éå¸¸åƒä¸€ä¸ª monadã€‚ä¸‹é¢æ¥ç‚¹è¯æ˜ï¼š ç±»å‹æ„é€ å­ï¼šPromise &lt; T &gt; ç±»å‹è½¬æ¢å­ï¼šPromise.resolve ç»„åˆå­ï¼šPromise&lt; T &gt;.then( (value: T) =&gt; U ) 1234567891011121314151617181920let x = Promise.resolve(&quot;now&quot;)console.log(x)x.then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;run1&quot;) return Promise.resolve(&quot;run1&quot;)&#125;).then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;run2&quot;) return Promise.reject(&quot;run2&quot;)&#125;).then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;run3&quot;) return Promise.resolve(&quot;run3&quot;)&#125;).catch((reason) =&gt; &#123; console.log(&quot;break at &quot; + reason)&#125;)/*Promise &#123; &#x27;now&#x27; &#125;pre: now run1pre: run1 run2break at run2*/ æ€»ç»“ ç›¸å…³é˜…è¯» Haskell Monad_å“”å“©å“”å“©_bilibili Functors, Applicatives, And Monads In Pictures - adit.io å¦‚ä½•è‡ªåº•å‘ä¸Šåœ°å»ºç«‹èµ·å¯¹ Monad çš„ç†è§£ - çŸ¥ä¹ ä»€ä¹ˆæ˜¯ Monad (Functional Programming)ï¼Ÿ - Belleveçš„å›ç­” - çŸ¥ä¹ ğŸ¤£ æ·±å…¥ç†è§£å‡½æ•°å¼ç¼–ç¨‹ï¼ˆä¸Šï¼‰ - ç¾å›¢æŠ€æœ¯å›¢é˜Ÿ æ·±å…¥ç†è§£å‡½æ•°å¼ç¼–ç¨‹ï¼ˆä¸‹ï¼‰ - ç¾å›¢æŠ€æœ¯å›¢é˜Ÿ Futureä¸promise - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦","categories":["blog"]},{"title":"SipHash","path":"/pages/blog/SipHash.html","content":"è®ºæ–‡ eprint.iacr.org/2012/351.pdf ä»£ç ä½ç½® library/core/src/hash/sip.rs SipHash æ˜¯ä¸€ç±»é’ˆå¯¹çŸ­æ¶ˆæ¯è®¾è®¡çš„ä¼ªéšæœºå‡½æ•°æ—ï¼Œç›¸è¾ƒäºå…¶ä»–çš„å“ˆå¸Œå‡½æ•°æœ‰åœ¨çŸ­æ¶ˆæ¯ä¸Šæ€§èƒ½é«˜ã€ç”±äºéšæœºè¾“å…¥çš„å­˜åœ¨éš¾ä»¥æ„é€ å“ˆå¸Œ dos æ”»å‡»çš„ä¼˜ç‚¹ï¼Œæ˜¯ rust ã€python çš„å†…ç½®å“ˆå¸Œå‡½æ•°å®ç°ã€‚ å®ç° å¯¹äº SipHash-c-d å‡½æ•°æ—ï¼Œè¾“å…¥ä¸ºä¸€ä¸ª 128 bit çš„ k å’Œ å¯ä¸ºç©ºçš„è¾“å…¥ mï¼Œè¾“å‡ºä¸ºä¸€ä¸ª 64 ä½é•¿åº¦çš„ SipHash-c-d(k,m)ã€‚å…¶ä¸­ c ä¸º â€œcompression roundsâ€ çš„æ¬¡æ•°ï¼Œ d ä¸º â€œfinalization roundsâ€ çš„æ¬¡æ•°ï¼Œâ€œcompression roundsâ€ å’Œ â€œfinalization roundsâ€ åœ¨ä¹‹åä¸­æœ‰è¯´æ˜å…·ä½“çš„å®ç°æ­¥éª¤ã€‚ åˆå§‹åŒ– é¦–å…ˆä½¿ç”¨ k0ã€k1 åˆå§‹åŒ–å››ä¸ªå€¼ v0 ã€v1 ã€v2 ã€v3ï¼Œå…¶ä¸­ k0ã€k1 ä¸º è¾“å…¥ k çš„ 64 ä½çš„å°ç«¯ç¼–ç  (ä¹Ÿå°±æ˜¯ä¸¤ä¸ª u64 å€¼ k0 ã€k1 ç»„æˆäº† k )ã€‚ å¯¹äºå…¶ä¸­çš„å¸¸é‡ï¼Œè®ºæ–‡çš„é€‰å–è§£é‡Šä¸º: The initial state constant corresponds to the ASCII string â€œsomepseudorandomlygeneratedbytesâ€, big-endian encoded. è®ºæ–‡ä¸­æå‡ºåªéœ€è¦æ»¡è¶³ v0 å’Œ v1 ä¸åŒäº v2 å’Œ v3 å³å¯(ä¹Ÿæ²¡åˆ†æä¸ºå•¥ã€‚ã€‚ã€‚)ã€‚ the only requirement was some asymmetry so that the initial v0 and v1 differ from v2 and v3. Compression Round åœ¨åˆå§‹åŒ–çŠ¶æ€åï¼Œå°†è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œç¼–ç ï¼Œå°†è¾“å…¥çš„å­—ç¬¦ä¸²ä»¥æ¯ 8 å­—èŠ‚ä½œä¸ºä¸€ç»„ä»¥å°ç«¯åºç¼–ç æˆ 64 ä½çš„æ•° mim_imiâ€‹ ï¼Œæœ€åä¸å¤Ÿçš„ç”¨ 0 åšå¡«å……ï¼Œæœ€åä¸€ä¸ªå­—èŠ‚çš„å€¼ä¸ºè¾“å…¥çš„å­—ç¬¦ä¸²é•¿åº¦ lenâ€Šmodâ€Š256len \\bmod 256lenmod256ã€‚å…·ä½“æ¥è¯´ï¼Œç¼–ç çš„è¿‡ç¨‹å¦‚ä¸‹å›¾: åœ¨å°†è¾“å…¥ s ç¼–ç æˆ m0,m1â€¦mâŒˆ(len+1)8âŒ‰m_0,m_1 \\dots m_{\\lceil \\frac{(len+1)}{8} \\rceil}m0â€‹,m1â€‹â€¦mâŒˆ8(len+1)â€‹âŒ‰â€‹ åï¼Œå¯¹äºæ¯ä¸ª mim_imiâ€‹ æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼Œè¿­ä»£æ‰§è¡Œå®Œæ‰€æœ‰çš„è¾“å…¥åï¼ŒCompression Round å®Œæˆã€‚ v3Â âŠ•=miSipRound(v0,v1,v2,v3)Â forÂ cÂ timesv0Â âŠ•=mi\\begin{aligned} v_3 \\ \\oplus = m_i \\\\ SipRound(v_0,v_1,v_2,v_3)\\ for\\ c \\ times \\\\ v_0 \\ \\oplus = m_i \\end{aligned} v3â€‹Â âŠ•=miâ€‹SipRound(v0â€‹,v1â€‹,v2â€‹,v3â€‹)Â forÂ cÂ timesv0â€‹Â âŠ•=miâ€‹â€‹ PS: å·¨ğŸ’©ğŸ¤¡çš„æ˜¯è®ºæ–‡ä¸­çš„ â€œFor example, the one-byte input string m = ab is parsed as m0 = 01000000000000abâ€ã€‚å¼€å§‹æˆ‘è¿˜ä»¥ä¸ºè¾“å…¥çš„æ˜¯å­—ç¬¦ä¸² â€œabâ€ï¼Œæ²¡çœ‹åˆ° â€œone-byte inputâ€ï¼Œå¯¼è‡´ç¼–ç è¾“å…¥ m è¿™å—å¡äº†ä¸€ä¼šã€‚æ„Ÿè§‰å†™æˆ â€œ0xabâ€ å’Œ â€œ0x01000000000000abâ€ ä¼šå¥½ä¸€ç‚¹ğŸ¤¡ã€‚ Finalization Round åœ¨æ‰€æœ‰çš„è¾“å…¥å­—èŠ‚å¤„ç†åœ¨ Compression Round å¤„ç†å®Œæˆåï¼Œå°† v2v_2v2â€‹ å’Œå¸¸é‡ 0xff0\\mathrm{xff}0xff (ä¹Ÿæ˜¯ä¸€ä¸ªéšæœºçš„éé›¶å€¼å³å¯) è¿›è¡Œå¼‚æˆ–ï¼Œå†è¿›è¡Œ d è½® SipRound ä¹‹åï¼Œå°† v0v_0v0â€‹ ã€v1v_1v1â€‹ã€v2v_2v2â€‹ã€v3v_3v3â€‹ è¿›è¡Œå¼‚æˆ–å’Œåå¾—åˆ°æœ€ç»ˆçš„ 64 ä½å“ˆå¸Œå€¼ã€‚ v2Â âŠ•=0xffSipRound(v0,v1,v2,v3)Â forÂ dÂ timesres=v0âŠ•v1âŠ•v2âŠ•v3\\begin{aligned} v_2 \\ \\oplus = 0\\mathrm{xff} \\\\ SipRound(v_0,v_1,v_2,v_3)\\ for\\ d \\ times \\\\ res = v_0 \\oplus v_1 \\oplus v_2 \\oplus v_3 \\end{aligned} v2â€‹Â âŠ•=0xffSipRound(v0â€‹,v1â€‹,v2â€‹,v3â€‹)Â forÂ dÂ timesres=v0â€‹âŠ•v1â€‹âŠ•v2â€‹âŠ•v3â€‹â€‹ SipRound SipRound çš„è¿ç®—è¿‡ç¨‹å¦‚ä¸‹: å®‰å…¨æ€§åˆ†æ #todo [ ] SipHash å®‰å…¨æ€§åˆ†æ","tags":["hash"],"categories":["blog"]},{"title":"æ‘„å½±å­¦ä¹ ","path":"/pages/blog/æ‘„å½±å­¦ä¹ .html","content":"å‚è€ƒ+å›¾ç‰‡æ¥æº ä»é›¶å¼€å§‹æ‰‹æŠŠæ‰‹æ•™ä½ å­¦æ‘„å½±ï¼Œ20èŠ‚è¯¾å¸¦ä½ ä»å°ç™½åˆ°å¤§å¸ˆ | æ‘„å½±å‰æœŸæ‹æ‘„å…¥é—¨æ•™ç¨‹_å“”å“©å“”å“©_bilibili æ¦‚å¿µ ä¼ æ„Ÿå™¨å¤§å°åˆ†ç±» ä¸‹å›¾æ¥è‡ªäº ç„¦è· æ›å…‰ å…‰åœˆ å¿«é—¨æ—¶é—´ æ„Ÿå…‰åº¦ (ISO) æ‹æ‘„æ¨¡å¼","categories":["blog"]},{"title":"rustæºç é˜…è¯»","path":"/pages/blog/rustæºç é˜…è¯».html","content":"æ›´æ–°ä¸­â€¦ wikié“¾æ¥","tags":["rust"],"categories":["blog"]},{"title":"Rust For Screeps (3): ç³»ç»Ÿç›‘æ§å’Œ panic å¤„ç†","path":"/pages/blog/Rust For Screeps (3) ç³»ç»Ÿç›‘æ§å’Œ panic å¤„ç†.html","content":"#todo [ ] TODO: ç³»ç»Ÿç›‘æ§å’Œ panic å¤„ç†","categories":["screeps"]},{"title":"Rust For Screeps (3): ç³»ç»Ÿç›‘æ§","path":"/pages/blog/Rust For Screeps (3) ç³»ç»Ÿç›‘æ§.html","content":"å‚è€ƒ Screeps åˆ¶ä½œç»Ÿè®¡å›¾è¡¨ - ç®€ä¹¦ é¦–å…ˆè¯´æ˜: æœ¬æ–‡ä½¿ç”¨ docker å°†ç›‘æ§ç³»ç»Ÿéƒ¨ç½²åœ¨è‡ªæœ‰æœåŠ¡å™¨ä¸Šï¼Œæ‰€ä»¥å…ˆå†³æ¡ä»¶æ˜¯ä¸€å°èƒ½å…¬ç½‘è®¿é—®çš„æœåŠ¡å™¨( æ•´ä½“æµç¨‹ å…·ä½“å®ç° è®°å½•å½“å‰çŠ¶æ€å­˜å…¥å†…å­˜ åœ¨ Screeps åˆ¶ä½œç»Ÿè®¡å›¾è¡¨ - ç®€ä¹¦ ä¸­ä½¿ç”¨çš„æ˜¯ memory object å­˜å‚¨ç³»ç»Ÿä¿¡æ¯ã€‚é—æ†¾çš„æ˜¯åœ¨ rust ä¸­æ— æ³•ä½¿ç”¨ memory å¯¹è±¡ï¼Œä½†æ˜¯ screeps è¿˜æœ‰å¦ä¸€ä¸ªå­˜å‚¨ä¿¡æ¯çš„åœ°æ–¹ï¼Œé‚£å°±æ˜¯ raw memory ã€‚ raw memory å¯ä»¥å­˜å‚¨ 10 MB çš„åºåˆ—åŒ–åçš„å†…å®¹ï¼Œå®ƒç”±ä¸€ä¸ªä¸ª segment ç»„æˆï¼Œæ¯ä¸ªsegment æœ€å¤šå­˜å‚¨ 100 KB å†…å®¹ã€‚æ‰€ä»¥å¯ä»¥æŒ‡å®šä¸€æ®µ segment ç”¨äºå­˜å‚¨å½“å‰ç³»ç»Ÿçš„çŠ¶æ€ã€‚ 12345fn log(&amp;self) &#123;\tlet status_segement = raw_memory::segments();\tlet status = Status::get_status();\tstatus_segement.set(STATUS_INDEX, status.into());&#125; è®¿é—®å†…å­˜å¹¶è§£æå†…å­˜å†…å®¹ GitHub - booiris/rust-learning at screep_log å°†ä¿¡æ¯å­˜å‚¨åˆ°æ—¶åºæ•°æ®åº“ä¸­ ä½¿ç”¨ Grafana åˆ¶ä½œå›¾è¡¨ 123456789101112131415161718192021222324252627282930313233343536373839404142version: &#x27;2&#x27;services: sync: restart: unless-stopped build: context: ./sync dockerfile: Dockerfile image: sync:1 volumes: - ./sync/log:/log depends_on: - influxdb# https://hub.docker.com/_/influxdb æŸ¥çœ‹å‚æ•°å«ä¹‰ influxdb: image: influxdb:latest restart: unless-stopped volumes: - ./influxdb-data:/var/lib/influxdb2 - ./influxdb-config:/etc/influxdb2 environment: - DOCKER_INFLUXDB_INIT_MODE=setup - DOCKER_INFLUXDB_INIT_USERNAME=$&#123;username&#125; - DOCKER_INFLUXDB_INIT_PASSWORD=$&#123;pwd&#125; - DOCKER_INFLUXDB_INIT_ORG=$&#123;org&#125; - DOCKER_INFLUXDB_INIT_BUCKET=$&#123;bucket&#125;# https://grafana.com/docs/grafana/latest/setup-grafana/installation/docker/ æŸ¥çœ‹å‚æ•°å«ä¹‰ grafana: image: grafana/grafana:latest restart: unless-stopped ports: - &#x27;12002:3000&#x27; volumes: - ./grafana-data:/var/lib/grafana - ./grafana-provisioning/:/etc/grafana/provisioning depends_on: - influxdb user: &quot;$UID:$GID&quot; environment: - GF_SECURITY_ADMIN_USER=$&#123;GRAFANA_USERNAME&#125; - GF_SECURITY_ADMIN_PASSWORD=$&#123;GRAFANA_PASSWORD&#125;","categories":["screeps"]},{"title":"Rust For Screeps (2): è‡ªå®šä¹‰å­˜å‚¨æ¨¡å‹","path":"/pages/blog/Rust For Screeps (2) è‡ªå®šä¹‰å­˜å‚¨æ¨¡å‹.html","content":"Screeps å­˜å‚¨æ¨¡å‹ screeps çš„å­˜å‚¨æ¨¡å‹åŸºæœ¬å¦‚å›¾æ‰€ç¤ºã€‚ å…¶ä¸­å­˜åœ¨ä¸¤ç§ç±»å‹çš„ memoryï¼Œä¸€ä¸ªæ˜¯ memory object ï¼Œå¦ä¸€ä¸ªæ˜¯ raw memory ã€‚ memory object memory object çš„å…·ä½“ä»‹ç»åœ¨ Global Objects | Screeps Documentationã€‚ Each player has access to the global objectÂ MemoryÂ in which he/she may store any information in the JSON format. 1Memory.someData = &#123;...&#125;; å¯ä»¥çœ‹å‡º screeps æœ¬èº«å†…ç½®äº†ä¸€ä¸ª Memory çš„å¯¹è±¡å®ä¾‹ã€‚å¯ä»¥å¾€å…¶ä¸­æ·»åŠ å„ç§å±æ€§æ¥è¾¾åˆ°å­˜å‚¨ä¿¡æ¯çš„ç›®çš„ã€‚ raw memory raw memory åœ¨è¿™é‡Œè¢«æåˆ° Global Objects | Screeps Documentation The Memory object is stored in the stringified form and is parsed each time upon the first in the tick access from your script with the help of theÂ JSON.parseÂ method. å¯ä»¥çœ‹å‡º Memory çš„å¯¹è±¡å®ä¾‹æœ€ç»ˆä¼šè¢«åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²å­˜å‚¨åˆ° raw memory ä¸­ï¼Œåœ¨æ¸¸æˆçš„æ¯ä¸ª tick è¿›è¡Œä¼ é€’ã€‚ å­˜å‚¨ä¼ é€’è¿‡ç¨‹ åœ¨æ¸¸æˆçš„è¿›è¡Œæ¯ä¸ª tick ï¼Œscreeps ç³»ç»Ÿä¼šååºåˆ—åŒ– raw memory åˆ° Memory Object (ä»£ç è§ game.jsã€game.js) 1234_.extend(runCodeCache[userId].globals, &#123;\tRawMemory: runCodeCache[userId].memory,\tconsole: runCodeCache[userId].fakeConsole&#125;); 12345678910111213141516171819202122Object.defineProperty(runCodeCache[userId].globals, &#x27;Memory&#x27;, &#123;\tconfigurable: true,\tenumerable: true,\tget() &#123; try &#123; runCodeCache[userId].memory._parsed = JSON.parse(runCodeCache[userId].memory.get() || &quot;&#123;&#125;&quot;); runCodeCache[userId].memory._parsed.__proto__ = null; &#125; catch (e) &#123; runCodeCache[userId].memory._parsed = null; &#125; Object.defineProperty(runCodeCache[userId].globals, &#x27;Memory&#x27;, &#123; configurable: true, enumerable: true, value: runCodeCache[userId].memory._parsed &#125;); return runCodeCache[userId].memory._parsed;\t&#125;&#125;); åœ¨æ¯ä¸ª tick æœ€åï¼Œå†å°† Memory åºåˆ—åŒ–åˆ° raw memory é‡Œã€‚æ‰€ä»¥ï¼Œåœ¨æ¯ä¸ª tick é—´ï¼ŒçœŸæ­£ä¼ é€’çš„æ˜¯ raw memoryã€‚ Rust å­˜å‚¨æ¨¡å‹ ä»ä¸Šé¢å¯ä»¥çŸ¥é“ï¼ŒScreeps æœ‰ä¸€ä¸ª JavaScript å¯¹è±¡ Memory ä¿å­˜éœ€è¦çš„ä¿¡æ¯ã€‚ä½†æ˜¯è¦ä» rust ä¸­è®¿é—® JavaScript é‡Œçš„å¯¹è±¡ååˆ†éº»çƒ¦ã€‚åŒæ—¶ screeps-game-api é‡Œä¼¼ä¹åªæœ‰ raw memory çš„è·å–æ–¹æ³•ï¼Œè€Œæ²¡æœ‰ memory å¯¹è±¡çš„è·å–æ–¹æ³•ã€‚ æ‰€ä»¥æ˜¾ç„¶æ˜“è§ï¼Œæˆ‘ä»¬çš„å­˜å‚¨ä¿¡æ¯éœ€è¦æ”¾åˆ° rust é‡Œã€‚åœ¨ä¸Šä¸€ç« çš„ç¤ºä¾‹ä»£ç ä¸­ï¼Œæœ‰è¿™æ ·ä¸€ä¸ªå˜é‡: 12345// this is one way to persist data between ticks within Rust&#x27;s memory, as opposed to// keeping state in memory on game objects - but will be lost on global resets!thread_local! &#123; static CREEP_TARGETS: RefCell&lt;HashMap&lt;String, CreepTarget&gt;&gt; = RefCell::new(HashMap::new());&#125; æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ RefCell åˆ›å»ºä¸€ä¸ªå…¨å±€å˜é‡ (ç±»ä¼¼ javaScript é‡Œçš„ Memory å¯¹è±¡) å­˜å‚¨åˆ° wasm çš„çº¿æ€§å†…å­˜é‡Œã€‚åªè¦ wasm çš„å®ä¾‹æ²¡æœ‰è¢«é”€æ¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå…¨å±€å˜é‡å°±å¯ä»¥éšç€ wasm å®ä¾‹åœ¨æ¯ä¸ª tick ä¼ é€’ã€‚ è‡ªå®šä¹‰å­˜å‚¨å®ç° é€šè¿‡ rust çš„å…¨å±€å˜é‡æˆ‘ä»¬å®ç°äº†ä¿¡æ¯è·¨ tick å­˜å‚¨ï¼Œä½†æ³¨æ„åˆ°æ³¨é‡Šä¸­å­˜åœ¨ç€ä¸€å¥è¯ã€‚ keeping state in memory on game objects - but will be lost on global resets! Screeps ç³»ç»Ÿå­˜åœ¨ç€ä¸€ä¸ªæœºåˆ¶ï¼Œå°±æ˜¯ global reset ï¼Œä¼šå®šæ—¶é”€æ¯ javaScript é‡Œçš„å¯¹è±¡å¹¶ä¸”é‡å»ºï¼Œè¿™å°±å¯¼è‡´äº†è¿™ä¼šé”€æ¯ wasm çš„å®ä¾‹ï¼Œè¿›è€Œå¯¼è‡´å­˜å‚¨çš„ä¿¡æ¯ä¸¢å¤±ã€‚ raw memory ä½¿ç”¨ ä»ç¬¬ä¸€éƒ¨åˆ†å¯ä»¥çŸ¥é“ raw memory å¯ä»¥è®¤ä¸ºæ˜¯ Screeps ä¸­çš„æŒä¹…æ€§å­˜å‚¨ã€‚æ‰€ä»¥å¦‚æœå¯ä»¥åœ¨æ¯ä¸ª tick æœ€åæŠŠ rust é‡Œçš„å…¨å±€å˜é‡åºåˆ—åŒ–åˆ° raw memory é‡Œï¼Œç„¶ååœ¨ wasm å®ä¾‹åˆå§‹åŒ–æ—¶å†ä» raw memory é‡Œååºåˆ—åŒ–å› rust çš„å…¨å±€å˜é‡ï¼Œè¿™å°±å®ç°äº†ä¿¡æ¯çš„è·¨ tick ä¿å­˜è€Œåˆä¸ä¼šå—åˆ° global reset çš„å½±å“ã€‚ rust éƒ¨åˆ†å®ç° Screeps çš„ api å­˜åœ¨å¯¹ raw memory çš„æ“ä½œæ–¹æ³• Screeps Documentationã€‚ å‚¨å­˜å…¨å±€å˜é‡å‚è€ƒä»£ç : 123456789thread_local! &#123; pub static GLOBAL_LONG_MEMORY: RefCell&lt;GlobalMemory&gt; = RefCell::new(GlobalMemory::new());&#125;GLOBAL_LONG_MEMORY.with(|mem| &#123;\tlet mem = &amp;*mem.borrow();\tlet mem: String = mem.into();\traw_memory::set(&amp;JsString::from_str(&amp;mem).expect(&quot;can conver global mem to string&quot;))&#125;); å…¶ä¸­ GlobalMemory æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œå¹¶ä¸”å®ç°äº† into String çš„æ–¹æ³•ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ mem.into() è½¬æ¢ä¸º String ç±»å‹ï¼Œæœ€åé€šè¿‡ api çš„ raw_memory::set æ–¹æ³•å°†å…¨å±€å˜é‡ä¿å­˜åˆ° raw memory ä¸­ã€‚ åˆå§‹åŒ–å…¨å±€å˜é‡å‚è€ƒä»£ç : 1234567891011GLOBAL_LONG_MEMORY.with(|mem| &#123;\tlet raw_memory: String = raw_memory::get() .try_into() .expect(&quot;can not get raw memory&quot;);\tif let Ok(raw_mem) = GlobalMemory::try_from(raw_memory) &#123; *mem.borrow_mut() = raw_mem;\t&#125; else &#123; log::error!(&quot;old mem can not match new struct!&quot;); *mem.borrow_mut() = GlobalMemory::new();\t&#125;&#125;); å¯ä»¥çœ‹å‡ºï¼Œå­˜åœ¨æ— æ³•ä» raw memory è¿˜åŸå›å…¨å±€å˜é‡çš„æƒ…å†µ ( GlobalMemory çš„ç»“æ„å‡ºç°äº†ç ´åæ€§çš„æ›´æ”¹å¯¼è‡´æ— æ³•ä»ä¹‹å‰çš„ç»“æ„ååºåˆ—åŒ–å›å»)ã€‚è¿™æ—¶å€™éœ€è¦è€ƒè™‘æ„å»ºä¸€ä¸ªåœ¨ç©ºçš„å…¨å±€å˜é‡ä¸‹è¿˜èƒ½ç»§ç»­è¿è¡Œå¹¶ä¸”è¿˜åŸçš„ç³»ç»Ÿã€‚ javaScript éƒ¨åˆ†å®ç° æœ¬æ¥å­˜å‚¨ raw memory çš„è¿‡ç¨‹åœ¨ rust ä¸­å®ç°å³å¯ã€‚ä½†æ˜¯å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼ŒScreeps ç³»ç»Ÿè¿è¡Œä¸­ï¼ŒæŸäº›åŠ¨ä½œ (æ¯”å¦‚ creep_move) ä¼šä½¿ç”¨çš„ memory object å®ä¾‹ï¼Œæ‰€ä»¥ä¼šå¯¹ raw memory è¿›è¡Œååºåˆ—åŒ–ã€‚ä¸ºäº†ä¸å¿…è¦çš„æ¶ˆè€—ï¼Œæˆ‘ä»¬å¯ä»¥æŒæœ‰ä¸€ä¸ª mem_proxy å¯¹è±¡å®ä¾‹ï¼Œæ¯ä¸ª tick å¼€å§‹ï¼Œå°±å¯¹ memory object è¿›è¡Œèµ‹å€¼ï¼Œè¿™æ ·å°±ä¸ä¼šè§¦å‘ååºåˆ—åŒ–ï¼Œå‡å°‘ cpu æ¶ˆè€—ã€‚ å‚è€ƒ Screepsæ¸¸æˆ Memoryä»™æœ¯ - ç®€ä¹¦ å®ç°ä»£ç å¦‚ä¸‹: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&quot;use strict&quot;;let wasm_module;const MODULE_NAME = &quot;rust-screep-world&quot;;function console_error(...args) &#123; console.log(...args); Game.notify(args.join(&#x27; &#x27;));&#125;let mem_proxy = &#123; creeps: &#123;&#125; &#125;module.exports.loop = function () &#123; delete global.Memory; global.Memory = mem_proxy RawMemory._parsed = mem_proxy try &#123; if (wasm_module) &#123; wasm_module.loop(); &#125; else &#123; // attempt to load the wasm only if there&#x27;s enough bucket to do a bunch of work this tick if (Game.cpu.bucket &lt; 500) &#123; console.log(&quot;we are running out of time, pausing compile!!!&quot; + JSON.stringify(Game.cpu)); return; &#125; // delect the module from the cache, so we can reload it if (MODULE_NAME in require.cache) &#123; delete require.cache[MODULE_NAME]; &#125; // replace this initialize function on the module wasm_module = require(MODULE_NAME); // load the wasm instance! wasm_module.initialize_instance(); // run the setup function, which configures logging wasm_module.setup(); // go ahead and run the loop for its first tick wasm_module.loop(); &#125; &#125; catch (error) &#123; console_error(&quot;caught exception err:&quot;, error); if (error.stack) &#123; console_error(&quot;stack trace:&quot;, error.stack); &#125; console_error(&quot;resetting VM next tick.&quot;); wasm_module = null; &#125; mem_proxy = global.Memory&#125;","categories":["screeps"]},{"title":"Rust For Screeps (1): åˆå§‹ç¯å¢ƒæ­å»º","path":"/pages/blog/Rust For Screeps (1) åˆå§‹ç¯å¢ƒæ­å»º.html","content":"å‚è€ƒ GitHub - rustyscreeps/screeps-starter-rust: Starter Rust AI for Screeps, the JavaScript-based MMO game å®‰è£…ç›¸å…³cli 1cargo install cargo-screeps å‘½ä»¤åŒ…å«äº†æ„å»ºä»£ç ã€ä¸Šä¼ ä»£ç ç­‰æ“ä½œã€‚ ä¸‹è½½æ¨¡æ¿æ–‡ä»¶ 12git clone https://github.com/rustyscreeps/screeps-starter-rust.gitcd screeps-starter-rust æ¨¡æ¿ (ç‰ˆæœ¬:d91b60f9a13eb0bd763b094acb6a1d749bb1b12f) ä¸­åŒ…å«çš„æ–‡ä»¶: 12345678910./â”œâ”€â”€ Cargo.tomlâ”œâ”€â”€ example-screeps.tomlâ”œâ”€â”€ javascriptâ”‚ â””â”€â”€ main.jsâ”œâ”€â”€ LICENSEâ”œâ”€â”€ README.mdâ””â”€â”€ src â”œâ”€â”€ lib.rs â””â”€â”€ logging.rs æ¨¡æ¿æ–‡ä»¶è¯´æ˜ example-screeps.toml ç”¨äº cargo-screeps çš„é…ç½®ã€‚ javascript/main.js ä¸ºæ¸¸æˆä¸»å…¥å£ï¼Œå…¶ä¸­å†…å®¹å¦‚ä¸‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344&quot;use strict&quot;;let wasm_module;// replace this with the name of your moduleconst MODULE_NAME = &quot;screeps-starter-rust&quot;;function console_error(...args) &#123; console.log(...args); Game.notify(args.join(&#x27; &#x27;));&#125;module.exports.loop = function () &#123; try &#123; if (wasm_module) &#123; wasm_module.loop(); &#125; else &#123; // attempt to load the wasm only if there&#x27;s enough bucket to do a bunch of work this tick if (Game.cpu.bucket &lt; 500) &#123; console.log(&quot;we are running out of time, pausing compile!&quot; + JSON.stringify(Game.cpu)); return; &#125; // delect the module from the cache, so we can reload it if (MODULE_NAME in require.cache) &#123; delete require.cache[MODULE_NAME]; &#125; // load the wasm module wasm_module = require(MODULE_NAME); // load the wasm instance! wasm_module.initialize_instance(); // run the setup function, which configures logging wasm_module.setup(); // go ahead and run the loop for its first tick wasm_module.loop(); &#125; &#125; catch (error) &#123; console_error(&quot;caught exception:&quot;, error); if (error.stack) &#123; console_error(&quot;stack trace:&quot;, error.stack); &#125; console_error(&quot;resetting VM next tick.&quot;); wasm_module = null; &#125;&#125; æ–‡ä»¶ä¸­ wasm_module ä¿å­˜äº† wasm çš„å®ä¾‹ã€‚å¦‚æœ wasm çš„å®ä¾‹å­˜åœ¨ï¼Œå°±è°ƒç”¨ loop å‡½æ•°è¿è¡Œæ¸¸æˆé€»è¾‘ã€‚å¦‚æœ wasm çš„å®ä¾‹ä¸å­˜åœ¨ (ç”±äºæ›´æ–°ä»£ç æˆ– screeps è¿›è¡Œäº†å†…å­˜å›æ”¶ç­‰åŸå› å¯¼è‡´å®åˆ—è¢«é”€æ¯)ï¼Œé‡æ–°è½½å…¥ wasm å¹¶ä¸”è°ƒç”¨ setup å‡½æ•°è¿›è¡Œåˆå§‹åŒ–ï¼Œç„¶åå†è¿è¡Œæ¸¸æˆé€»è¾‘ã€‚ src/logging.rs ä¸ºè¾…åŠ©æ–‡ä»¶ï¼Œç”¨äºæ—¥å¿—çš„å®ç°ã€‚åŸºæœ¬ä¸Šå°±æ˜¯è¿›è¡Œ log æ ¼å¼çš„åˆ›å»ºï¼Œä¸åšè¿‡å¤šè¯´æ˜ã€‚åœ¨ setup é˜¶æ®µè°ƒç”¨ä¸€ä¸‹ setup_logging å‡½æ•°å°±è¡Œã€‚ src/lib.rs ä¸º rust çš„å®ç°é€»è¾‘å…¥å£ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273use std::cell::RefCell;use std::collections::&#123;hash_map::Entry, HashMap&#125;;use log::*;use screeps::&#123; constants::&#123;ErrorCode, Part, ResourceType&#125;, enums::StructureObject, find, game, local::ObjectId, objects::&#123;Creep, Source, StructureController&#125;, prelude::*,&#125;;use wasm_bindgen::prelude::*;mod logging;// add wasm_bindgen to any function you would like to expose for call from js#[wasm_bindgen]pub fn setup() &#123; logging::setup_logging(logging::Info);&#125;// this is one way to persist data between ticks within Rust&#x27;s memory, as opposed to// keeping state in memory on game objects - but will be lost on global resets!thread_local! &#123; static CREEP_TARGETS: RefCell&lt;HashMap&lt;String, CreepTarget&gt;&gt; = RefCell::new(HashMap::new());&#125;// this enum will represent a creep&#x27;s lock on a specific target object, storing a js reference// to the object id so that we can grab a fresh reference to the object each successive tick,// since screeps game objects become &#x27;stale&#x27; and shouldn&#x27;t be used beyond the tick they were fetched#[derive(Clone)]enum CreepTarget &#123; Upgrade(ObjectId&lt;StructureController&gt;), Harvest(ObjectId&lt;Source&gt;),&#125;// to use a reserved name as a function name, use `js_name`:#[wasm_bindgen(js_name = loop)]pub fn game_loop() &#123; debug!(&quot;loop starting! CPU: &#123;&#125;&quot;, game::cpu::get_used()); // mutably borrow the creep_targets refcell, which is holding our creep target locks // in the wasm heap CREEP_TARGETS.with(|creep_targets_refcell| &#123; let mut creep_targets = creep_targets_refcell.borrow_mut(); debug!(&quot;running creeps&quot;); for creep in game::creeps().values() &#123; run_creep(&amp;creep, &amp;mut creep_targets); &#125; &#125;); debug!(&quot;running spawns&quot;); let mut additional = 0; for spawn in game::spawns().values() &#123; debug!(&quot;running spawn &#123;&#125;&quot;, String::from(spawn.name())); let body = [Part::Move, Part::Move, Part::Carry, Part::Work]; if spawn.room().unwrap().energy_available() &gt;= body.iter().map(|p| p.cost()).sum() &#123; // create a unique name, spawn. let name_base = game::time(); let name = format!(&quot;&#123;&#125;-&#123;&#125;&quot;, name_base, additional); // note that this bot has a fatal flaw; spawning a creep // creates Memory.creeps[creep_name] which will build up forever; // these memory entries should be prevented (todo doc link on how) or cleaned up match spawn.spawn_creep(&amp;body, &amp;name) &#123; Ok(()) =&gt; additional += 1, Err(e) =&gt; warn!(&quot;couldn&#x27;t spawn: &#123;:?&#125;&quot;, e), &#125; &#125; &#125; info!(&quot;done! cpu: &#123;&#125;&quot;, game::cpu::get_used())&#125; å…¶ä¸­éœ€è¦å…³æ³¨ä¸¤ä¸ªå‡½æ•° setup å’Œ game_loop ã€‚ setup ä¸º wasm å®ä¾‹åˆ›å»ºçš„æ—¶å€™è°ƒç”¨çš„å‡½æ•°ï¼Œåœ¨å…¶ä¸­å¯ä»¥å®ç°æ—¥å¿—åˆå§‹åŒ–ã€æ•°æ®åˆå§‹åŒ–çš„é€»è¾‘ã€‚ game_loop é€šè¿‡ #[wasm_bindgen(js_name = loop)] çš„æ ‡æ³¨ (rust ä¸­ç§°ä¸ºè¿‡ç¨‹å®) å°†å…¶æ”¹åä¸ºwasm é‡Œè¿è¡Œçš„ loop å‡½æ•°ï¼Œè¿™ä¹Ÿæ˜¯æ¸¸æˆä¸­æ¯ tick è¿è¡Œçš„ä¸»é€»è¾‘ã€‚","categories":["screeps"]},{"title":"æ‚è®°","path":"/pages/linux/æ‚è®°.html","content":"[[2022-08-20]] æˆ‘ä»¬å»ºç«‹sshéš§é“çš„æ—¶å€™ï¼Œå¾€å¾€æ˜¯æƒ³é€šè¿‡ä¸€å°å…¬ç½‘çš„ä¸»æœºæˆ–è€…æ˜¯å¤§å®¶éƒ½å¯ä»¥è®¿é—®çš„ä¸»æœºåšè·³è½¬æœºï¼Œæ¥è®¿é—®å†…éƒ¨æˆ–è€…å¤–éƒ¨ä¸èƒ½ç›´æ¥è®¿é—®çš„æœºå™¨ã€‚æ‰€ä»¥ä¸€èˆ¬åƒè¿™ç§æƒ…å†µä¸‹ï¼Œè¯·å°†è·³è½¬æœºä¸­çš„sshæœåŠ¡å™¨ä¸­çš„GatewayPortsè®¾ä¸ºyesã€‚ ç«¯å£è½¬å‘æ—¶å‚æ•°ä¸º -NfR [[2022-08-30]] dockerè¿è¡Œsystemctl 1docker run -d --name desk -p 2222:22 -v /home/booiris:/home/booiris --hostname vm-host --env container=docker --privileged archlinux /sbin/init [[2022-10-08]] @ + æ—¶é—´ == today rust partition_point(|x| x &lt; &amp;s) å‡½æ•° lower_bound upper_bound åœ¨ä½ç½®å·¦è¾¹çš„ä¸ºæ»¡è¶³è¡¨è¾¾å¼çš„å€¼ï¼Œå³è¾¹ä¸ºä¸æ»¡è¶³è¡¨è¾¾å¼çš„å€¼ã€‚ [[2022-12-25]] çµæ„Ÿï¼š å¡ç‰Œæ‹“å°åœºæ™¯ä¸­çš„å…ƒç´  æ§åˆ¶äººç‰©ä¼šæœ‰å½±å“","categories":["linux"]},{"title":"linuxè‡ªå¯åŠ¨æœåŠ¡","path":"/pages/linux/linuxè‡ªå¯åŠ¨æœåŠ¡.html","content":"è‡ªå¯åŠ¨æ–‡ä»¶æ”¾åœ¨ /usr/lib/systemd/system 12345678910[Unit]Description=code-server[Service]Type=simpleExecStart=/usr/bin/code-serverUser=your user name[Install]WantedBy=multi-user.target 123sudo systemctl daemon-reload #åˆ·æ–°sudo systemctl start code-serversudo systemctl enable code-server","categories":["linux"]},{"title":"archè™šæ‹Ÿæœºå®‰è£…","path":"/pages/linux/archè™šæ‹Ÿæœºå®‰è£….html","content":"æŸ¥çœ‹ipåœ°å€ 1ip addr æ—¶é—´åŒæ­¥ 1timedatectl set-ntp true å‡†å¤‡ç£ç›˜åˆ†åŒº æ˜¾ç¤ºæ‰€æœ‰åˆ†åŒº 1fdisk -l å¼€å§‹åˆ†åŒº 1fdisk /dev/sda åˆ†åŒºè¿‡ç¨‹å‚è€ƒç½‘å€ ç¡®è®¤æ˜¯å¦ç”Ÿæ•ˆ 1fdisk -l /dev/sda æ ¼å¼åŒ–åˆ†åŒºå’Œè®¾ç½®swapåˆ†åŒº 123mkfs.fat -F32 /dev/sda1mkswap /dev/sda2mkfs.ext4 /dev/sda3 å¯ç”¨äº¤æ¢åˆ†åŒº 1swapon /dev/sda2 æŒ‚è½½æ ¹ç›®å½• 1mount /dev/sda3 /mnt æŒ‚è½½bootç›®å½• 12mkdir /mnt/bootmount /dev/sda1 /mnt/boot å®‰è£…ç³»ç»Ÿ ä¿®æ”¹é•œåƒæº 1vim /etc/pacman.d/mirrorlist æ·»åŠ  Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch é•œåƒ å¦‚æœå®‰è£…æ—¶æŠ¥é”™Â ERROR: 5984EA8F3C could not be locally signedÂ è§£å†³åŠæ³•ï¼š 123456rm -fr /etc/pacman.d/gnupgumount /etc/pacman.d/gnupgrm -fr /etc/pacman.d/gnupgpacman-key --initpacman-key --populate archlinuxpacman -Sy archlinux-keyring å®‰è£…ç³»ç»Ÿå’Œç½‘ç»œæ’ä»¶ 1pacstrap /mnt base linux networkmanager é…ç½®ç³»ç»Ÿ ç”Ÿæˆfstabæ–‡ä»¶ 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab è¿›å…¥chroot 1arch-chroot /mnt è®¾ç½®æ—¶åŒº 1ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime è®¾ç½®ç¡¬ä»¶æ—¶é—´åŒæ­¥ 1hwclock --systohc å®‰è£…vim 1pacman -S vim è¯­è¨€è®¾ç½® 123vim /etc/locale.genen_USzh_CN ç”Ÿæˆè¯­è¨€ 1locale-gen è®¾ç½®é»˜è®¤è¯­è¨€ 1echo LANG=en_US.UTF-8 &gt; /etc/locale.conf åˆ›å»ºhostæ–‡ä»¶ 1echo YourNewHostname &gt; /etc/hostname æ·»åŠ host 123456vim /etc/hosts# Static table lookup for hostnames. # See hosts(5) for details. 127.0.0.1 localhost ::1 localhost 127.0.1.1 YourNewHostname.localdomain YourNewHostname å¼€å¯ç½‘ç»œæœåŠ¡ 1systemctl enable NetworkManager è®¾ç½® root ç”¨æˆ·å¯†ç  1passwd å®‰è£…å¼•å¯¼ç¨‹åº UEFI ç³»ç»Ÿï¼š 123pacman -S grub efibootmgrgrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=&quot;Arch Linux&quot; --recheckgrub-mkconfig -o /boot/grub/grub.cfg å®Œæˆå®‰è£… 123exitumount -R /mntreboot å¤‡æ³¨ å®ä½“æœºå®‰è£…ç±»ä¼¼ï¼Œå…³é—­æ˜¾ç¤ºå± 1setterm -blank 1 # å¾…æœºä¸€åˆ†é’Ÿå…³é—­æ˜¾ç¤ºå± åœ¨è¿›å…¥fakerootåå®‰è£… intel-ucode,ç”µæºç®¡ç†tlp","categories":["linux"]},{"title":"nginxåå‘ä»£ç†è‡ªç­¾å","path":"/pages/linux/nginxåå‘ä»£ç†è‡ªç­¾å.html","content":"è‡ªç­¾åcaè¯ä¹¦ é¦–å…ˆåˆ›å»ºcertæ–‡ä»¶å¤¹ä¿å­˜è¯ä¹¦ã€‚ 12mkdir certcd cert ç„¶ååˆ›å»ºé…ç½®æ–‡ä»¶cert.cnfï¼Œæ³¨æ„å¦‚æœæ—¶ipè‡ªç­¾åå°±åœ¨your_IPå¡«å†™è‡ªå·±çš„ipï¼Œå¦‚æœæ˜¯è‡ªç­¾ååŸŸåå°±æ˜¯åœ¨your_domainå†™è‡ªå·±çš„åŸŸåã€‚ [dn]ä¸‹CNå­—æ®µæ˜¯caæ ¹æœåŠ¡å™¨åœ°å€ï¼Œalt_namesä¸‹æ˜¯caéªŒè¯çš„ipå’ŒåŸŸååœ°å€ï¼Œä¸€èˆ¬æƒ…å†µä¸‹è¿™ä¸¤ä¸ªæ˜¯ä¸€æ ·çš„ã€‚ 12345678910111213141516171819202122232425[req] prompt = no default_bits = 4096default_md = sha256distinguished_name = dn x509_extensions = v3_req[dn] C=CNST=ShanghaiL=ShanghaiO=TESTOU=Testing DomainCN=$your_IP or $your_domainemailAddress=admin@localhost[v3_req]basicConstraints=CA:TRUEkeyUsage=digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentextendedKeyUsage=serverAuthsubjectAltName=@alt_names[alt_names]IP.1=$your_IPDNS.1=$your_domain æ ¹æ®é…ç½®æ–‡ä»¶ç”Ÿæˆè¯ä¹¦ã€‚ 1openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout cert.key -out cert.crt -config cert.cnf å½“å‰ç›®å½•ä¸‹ç”Ÿæˆä¸¤ä¸ªæ–‡ä»¶cert.crtå’Œcert.keyï¼Œè‡³æ­¤è‡ªç­¾åæ­¥éª¤å®Œæˆã€‚ nginxåå‘ä»£ç† dockeræ‹‰å–nginxé•œåƒã€‚ 1docker pull nginx æ–°å»ºä¸€ä¸ªå®¹å™¨è·å–configæ–‡ä»¶ã€‚ 1234docker run -d --name nginx nginxdocker cp nginx:/etc/nginx/nginx.conf ./nginx.confdocker stop nginxdocker rm nginx åœ¨configæ–‡ä»¶çš„httpå†…åŠ å…¥å¦‚ä¸‹å†…å®¹ã€‚ 123456789101112131415161718192021server&#123;\tlisten 443 ssl;\tserver_name $your_ip or website;\tssl_certificate /cert/cert.crt;\tssl_certificate_key /cert/cert.key;\tssl_session_cache shared:SSL:1m;\tssl_session_timeout 5m;\tssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #åŠ å¯†ç®—æ³•\tssl_protocols TLSv1 TLSv1.1 TLSv1.2; #å®‰å…¨é“¾æ¥å¯é€‰çš„åŠ å¯†åè®®\tssl_prefer_server_ciphers on; #ä½¿ç”¨æœåŠ¡å™¨ç«¯çš„é¦–é€‰ç®—æ³•\tlocation / &#123; proxy_pass http://$your_proxy_ip:$your_proxy_port; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Accept-Encoding gzip;\t&#125;&#125; ä½¿ç”¨nginxåå‘ä»£ç†ã€‚ 1docker run -d --restart=always -p $your_port:443 --name nginx -v &quot;$PWD&quot;/nginx.conf:/etc/nginx/nginx.conf -v &quot;$PWD&quot;/cert:/cert nginx æ›´æ–°nginx 1234#æµ‹è¯•é…ç½®æ–‡ä»¶docker exec nginx nginx -t #æ›´æ–°nginxé…ç½®docker exec nginx nginx -s reload","categories":["linux"]},{"title":"Data Lab","path":"/pages/csapp/Data Lab.html","content":"CS:APP Data Lab restriction Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. Function arguments and local variables (no global variables). Unary integer operations ! ~ Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt; NOT ALLOW Use any control constructs such as if, do, while, for, switch, etc. Define or use any macros. Define any additional functions in this file. Call any functions. Use any other operations, such as &amp;&amp;, ||, -, or ?: Use any form of casting. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. Question q1 Description bitXor - x^y using only ~ and &amp;. Example bitXor(4, 5) = 1 Answer xâŠ•y=(âˆ¼xâˆ§y)âˆ¨(xâˆ§âˆ¼y)=âˆ¼(âˆ¼(âˆ¼xâˆ§y)âˆ§âˆ¼(xâˆ§âˆ¼y))xâŠ•y=(xâˆ¨y)âˆ§(âˆ¼xâˆ¨âˆ¼y)=âˆ¼(âˆ¼xâˆ§âˆ¼y)âˆ§âˆ¼(xâˆ§y)\\begin{aligned} x \\oplus y &amp;= (\\sim x \\wedge y) \\vee (x \\wedge \\sim y) = \\sim(\\sim(\\sim x \\wedge y) \\wedge \\sim(x \\wedge \\sim y)) \\\\ x \\oplus y &amp;= (x \\vee y) \\wedge (\\sim x \\vee \\sim y) = \\sim(\\sim x \\wedge \\sim y) \\wedge \\sim (x \\wedge y) \\end{aligned} xâŠ•yxâŠ•yâ€‹=(âˆ¼xâˆ§y)âˆ¨(xâˆ§âˆ¼y)=âˆ¼(âˆ¼(âˆ¼xâˆ§y)âˆ§âˆ¼(xâˆ§âˆ¼y))=(xâˆ¨y)âˆ§(âˆ¼xâˆ¨âˆ¼y)=âˆ¼(âˆ¼xâˆ§âˆ¼y)âˆ§âˆ¼(xâˆ§y)â€‹ Compare eq1 and eq2, eq1 uses five NOT operations and three AND operations, eq2 uses four NOT operations and three AND operations. Therefore eq2 is better. Code 1234int bitXor(int x, int y) &#123; return ~(x &amp; y) &amp; ~(~x &amp; ~y); // return ~(~(x &amp; ~y) &amp; ~(~x &amp; y));&#125; q2 Description tmin - return minimum twoâ€™s complement integer. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;. Answer For data of type int, the minimum value is âˆ’231-2^{31}âˆ’231 which is expressed in binary as 1|0x31. Code 123int tmin(void) &#123; return 1 &lt;&lt; 31;&#125; q3 Description IsTmax - returns 1 if x is the maximum, twoâ€™s complement number, and 0 otherwise. Legal ops: ! ~ &amp; ^ | +. Answer Notice that only when x = -1 or x = INT_MAX, x^(x+1) = 0xffffffff. Therefore, we can use a = ~(x ^ (x+1)) to find INT_MAX and -1. when a = 0, x = INT_MAX or -1. Next step we need to distinguish INT_MAX and -1. Notice that -1 + 1 = 0. So we can use b = !(x+1) to find -1. when b = 0, x = INT_MAX; b = 1, x = -1. At Last, we can use res = !(a | b) to check whether x is INT_MAX. Code 12345int isTmax(int x) &#123; int temp = x + 1; int a = ~(x ^ temp); return !((!temp) | a);&#125; q4 Description allOddBits - return 1 if all odd-numbered bits in word set to 1 where bits are numbered from 0 (least significant) to 31 (most significant). Example Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1. Answer We can use (x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA to check if all odd-numbered bits in word set to 1. Therefore itâ€™s important to get a constant 0xAAAAAAAA. Since we can only use 0 ~ 0xff, we can simply repeate flowing code four times to get 0xAAAAAAAA. 12key |= 0xaa;key &lt;&lt;= 8; However, it will cost 2 * 4 = 8 operations. We can use a better way to get constant. get a = 0xAA. get b = 0xAAAA. get c = 0xAAAAAAAA. Itâ€™s a bit like binary serach. Every time we can construct double length number. Therefore to build a 32 bits number, we just use log(324)=3log(\\frac{32}{4}) = 3log(432â€‹)=3 operations to get the number. Code 1234567int allOddBits(int x) &#123; int a = 0xaa; int b = a | a &lt;&lt; 8; int c = b | b &lt;&lt; 16; return !((x &amp; c) ^ c);&#125; q5 Description negate - return -x Example Example: negate(1) = -1. Answer Since x + ~x = -1, we can change it to -x = ~x + 1. Code 1234int negate(int x)&#123; return ~x + 1;&#125; q6 Description isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters â€˜0â€™ to â€˜9â€™) Example isAsciiDigit(0x35) = 1. isAsciiDigit(0x3a) = 0. isAsciiDigit(0x05) = 0. Answer %TODO Code 12345678910int isAsciiDigit(int x)&#123; int a = x &gt;&gt; 4; int key = 0x3; int check1 = !(key ^ a); int check2 = !((x &gt;&gt; 3) &amp; 1); int check3 = !(x ^ 0x38); int check4 = !(x ^ 0x39); return check1 &amp; (check2 | check3 | check4);&#125; q7 Description conditional - same as x ? y : z Example Example: conditional(2,4,5) = 4 Answer At first, we can use x = !x to make f(x)=0{xâ‰ 0},1{x=0}f(x)= 0 \\{x eq 0\\}, 1 \\{x = 0\\}f(x)=0{xî€ =0},1{x=0}. With x = ~x + 1, we can get g(x)=ffff{xâ‰ 0},0000{x=0}g(x) = ffff \\{x eq 0 \\}, 0000\\{x=0\\}g(x)=ffff{xî€ =0},0000{x=0}. Notice that y ^ y ^ z = z, y ^ 0 = y. Therefore, we can use y ^ ((y ^ z) &amp; x) to get answer. When x = 0, (y ^ z) &amp; x = y ^ z, otherwise, (y ^ z) &amp; x = 0. Code 123456int conditional(int x, int y, int z)&#123; x = !x; x = ~x + 1; return y ^ ((y ^ z) &amp; x);&#125;","categories":["csapp"]},{"title":"æ ‘çŠ¶æ•°ç»„","path":"/pages/algorithm/segment_tree/æ ‘çŠ¶æ•°ç»„.html","content":"åŒºé—´å’Œæ¨¡æ¿ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pub struct Bitree &#123; tree: Vec&lt;i32&gt;, len: usize,&#125;impl Bitree &#123; #[inline] pub fn new(ini: &amp;Vec&lt;i32&gt;) -&gt; Self &#123; let mut res = Bitree &#123; tree: vec![0; ini.len() + 1], len: ini.len(), &#125;; for (index, v) in ini.iter().enumerate() &#123; res.update(index + 1, *v); &#125; res &#125; #[inline] fn lowbit(x: usize) -&gt; usize &#123; return (x as i32 &amp; -(x as i32)) as usize; &#125; fn update(&amp;mut self, index: usize, v: i32) &#123; let mut pos = index; while pos &lt;= self.len &#123; self.tree[pos] += v; pos += Self::lowbit(pos); &#125; &#125; fn get(&amp;self, n: usize) -&gt; i32 &#123; let mut res = 0; let mut pos = n; while pos &gt; 0 &#123; res += self.tree[pos]; pos -= Self::lowbit(pos); &#125; res &#125; /// `query` ä¸‹æ ‡ä»`1`å¼€å§‹ pub fn query(&amp;self, l: usize, r: usize) -&gt; i32 &#123; self.get(r) - self.get(l - 1) &#125;&#125; æŸ¥è¯¢ logâ¡(n)\\log(n)log(n) ,æ›´æ–° logâ¡(n)\\log(n)log(n)ã€‚ åŒºé—´æœ€å€¼æ¨¡ç‰ˆ: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051use std::cmp::*;pub struct Bitree &#123; tree: Vec&lt;i32&gt;, val: Vec&lt;i32&gt;, len: usize,&#125;impl Bitree &#123; #[inline] pub fn new(len: usize) -&gt; Self &#123; Bitree &#123; tree: vec![0; len + 1], val: vec![0; len + 1], len, &#125; &#125; #[inline] fn lowbit(x: usize) -&gt; usize &#123; return (x as i32 &amp; -(x as i32)) as usize; &#125; fn update(&amp;mut self, index: usize, v: i32) &#123; let mut pos = index; self.val[pos] = v; while pos &lt;= self.len &#123; self.tree[pos] = self.val[pos]; let low = Self::lowbit(pos); let mut i = 1; while i &lt; low &#123; self.tree[pos] = max(self.tree[pos], self.tree[pos - i]); i &lt;&lt;= 1; &#125; pos += Self::lowbit(pos); &#125; &#125; /// `query` ä¸‹æ ‡ä»`1`å¼€å§‹ pub fn query(&amp;self, mut l: i32, mut r: i32) -&gt; i32 &#123; let mut res = 0; l = max(1, l); while r &gt;= l &#123; res = max(res, self.val[r as usize]); r -= 1; while r - Self::lowbit(r as usize) as i32 &gt;= l &#123; res = max(res, self.tree[r as usize]); r -= Self::lowbit(r as usize) as i32; &#125; &#125; res &#125;&#125; æŸ¥è¯¢ logâ¡(n)\\log(n)log(n) ,æ›´æ–° logâ¡(n)2\\log(n)^2log(n)2ã€‚","categories":["algorithm","segment_tree"]},{"title":"Obsidian å¤šå¹³å°åŒæ­¥æ–¹æ³•","path":"/pages/blog/sync.html","content":"! æ¨èè‡ªå»º webdav æœåŠ¡ webdav åŒæ­¥ ä½¿ç”¨ Remotely Save æ’ä»¶è¿›è¡Œå¤šå¹³å°åŒæ­¥ã€‚ æ³¨å†Œ webdav æœåŠ¡ ä½¿ç”¨ TeraCLOUD ç½‘ç›˜ã€‚ä½¿ç”¨æ­¥éª¤å¦‚ä¸‹ï¼š æ³¨å†Œè´¦å·ã€‚ ç™»å½• ï¼Œè¿›å…¥ mypage ç•Œé¢ã€‚ å¼€å¯ webdav æœåŠ¡ï¼Œè®°ä½ç”¨æˆ·åå’Œå¯†ç ã€‚ è‡³æ­¤ï¼Œwebdav æœåŠ¡æ³¨å†ŒæˆåŠŸã€‚ ä½¿ç”¨ Remotely Save æ’ä»¶è¿›è¡ŒåŒæ­¥ å®‰è£…æ’ä»¶ã€‚ æœåŠ¡é€‰æ‹© webdavã€‚ å¡«å†™ä¸Šé¢çš„ç”¨æˆ·åå’Œå¯†ç ã€‚ æµ‹è¯•è¿æ¥ï¼Œä¹‹åè‡ªè¡Œè®¾ç½®åŒæ­¥æ–¹å¼å³å¯ã€‚","categories":["blog"]},{"title":"æ’ä»¶åˆ—è¡¨","path":"/pages/blog/extension.html","content":"Admonition Auto Link Title Advanced table Better word count Calendar Check list Collapse All Data view Editor syntax highlight Excalidraw File tree alternative Full screen plugin Image Toolkit Link Favicons Linter Mind map Minimal theme settings Natural Language Dates Note refactor obsidian Outliner Remember cursor position Remotely Save Templater Auto Link Title ç²˜è´´äº’è”ç½‘é“¾æ¥çš„æ—¶å€™è‡ªåŠ¨æ·»åŠ æ ‡é¢˜ã€‚ Link Favicons æ˜¾ç¤ºé“¾æ¥çš„ icon Image Toolkit é¢„è§ˆå›¾ç‰‡ Collapse All æŠ˜å æ‰€æœ‰æ–‡ä»¶å¤¹ Natural Language Dates è‡ªåŠ¨ç”Ÿæˆæ—¥æœŸ + @ Better word count è®¡ç®—å­—æ•° Excalidraw ç»˜ç”»æ¿ outliner åˆ—è¡¨è°ƒæ•´ mind map æ€ç»´å¯¼å›¾ refactor obsidian å°†è¿‡é•¿çš„ç¬”è®°åˆ†ä¸ºå¤šä¸ªç¬”è®° advanced table å¼ºåŒ–è¡¨æ ¼ syntax highlight ä»£ç é«˜äº® 123int main()&#123;\tcout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;&#125; admonition 12345678æ ‡æ³¨æ  æ·»åŠ  ad å‰ç¼€```ad-bugtitle: I&#x27;m Nested!~~~javascriptthrow new Error(&quot;Oops, I&#x27;m a bug.&quot;);~~~``` remotely save åŒæ­¥æ–‡æ¡£ linter æ ¼å¼åŒ–æ–‡æ¡£ data view æ–‡æ¡£ä¿¡æ¯èšåˆ file tree æ–‡ä»¶æ ‘ç®¡ç† full screen ç¦…æ¨¡å¼ templater æ¨¡æ¿æ’ä»¶ check list todo åˆ—è¡¨ ç›¸å…³é“¾æ¥ Obsidian-æ’ä»¶æ¨èï¼ˆ20220323æ›´æ–°-é™„å‹ç¼©åŒ…ï¼‰ - çŸ¥ä¹","categories":["blog"]},{"title":"linux-install","path":"/pages/linux/linux-install.html","content":"WSL 1wsl --list å¸è½½å¯¹åº”çš„ç³»ç»Ÿ 1wsl --unregister Ubuntu è®¾ç½®é»˜è®¤ç³»ç»Ÿ 1wslconfig /setdefault Name ä¿®æ”¹é»˜è®¤ç”¨æˆ·ï¼Œä¸»æœºåï¼Œä¿®æ”¹/etc/wsl.confæ–‡ä»¶ 12345[user]default=youruser[network]hostname=yourhostname Ubuntu æ¢æº å¤‡ä»½sources.listæ–‡ä»¶ 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak ç¼–è¾‘/etc/apt/sources.listæ–‡ä»¶ 1sudo vim /etc/apt/sources.list åœ¨æ–‡ä»¶å‰é¢æ·»åŠ ä¸‹é¢çš„æ¡ç›®(é˜¿é‡Œæº) 12345678910deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse æ›´æ–° 1sudo apt update oh-my-bash ç¾åŒ– å®‰è£… 1bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmybash/oh-my-bash/master/tools/install.sh)&quot; å®‰è£…è½¯ä»¶ å®‰è£…i3wm å®‰è£… 1sudo apt install i3 åŒæ­¥æœ€æ–°ä»“åº“ 12345sudo apt install ca-certificates/usr/lib/apt/apt-helper download-file https://debian.sur5r.net/i3/pool/main/s/sur5r-keyring/sur5r-keyring_2021.02.02_all.deb keyring.deb SHA256:cccfb1dd7d6b1b6a137bb96ea5b5eef18a0a4a6df1d6c0c37832025d2edaa710sudo dpkg -i ./keyring.debsudo sh -c &quot;echo &quot;deb http://debian.sur5r.net/i3/ $(grep &#x27;^DISTRIB_CODENAME=&#x27; /etc/lsb-release | cut -f2 -d=) universe&quot; &gt; /etc/apt/sources.list.d/sur5r-i3.list&quot;sudo apt update å®‰è£…tigervnc å®‰è£… 1sudo apt install tigervnc-standalone-server å¯åŠ¨ 1vncserver -SecurityTypes=None -localhost=no --I-KNOW-THIS-IS-INSECURE :1 -dpi 150 -geometry=1920x1080 æ˜¾ç¤ºå½“å‰ip 1ip addr | grep eth0 å®‰è£…fehã€xfce4-terminalã€rofiã€polybar 1sudo apt install feh xfce4-terminal rofi polybar å®‰è£…picom 12345678sudo apt install libxext-dev libxcb1-dev libxcb-damage0-dev libxcb-xfixes0-dev libxcb-shape0-dev libxcb-render-util0-dev libxcb-render0-dev libxcb-randr0-dev libxcb-composite0-dev libxcb-image0-dev libxcb-present-dev libxcb-xinerama0-dev libxcb-glx0-dev libpixman-1-dev libdbus-1-dev libconfig-dev libgl1-mesa-dev libpcre2-dev libpcre3-dev libevdev-dev uthash-dev libev-dev libx11-xcb-dev meson gcccdgit clone https://github.com/yshui/picom.git --depth=1cd picomgit submodule update --init --recursivemeson --buildtype=release . buildninja -C buildsudo ninja -C build install å®‰è£…google ä¸‹è½½å®‰è£…åŒ… 1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb å®‰è£… 1sudo apt install ./google-chrome-stable_current_amd64.deb åŠ è½½å­—ä½“ 12sudo mkfontscalesudo fc-cache -fv ARCH åˆ›å»ºç”¨æˆ· 12345678useradd -m -G wheel username# è¯·è‡ªè¡Œæ›¿æ¢ username ä¸ºä½ çš„ç”¨æˆ·åpasswd username# è¯·è‡ªè¡Œæ›¿æ¢ username ä¸ºä½ çš„ç”¨æˆ·åvim /etc/sudoers# å»æ‰# %wheel ALL=(ALL)ALL è®¾ç½®é»˜è®¤ç”¨æˆ· 1./Arch.exe config --default-user booiris æ¢æº 12345678910111213141516171819202122232425sudo pacman-key --initsudo pacman-key --populate archlinuxcp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backupsudo vim /etc/pacman.d/mirrorlist# æ¸…åå¤§å­¦Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch## 163Server = http://mirrors.163.com/archlinux/$repo/os/$arch## aliyunServer = http://mirrors.aliyun.com/archlinux/$repo/os/$archcp /etc/pacman.conf /etc/pacman.conf.backupsudo vim /etc/pacman.conf[archlinuxcn]# The Chinese Arch Linux communities packages.# SigLevel = Optional TrustedOnlySigLevel = Optional TrustAll# æ¸…åå¤§å­¦Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$archsudo pacman -Syyu YAY å®‰è£… 1sudo pacman -S yay æ¢æº 1yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save å®‰è£…è½¯ä»¶ 123yay -S base-develyay -S i3 tigervnc sublime-text-4 google-chrome xfce4-terminal tighervnc é…ç½® ç”¨ vncpasswd åˆ›å»ºå¯†ç ï¼Œå®ƒä¼šå°†å“ˆå¸Œå¤„ç†ä¹‹åçš„å¯†ç å­˜å‚¨åœ¨ ~/.vnc/passwdã€‚ ç¼–è¾‘ /etc/tigervnc/vncserver.users æ¥å®šä¹‰ç”¨æˆ·æ˜ å°„ åˆ›å»º ~/.vnc/configï¼Œå…¶ä¸­è‡³å°‘è¦æœ‰ä¸€è¡Œå®šä¹‰ä¼šè¯çš„ç±»å‹ï¼Œæ¯”å¦‚ session=foo ï¼ˆå°†fooæ›¿æ¢ä¸ºä½ æƒ³è¦è¿è¡Œçš„æ¡Œé¢ç¯å¢ƒï¼‰ã€‚ä½ å¯ä»¥é€šè¿‡æŸ¥çœ‹ /usr/share/xsessions/ é‡Œçš„ .desktop æ–‡ä»¶æ¥çŸ¥é“æœ‰å“ªäº›æ¡Œé¢ç¯å¢ƒåœ¨å½“å‰ç³»ç»Ÿä¸Šå¯ä»¥ä½¿ç”¨ã€‚ 1234session=i3geometry=1920x1080dpi=150alwaysshared è¯­è¨€ 12sudo vim /etc/locale.gensudo locale-gen å­—ä½“ 1yay -S noto-fonts-emoji adobe-source-han-serif-cn-fonts adobe-source-han-serif-tw-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-tw-fonts nerd-fonts-jetbrains-mono ttf-iosevka-nerd ttf-material-icons-git papirus-icon-theme æ¡Œé¢ 12yay -S polybar rofi feh picom xss-lock dbus-x11 google-chromeyay -S fcitx5-im fcitx5-chinese-addons åˆ›å»º.Xresources 1234567Xft.dpi: 120Xft.autohint: 0Xft.lcdfilter: lcddefaultXft.hintstyle: hintfullXft.hinting: 1Xft.antialias: 1Xft.rgba: rgb rofi 1234mkdir ~/.local/share/rofigit clone https://github.com/Murzchnvok/rofi-collection.git --depth=1cp -r nord $HOME/.local/share/rofi/themes/ åˆ›å»ºconfig.rasi 12//@theme &quot;/home/booiris/.local/share/rofi/themes/nord.rasi&quot;@theme &quot;/home/booiris/.local/share/rofi/themes/nord.rasi&quot;","categories":["linux"]},{"title":"chapter 1","path":"/pages/csapp/chapter 1.html","content":"#todo [ ] TODO: æ²¡å†™å®Œ 1.3 funny question Optimize Problems Is a switch statment always more efficient than a sequence of if-else statements? [ ] q1 answer: How much overhead is incurred by a function call? [ ] q2 answer: Is a while loop more efficient than a for loop? [ ] q3 answer: Are pointer references more efficient than array indexes? [ ] q4 answer: Why does out loop run so much faster if we sum into a local variable instead of an argument that is passed by reference? [ ] q5 answer: How can a function run faster when we simply rearrange the parenthes in an arithmetic expression? [ ] q6 answer: 1.4 1.4.1 I/O Devices Each I/O devices is connected to I/O bus by either a controller or an adapter. Controller is chip set in the devices or on the system's motherboard. Adapter is a card that plugs into a slot on the motherboard. #chapter1/IO","categories":["csapp"]},{"path":"/package.json","content":"{\"name\":\"hexo-site\",\"version\":\"0.0.0\",\"private\":true,\"hexo\":{\"version\":\"6.2.0\"},\"dependencies\":{\"hexo\":\"^6.2.0\",\"hexo-deployer-git\":\"^3.0.0\",\"hexo-generator-archive\":\"^1.0.0\",\"hexo-generator-category\":\"^1.0.0\",\"hexo-generator-index\":\"^2.0.0\",\"hexo-generator-tag\":\"^1.0.0\",\"hexo-renderer-ejs\":\"^2.0.0\",\"hexo-renderer-markdown-it-plus\":\"^1.0.4\",\"hexo-renderer-stylus\":\"^2.1.0\",\"hexo-server\":\"^3.0.0\"},\"devDependencies\":{\"@vercel/node\":\"^2.5.22\",\"web-vitals\":\"^3.0.3\"}}"},{"path":"/vercel.json","content":"{\"github\":{\"silent\":true},\"headers\":[{\"source\":\"/(.*)\",\"headers\":[{\"key\":\"Access-Control-Allow-Origin\",\"value\":\"*\"},{\"key\":\"Access-Control-Allow-Headers\",\"value\":\"content-type\"},{\"key\":\"Access-Control-Allow-Methods\",\"value\":\"DELETE,PUT,POST,GET,OPTIONS\"}]}]}"},{"path":"/api/analytics.js","content":"import { getCLS, getFCP, getFID, getLCP, getTTFB } from 'web-vitals'; const vitalsUrl = 'https://vitals.vercel-analytics.com/v1/vitals'; function getConnectionSpeed() { return 'connection' in navigator && navigator['connection'] && 'effectiveType' in navigator['connection'] ? navigator['connection']['effectiveType'] : ''; } function sendToAnalytics(metric, options) { const page = Object.entries(options.params).reduce( (acc, [key, value]) => acc.replace(value, `[${key}]`), options.path, ); const body = { dsn: options.analyticsId, // qPgJqYH9LQX5o31Ormk8iWhCxZO id: metric.id, // v2-1653884975443-1839479248192 page, // /blog/[slug] href: location.href, // https://my-app.vercel.app/blog/my-test event_name: metric.name, // TTFB value: metric.value.toString(), // 60.20000000298023 speed: getConnectionSpeed(), // 4g }; if (options.debug) { console.log('[Analytics]', metric.name, JSON.stringify(body, null, 2)); } const blob = new Blob([new URLSearchParams(body).toString()], { // This content type is necessary for `sendBeacon` type: 'application/x-www-form-urlencoded', }); if (navigator.sendBeacon) { navigator.sendBeacon(vitalsUrl, blob); } else fetch(vitalsUrl, { body: blob, method: 'POST', credentials: 'omit', keepalive: true, }); } export function webVitals(options) { try { getFID((metric) => sendToAnalytics(metric, options)); getTTFB((metric) => sendToAnalytics(metric, options)); getLCP((metric) => sendToAnalytics(metric, options)); getCLS((metric) => sendToAnalytics(metric, options)); getFCP((metric) => sendToAnalytics(metric, options)); } catch (err) { console.error('[Analytics]', err); } }"},{"path":"/api/hello.js","content":"export default function handler(request, response) { const { name } = request.query response.status(200).send(`Hello ${name}!`) }"},{"title":"game","path":"/game/index.html","content":"ä¸€äº›å°ç©æ„å„¿ï¼Œç‚¹å‡»æ ‡é¢˜æŸ¥çœ‹ Life-time The wasm-bindgen based Conway game. ä½¿ç”¨ rust wasm ç¼–å†™çš„åº·å¨æ¸¸æˆ github link: rust-learning/life-game at rust-game Â· booiris/rust-learning Â· GitHub Push-box å¼ºåŒ–å­¦ä¹ ç‰ˆæ¨ç®±å­ Reinforcement learning based Sokoban game. github link: rust-learning/push-box at rust-game Â· booiris/rust-learning Â· GitHub flappy-bird Attention! This game size is 10 MB. ä½¿ç”¨ bevy (ä¸€ç§æ•°æ®é©±åŠ¨æ¸¸æˆå¼•æ“ï¼Œè¿˜æŒºæœ‰æ„æ€çš„) ç¼–å†™çš„ flappy-bird Bevy based Flappy Bird game. github link: GitHub - booiris/rust-learning at snake snake åŸºäº fc æ¨¡æ‹Ÿå™¨è¿è¡Œçš„è´ªåƒè›‡æ¸¸æˆ github link: rust-nes/test-snake at master Â· booiris/rust-nes Â· GitHub"},{"title":"Picture","path":"/pic/index.html","content":"1 2 3"},{"path":"/js/memos.js","content":"utils.jq(() => { $(function () { const els = document.getElementsByClassName('ds-memos'); for (var i = 0; i < els.length; i++) { const el = els[i]; const api = el.getAttribute('api'); if (api == null) { continue; } const default_avatar = el.getAttribute('avatar') || def.avatar; const limit = el.getAttribute('limit'); const host = api.replace(/https:\\/\\/(.*?)\\/(.*)/i, '$1'); // layout utils.request(el, api, function (data) { data = data.memos var users = []; const filter = el.getAttribute('user'); if (filter && filter.length > 0) { users = filter.split(\",\"); } var hide = []; const hideStr = el.getAttribute('hide'); if (hideStr && hideStr.length > 0) { hide = hideStr.split(\",\"); } data.forEach((item, i) => { if (limit && i >= limit) { return; } if (item.user && item.user.login && users.length > 0) { if (!users.includes(item.user.login)) { return; } } let date = new Date(item.createTime) var cell = ''; cell += ''; if (!users.length && !hide.includes('user')) { cell += ''; if (default_avatar.length > 0) { cell += ``; } cell += '' + booiris + ''; cell += ''; } cell += '' + date.toLocaleString() + ''; cell += ''; cell += ''; cell += marked.parse(item.content || ''); var imgs = []; for (let res of item.resources) { if (res.type?.includes('image/')) { imgs.push(res); } } if (imgs.length > 0) { cell += ''; for (let img of imgs) { if (img.externalLink?.length > 0) { cell += ``; } else { cell += ``; } } cell += ''; } cell += ''; cell += ''; $(el).append(cell); }); }); } }); });"},{"path":"/src/auto-render.min.js","content":"!function (e, t) { \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"katex\")) : \"function\" == typeof define && define.amd ? define([\"katex\"], t) : \"object\" == typeof exports ? exports.renderMathInElement = t(require(\"katex\")) : e.renderMathInElement = t(e.katex) }(\"undefined\" != typeof self ? self : this, function (e) { return function (e) { var t = {}; function r(n) { if (t[n]) return t[n].exports; var o = t[n] = { i: n, l: !1, exports: {} }; return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports } return r.m = e, r.c = t, r.d = function (e, t, n) { r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n }) }, r.r = function (e) { \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 }) }, r.t = function (e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && \"object\" == typeof e && e && e.__esModule) return e; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, \"default\", { enumerable: !0, value: e }), 2 & t && \"string\" != typeof e) for (var o in e) r.d(n, o, function (t) { return e[t] }.bind(null, o)); return n }, r.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return r.d(t, \"a\", t), t }, r.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, r.p = \"\", r(r.s = 1) }([function (t, r) { t.exports = e }, function (e, t, r) { \"use strict\"; r.r(t); var n = r(0), o = r.n(n), a = function (e, t, r) { for (var n = r, o = 0, a = e.length; n < t.length;) { var i = t[n]; if (o"},{"path":"/game/flappy-bird/index.html","content":"import init from './flappy-bird.js' init()"},{"path":"/game/flappy-bird/flappy-bird.js","content":"const lAudioContext = (typeof AudioContext !== 'undefined' ? AudioContext : (typeof webkitAudioContext !== 'undefined' ? webkitAudioContext : undefined)); let wasm; const heap = new Array(32).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 36) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); let cachedUint8Memory0 = new Uint8Array(); function getUint8Memory0() { if (cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } function isLikeNone(x) { return x === undefined || x === null; } let cachedFloat64Memory0 = new Float64Array(); function getFloat64Memory0() { if (cachedFloat64Memory0.byteLength === 0) { cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer); } return cachedFloat64Memory0; } let cachedInt32Memory0 = new Int32Array(); function getInt32Memory0() { if (cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } let WASM_VECTOR_LEN = 0; const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } function debugString(val) { // primitive types const type = typeof val; if (type == 'number' || type == 'boolean' || val == null) { return `${val}`; } if (type == 'string') { return `\"${val}\"`; } if (type == 'symbol') { const description = val.description; if (description == null) { return 'Symbol'; } else { return `Symbol(${description})`; } } if (type == 'function') { const name = val.name; if (typeof name == 'string' && name.length > 0) { return `Function(${name})`; } else { return 'Function'; } } // objects if (Array.isArray(val)) { const length = val.length; let debug = '['; if (length > 0) { debug += debugString(val[0]); } for(let i = 1; i < length; i++) { debug += ', ' + debugString(val[i]); } debug += ']'; return debug; } // Test for built-in const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val)); let className; if (builtInMatches.length > 1) { className = builtInMatches[1]; } else { // Failed to match the standard '[object ClassName]' return toString.call(val); } if (className == 'Object') { // we're a user defined class or Object // JSON.stringify avoids problems with cycles, and is generally much // easier than looping through ownProperties of `val`. try { return 'Object(' + JSON.stringify(val) + ')'; } catch (_) { return 'Object'; } } // errors if (val instanceof Error) { return `${val.name}: ${val.message} ${val.stack}`; } // TODO we could test for more things here, like `Set`s and `Map`s. return className; } function makeMutClosure(arg0, arg1, dtor, f) { const state = { a: arg0, b: arg1, cnt: 1, dtor }; const real = (...args) => { // First up with a closure we increment the internal reference // count. This ensures that the Rust closure environment won't // be deallocated while we're invoking it. state.cnt++; const a = state.a; state.a = 0; try { return f(a, state.b, ...args); } finally { if (--state.cnt === 0) { wasm.__wbindgen_export_2.get(state.dtor)(a, state.b); } else { state.a = a; } } }; real.original = state; return real; } function __wbg_adapter_34(arg0, arg1) { wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h27253a35839af148(arg0, arg1); } function __wbg_adapter_37(arg0, arg1, arg2) { wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h1c8b3d7dcee3199d(arg0, arg1, addHeapObject(arg2)); } function handleError(f, args) { try { return f.apply(this, args); } catch (e) { wasm.__wbindgen_exn_store(addHeapObject(e)); } } function getArrayU8FromWasm0(ptr, len) { return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len); } let cachedFloat32Memory0 = new Float32Array(); function getFloat32Memory0() { if (cachedFloat32Memory0.byteLength === 0) { cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer); } return cachedFloat32Memory0; } function getArrayF32FromWasm0(ptr, len) { return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len); } function getArrayI32FromWasm0(ptr, len) { return getInt32Memory0().subarray(ptr / 4, ptr / 4 + len); } let cachedUint32Memory0 = new Uint32Array(); function getUint32Memory0() { if (cachedUint32Memory0.byteLength === 0) { cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer); } return cachedUint32Memory0; } function getArrayU32FromWasm0(ptr, len) { return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len); } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbg_fetch_c5d08af59be0ee7d = function(arg0, arg1, arg2) { const ret = getObject(arg0).fetch(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_instanceof_Response_eaa426220848a39e = function(arg0) { let result; try { result = getObject(arg0) instanceof Response; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_arrayBuffer_4c27b6f00c530232 = function() { return handleError(function (arg0) { const ret = getObject(arg0).arrayBuffer(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) { const ret = new Uint8Array(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbg_connected_41b85c162970593b = function(arg0) { const ret = getObject(arg0).connected; return ret; }; imports.wbg.__wbg_isSecureContext_541f52c311a1c679 = function(arg0) { const ret = getObject(arg0).isSecureContext; return ret; }; imports.wbg.__wbg_mark_40e050a77cc39fea = function(arg0, arg1) { performance.mark(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbg_log_c9486ca5d8e2cbe8 = function(arg0, arg1) { try { console.log(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_log_aba5996d9bde071f = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { try { console.log(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), getStringFromWasm0(arg6, arg7)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_fenceSync_91d72c970c880844 = function(arg0, arg1, arg2) { const ret = getObject(arg0).fenceSync(arg1 >>> 0, arg2 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createVertexArrayOES_00a5c523e5b17eff = function(arg0) { const ret = getObject(arg0).createVertexArrayOES(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createVertexArray_8467a75e68fec199 = function(arg0) { const ret = getObject(arg0).createVertexArray(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_bindVertexArrayOES_84540c072ea96b75 = function(arg0, arg1) { getObject(arg0).bindVertexArrayOES(getObject(arg1)); }; imports.wbg.__wbg_bindVertexArray_9d12800e272184b0 = function(arg0, arg1) { getObject(arg0).bindVertexArray(getObject(arg1)); }; imports.wbg.__wbg_bufferData_a33528a74dd300f4 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, getObject(arg2), arg3 >>> 0); }; imports.wbg.__wbg_bufferData_8d206d7adf6751c0 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, getObject(arg2), arg3 >>> 0); }; imports.wbg.__wbg_createSampler_288fd761eabe283d = function(arg0) { const ret = getObject(arg0).createSampler(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_new_0b9bfdd97583284e = function() { const ret = new Object(); return addHeapObject(ret); }; imports.wbg.__wbindgen_string_new = function(arg0, arg1) { const ret = getStringFromWasm0(arg0, arg1); return addHeapObject(ret); }; imports.wbg.__wbg_getContext_a6ea7a8e317f182a = function() { return handleError(function (arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getContext(getStringFromWasm0(arg1, arg2), getObject(arg3)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_instanceof_WebGl2RenderingContext_fcfa91cd777063f3 = function(arg0) { let result; try { result = getObject(arg0) instanceof WebGL2RenderingContext; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbindgen_object_clone_ref = function(arg0) { const ret = getObject(arg0); return addHeapObject(ret); }; imports.wbg.__wbg_exitPointerLock_1405aae165b47bfd = function(arg0) { getObject(arg0).exitPointerLock(); }; imports.wbg.__wbg_requestPointerLock_3bc7c389fbad1a71 = function(arg0) { getObject(arg0).requestPointerLock(); }; imports.wbg.__wbg_exitFullscreen_1510ded2ca20d624 = function(arg0) { getObject(arg0).exitFullscreen(); }; imports.wbg.__wbg_width_2f4b0cbbf1c850d9 = function(arg0) { const ret = getObject(arg0).width; return ret; }; imports.wbg.__wbg_height_a81d308a000d91d0 = function(arg0) { const ret = getObject(arg0).height; return ret; }; imports.wbg.__wbg_requestAnimationFrame_4181656476a7d86c = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).requestAnimationFrame(getObject(arg1)); return ret; }, arguments) }; imports.wbg.__wbg_error_02ffd4185a83fe18 = function(arg0, arg1) { console.error(getObject(arg0), getObject(arg1)); }; imports.wbg.__wbindgen_cb_drop = function(arg0) { const obj = takeObject(arg0).original; if (obj.cnt-- == 1) { obj.a = 0; return true; } const ret = false; return ret; }; imports.wbg.__wbg_clearTimeout_7d6f7bfeed34b348 = function(arg0, arg1) { getObject(arg0).clearTimeout(arg1); }; imports.wbg.__wbg_cancelAnimationFrame_679ac3913d7f9b34 = function() { return handleError(function (arg0, arg1) { getObject(arg0).cancelAnimationFrame(arg1); }, arguments) }; imports.wbg.__wbg_stopPropagation_eca3af16f2d02a91 = function(arg0) { getObject(arg0).stopPropagation(); }; imports.wbg.__wbg_cancelBubble_8c0bdf21c08f1717 = function(arg0) { const ret = getObject(arg0).cancelBubble; return ret; }; imports.wbg.__wbg_innerWidth_ffa584f74d721fce = function() { return handleError(function (arg0) { const ret = getObject(arg0).innerWidth; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_innerHeight_f4804c803fcf02b0 = function() { return handleError(function (arg0) { const ret = getObject(arg0).innerHeight; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_preventDefault_3209279b490de583 = function(arg0) { getObject(arg0).preventDefault(); }; imports.wbg.__wbg_deltaX_6b627fd6f4c19e51 = function(arg0) { const ret = getObject(arg0).deltaX; return ret; }; imports.wbg.__wbg_deltaY_a5393ec7ac0f7bb4 = function(arg0) { const ret = getObject(arg0).deltaY; return ret; }; imports.wbg.__wbg_deltaMode_a90be314f5c676f1 = function(arg0) { const ret = getObject(arg0).deltaMode; return ret; }; imports.wbg.__wbg_addEventListener_1fc744729ac6dc27 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) { getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3), getObject(arg4)); }, arguments) }; imports.wbg.__wbg_buttons_047716c1296e3d1c = function(arg0) { const ret = getObject(arg0).buttons; return ret; }; imports.wbg.__wbg_pointerId_18be034781db46f3 = function(arg0) { const ret = getObject(arg0).pointerId; return ret; }; imports.wbg.__wbg_setPointerCapture_7cc6c6e831d5dae0 = function() { return handleError(function (arg0, arg1) { getObject(arg0).setPointerCapture(arg1); }, arguments) }; imports.wbg.__wbg_getBoundingClientRect_06acb6ac1c23e409 = function(arg0) { const ret = getObject(arg0).getBoundingClientRect(); return addHeapObject(ret); }; imports.wbg.__wbg_clientX_e39206f946859108 = function(arg0) { const ret = getObject(arg0).clientX; return ret; }; imports.wbg.__wbg_x_419967b8271dcf59 = function(arg0) { const ret = getObject(arg0).x; return ret; }; imports.wbg.__wbg_clientY_e376bb2d8f470c88 = function(arg0) { const ret = getObject(arg0).clientY; return ret; }; imports.wbg.__wbg_y_0f67486e0f88b265 = function(arg0) { const ret = getObject(arg0).y; return ret; }; imports.wbg.__wbg_getModifierState_135305ae40997dc7 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getModifierState(getStringFromWasm0(arg1, arg2)); return ret; }; imports.wbg.__wbg_createElement_976dbb84fe1661b5 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_get_55f248d76a5aa3d1 = function(arg0, arg1, arg2) { const ret = getObject(arg0)[getStringFromWasm0(arg1, arg2)]; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_body_3cb4b4042b9a632b = function(arg0) { const ret = getObject(arg0).body; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_appendChild_e513ef0e5098dfdd = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).appendChild(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_parentElement_0cffb3ceb0f107bd = function(arg0) { const ret = getObject(arg0).parentElement; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_width_3ca95ccb4ba994e2 = function(arg0) { const ret = getObject(arg0).width; return ret; }; imports.wbg.__wbg_height_52d1d8c8ada7c55d = function(arg0) { const ret = getObject(arg0).height; return ret; }; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_eval_6dc8993472839847 = function() { return handleError(function (arg0, arg1) { const ret = eval(getStringFromWasm0(arg0, arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_boolean_get = function(arg0) { const v = getObject(arg0); const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2; return ret; }; imports.wbg.__wbg_close_7d5aa2babb9d8fc2 = function() { return handleError(function (arg0) { const ret = getObject(arg0).close(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_is_object = function(arg0) { const val = getObject(arg0); const ret = typeof(val) === 'object' && val !== null; return ret; }; imports.wbg.__wbg_randomFillSync_6894564c2c334c42 = function() { return handleError(function (arg0, arg1, arg2) { getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2)); }, arguments) }; imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) { const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_getRandomValues_805f1c3d65988a5a = function() { return handleError(function (arg0, arg1) { getObject(arg0).getRandomValues(getObject(arg1)); }, arguments) }; imports.wbg.__wbg_crypto_e1d53a1d73fb10b8 = function(arg0) { const ret = getObject(arg0).crypto; return addHeapObject(ret); }; imports.wbg.__wbg_process_038c26bf42b093f8 = function(arg0) { const ret = getObject(arg0).process; return addHeapObject(ret); }; imports.wbg.__wbg_versions_ab37218d2f0b24a8 = function(arg0) { const ret = getObject(arg0).versions; return addHeapObject(ret); }; imports.wbg.__wbg_node_080f4b19d15bc1fe = function(arg0) { const ret = getObject(arg0).node; return addHeapObject(ret); }; imports.wbg.__wbindgen_is_string = function(arg0) { const ret = typeof(getObject(arg0)) === 'string'; return ret; }; imports.wbg.__wbg_require_78a3dcfbdba9cbce = function() { return handleError(function () { const ret = module.require; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_is_function = function(arg0) { const ret = typeof(getObject(arg0)) === 'function'; return ret; }; imports.wbg.__wbg_call_168da88779e35f61 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).call(getObject(arg1), getObject(arg2)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_msCrypto_6e7d3e1f92610cbb = function(arg0) { const ret = getObject(arg0).msCrypto; return addHeapObject(ret); }; imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) { const ret = new Uint8Array(arg0 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_navigator_d1dcf282b97e2495 = function(arg0) { const ret = getObject(arg0).navigator; return addHeapObject(ret); }; imports.wbg.__wbg_getGamepads_8001a499f2b689fe = function() { return handleError(function (arg0) { const ret = getObject(arg0).getGamepads(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbg_instanceof_DomException_c2b4ae110dc047f8 = function(arg0) { let result; try { result = getObject(arg0) instanceof DOMException; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_message_a7af3ee0cc0fe28d = function(arg0, arg1) { const ret = getObject(arg1).message; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbindgen_number_get = function(arg0, arg1) { const obj = getObject(arg1); const ret = typeof(obj) === 'number' ? obj : undefined; getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret; getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret); }; imports.wbg.__wbindgen_is_null = function(arg0) { const ret = getObject(arg0) === null; return ret; }; imports.wbg.__wbg_id_55b63ccda43785eb = function(arg0, arg1) { const ret = getObject(arg1).id; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_buttons_1162e62c0dc4246e = function(arg0) { const ret = getObject(arg0).buttons; return addHeapObject(ret); }; imports.wbg.__wbg_axes_385390941534cfd7 = function(arg0) { const ret = getObject(arg0).axes; return addHeapObject(ret); }; imports.wbg.__wbg_mapping_778a451256a4d95e = function(arg0) { const ret = getObject(arg0).mapping; return addHeapObject(ret); }; imports.wbg.__wbindgen_string_get = function(arg0, arg1) { const obj = getObject(arg1); const ret = typeof(obj) === 'string' ? obj : undefined; var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_now_58886682b7e790d7 = function() { const ret = Date.now(); return ret; }; imports.wbg.__wbindgen_number_new = function(arg0) { const ret = arg0; return addHeapObject(ret); }; imports.wbg.__wbg_createFramebuffer_9b5b0507480146cd = function(arg0) { const ret = getObject(arg0).createFramebuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createFramebuffer_d5f3985ce3652661 = function(arg0) { const ret = getObject(arg0).createFramebuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createShader_4017d9fbc36659af = function(arg0, arg1) { const ret = getObject(arg0).createShader(arg1 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createShader_46a66dce5a9e22d0 = function(arg0, arg1) { const ret = getObject(arg0).createShader(arg1 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createTexture_4ce49e8a8c655124 = function(arg0) { const ret = getObject(arg0).createTexture(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createTexture_269f67d411bdc4dc = function(arg0) { const ret = getObject(arg0).createTexture(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_deleteShader_246e6e678f3eb957 = function(arg0, arg1) { getObject(arg0).deleteShader(getObject(arg1)); }; imports.wbg.__wbg_deleteShader_89369612f61ec145 = function(arg0, arg1) { getObject(arg0).deleteShader(getObject(arg1)); }; imports.wbg.__wbg_shaderSource_a0001b8eab5d44f4 = function(arg0, arg1, arg2, arg3) { getObject(arg0).shaderSource(getObject(arg1), getStringFromWasm0(arg2, arg3)); }; imports.wbg.__wbg_shaderSource_5111981e7afb61fb = function(arg0, arg1, arg2, arg3) { getObject(arg0).shaderSource(getObject(arg1), getStringFromWasm0(arg2, arg3)); }; imports.wbg.__wbg_compileShader_22b038faa1f49857 = function(arg0, arg1) { getObject(arg0).compileShader(getObject(arg1)); }; imports.wbg.__wbg_compileShader_822f38928f6f2a08 = function(arg0, arg1) { getObject(arg0).compileShader(getObject(arg1)); }; imports.wbg.__wbg_createProgram_1c5f8dffd1066e71 = function(arg0) { const ret = getObject(arg0).createProgram(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createProgram_dc6b23d3caa1d86e = function(arg0) { const ret = getObject(arg0).createProgram(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_deleteProgram_ce56000628d7f1ce = function(arg0, arg1) { getObject(arg0).deleteProgram(getObject(arg1)); }; imports.wbg.__wbg_deleteProgram_e8636e3cb5a18a59 = function(arg0, arg1) { getObject(arg0).deleteProgram(getObject(arg1)); }; imports.wbg.__wbg_attachShader_f4d51147351a1906 = function(arg0, arg1, arg2) { getObject(arg0).attachShader(getObject(arg1), getObject(arg2)); }; imports.wbg.__wbg_attachShader_90ad543fb1bccb18 = function(arg0, arg1, arg2) { getObject(arg0).attachShader(getObject(arg1), getObject(arg2)); }; imports.wbg.__wbg_linkProgram_25cda5f9318ea316 = function(arg0, arg1) { getObject(arg0).linkProgram(getObject(arg1)); }; imports.wbg.__wbg_linkProgram_c33885d9ea798810 = function(arg0, arg1) { getObject(arg0).linkProgram(getObject(arg1)); }; imports.wbg.__wbg_getProgramInfoLog_e47d5073d57fb18d = function(arg0, arg1, arg2) { const ret = getObject(arg1).getProgramInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getProgramInfoLog_1e37a3d1d090ec1c = function(arg0, arg1, arg2) { const ret = getObject(arg1).getProgramInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getActiveUniform_fd021da851153e8c = function(arg0, arg1, arg2) { const ret = getObject(arg0).getActiveUniform(getObject(arg1), arg2 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_size_878ba1bf0c2ec606 = function(arg0) { const ret = getObject(arg0).size; return ret; }; imports.wbg.__wbg_type_ca7819eaadc2049f = function(arg0) { const ret = getObject(arg0).type; return ret; }; imports.wbg.__wbg_getActiveUniform_97472b76b9daa461 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getActiveUniform(getObject(arg1), arg2 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_useProgram_156511a425feb519 = function(arg0, arg1) { getObject(arg0).useProgram(getObject(arg1)); }; imports.wbg.__wbg_useProgram_35a58ac1e0d9577b = function(arg0, arg1) { getObject(arg0).useProgram(getObject(arg1)); }; imports.wbg.__wbg_createBuffer_6e747d928c9ba46d = function(arg0) { const ret = getObject(arg0).createBuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createBuffer_a6cffb7f7d5b92a3 = function(arg0) { const ret = getObject(arg0).createBuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_bindBuffer_8b5135aa633680f5 = function(arg0, arg1, arg2) { getObject(arg0).bindBuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindBuffer_66e359418f5c82d7 = function(arg0, arg1, arg2) { getObject(arg0).bindBuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindFramebuffer_080d0b0cf22e1645 = function(arg0, arg1, arg2) { getObject(arg0).bindFramebuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindFramebuffer_5c01742edd5d843a = function(arg0, arg1, arg2) { getObject(arg0).bindFramebuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindRenderbuffer_6da549f066c1b8a5 = function(arg0, arg1, arg2) { getObject(arg0).bindRenderbuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindRenderbuffer_f66dee160b94e5ef = function(arg0, arg1, arg2) { getObject(arg0).bindRenderbuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_pixelStorei_bee1e2da4cb1115b = function(arg0, arg1, arg2) { getObject(arg0).pixelStorei(arg1 >>> 0, arg2); }; imports.wbg.__wbg_pixelStorei_51c83dc5117bea35 = function(arg0, arg1, arg2) { getObject(arg0).pixelStorei(arg1 >>> 0, arg2); }; imports.wbg.__wbg_bufferSubData_a116fea11850b38f = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferSubData(arg1 >>> 0, arg2, getObject(arg3)); }; imports.wbg.__wbg_bufferSubData_0e04c6c7fec3c949 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferSubData(arg1 >>> 0, arg2, getObject(arg3)); }; imports.wbg.__wbg_clearBufferiv_8bb0c2b97eedc22b = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferiv(arg1 >>> 0, arg2, getArrayI32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_clearBufferfv_5cc4edeacbcf72e8 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferfv(arg1 >>> 0, arg2, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_copyBufferSubData_11187dccce72b79b = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).copyBufferSubData(arg1 >>> 0, arg2 >>> 0, arg3, arg4, arg5); }; imports.wbg.__wbg_copyTexSubImage2D_e815f93a9ef52dd2 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).copyTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8); }; imports.wbg.__wbg_copyTexSubImage2D_4c72e3ef713b65e6 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).copyTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8); }; imports.wbg.__wbg_deleteBuffer_12fd7d93834069ef = function(arg0, arg1) { getObject(arg0).deleteBuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteBuffer_6fd9bca7f8a6d9de = function(arg0, arg1) { getObject(arg0).deleteBuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteFramebuffer_d7551444a28f508e = function(arg0, arg1) { getObject(arg0).deleteFramebuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteFramebuffer_2617e39d2c39b4da = function(arg0, arg1) { getObject(arg0).deleteFramebuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteSync_48aed3df05f4f497 = function(arg0, arg1) { getObject(arg0).deleteSync(getObject(arg1)); }; imports.wbg.__wbg_deleteTexture_68a539339fd87792 = function(arg0, arg1) { getObject(arg0).deleteTexture(getObject(arg1)); }; imports.wbg.__wbg_deleteTexture_5c40169772519141 = function(arg0, arg1) { getObject(arg0).deleteTexture(getObject(arg1)); }; imports.wbg.__wbg_disable_6835d16c2cd3fa26 = function(arg0, arg1) { getObject(arg0).disable(arg1 >>> 0); }; imports.wbg.__wbg_disable_1659dc1efb5fb934 = function(arg0, arg1) { getObject(arg0).disable(arg1 >>> 0); }; imports.wbg.__wbg_drawArrays_c0dcb4151e0bf007 = function(arg0, arg1, arg2, arg3) { getObject(arg0).drawArrays(arg1 >>> 0, arg2, arg3); }; imports.wbg.__wbg_drawArrays_d587302f7a868d91 = function(arg0, arg1, arg2, arg3) { getObject(arg0).drawArrays(arg1 >>> 0, arg2, arg3); }; imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() { const ret = new Array(); return addHeapObject(ret); }; imports.wbg.__wbg_drawBuffers_23c1572f12f90db2 = function(arg0, arg1) { getObject(arg0).drawBuffers(getObject(arg1)); }; imports.wbg.__wbg_push_740e4b286702d964 = function(arg0, arg1) { const ret = getObject(arg0).push(getObject(arg1)); return ret; }; imports.wbg.__wbg_of_d79bf3cec607f7a4 = function(arg0) { const ret = Array.of(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_drawBuffersWEBGL_482a093ae5a4ad55 = function(arg0, arg1) { getObject(arg0).drawBuffersWEBGL(getObject(arg1)); }; imports.wbg.__wbg_enable_fc393941ac400f72 = function(arg0, arg1) { getObject(arg0).enable(arg1 >>> 0); }; imports.wbg.__wbg_enable_4791414dce6f602a = function(arg0, arg1) { getObject(arg0).enable(arg1 >>> 0); }; imports.wbg.__wbg_framebufferTexture2D_499d1c21458d0113 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).framebufferTexture2D(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4), arg5); }; imports.wbg.__wbg_framebufferTexture2D_4b810902dffa1ef3 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).framebufferTexture2D(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4), arg5); }; imports.wbg.__wbg_framebufferTextureLayer_d5e78fc74b8261e3 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).framebufferTextureLayer(arg1 >>> 0, arg2 >>> 0, getObject(arg3), arg4, arg5); }; imports.wbg.__wbg_getIndexedParameter_d4a2b68e14a022a1 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).getIndexedParameter(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getUniformLocation_8e9cc276a231ddcd = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getUniformLocation(getObject(arg1), getStringFromWasm0(arg2, arg3)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_getUniformLocation_0da0c93f626244a2 = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getUniformLocation(getObject(arg1), getStringFromWasm0(arg2, arg3)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_samplerParameterf_6eda655d7213cb18 = function(arg0, arg1, arg2, arg3) { getObject(arg0).samplerParameterf(getObject(arg1), arg2 >>> 0, arg3); }; imports.wbg.__wbg_samplerParameteri_390f1debfe40f83b = function(arg0, arg1, arg2, arg3) { getObject(arg0).samplerParameteri(getObject(arg1), arg2 >>> 0, arg3); }; imports.wbg.__wbindgen_memory = function() { const ret = wasm.memory; return addHeapObject(ret); }; imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) { const ret = getObject(arg0).buffer; return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_890b478c8d7226ff = function(arg0, arg1, arg2) { const ret = new Int8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_698c5100ae9c3365 = function(arg0, arg1, arg2) { const ret = new Int16Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_5540e144e9b8b907 = function(arg0, arg1, arg2) { const ret = new Uint16Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_7be13f49af2b2012 = function(arg0, arg1, arg2) { const ret = new Int32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_9cc9adccd861aa26 = function(arg0, arg1, arg2) { const ret = new Uint32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4 = function(arg0, arg1, arg2) { const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_texStorage2D_d25a76ad1b1ea98f = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).texStorage2D(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_uniform1i_50124a48de1da66b = function(arg0, arg1, arg2) { getObject(arg0).uniform1i(getObject(arg1), arg2); }; imports.wbg.__wbg_uniform1i_49986febd844f2c4 = function(arg0, arg1, arg2) { getObject(arg0).uniform1i(getObject(arg1), arg2); }; imports.wbg.__wbg_colorMask_bc13c97d0db65962 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).colorMask(arg1 !== 0, arg2 !== 0, arg3 !== 0, arg4 !== 0); }; imports.wbg.__wbg_colorMask_12687df5490e9bc9 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).colorMask(arg1 !== 0, arg2 !== 0, arg3 !== 0, arg4 !== 0); }; imports.wbg.__wbg_depthMask_88ab181c23c32dcd = function(arg0, arg1) { getObject(arg0).depthMask(arg1 !== 0); }; imports.wbg.__wbg_depthMask_55f538b7411e5023 = function(arg0, arg1) { getObject(arg0).depthMask(arg1 !== 0); }; imports.wbg.__wbg_bindTexture_6f1dec563e82e818 = function(arg0, arg1, arg2) { getObject(arg0).bindTexture(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindTexture_ae9620ea4a6ffb97 = function(arg0, arg1, arg2) { getObject(arg0).bindTexture(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindSampler_4b0e0e598e2cae44 = function(arg0, arg1, arg2) { getObject(arg0).bindSampler(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_activeTexture_02b7c73c76c2c06b = function(arg0, arg1) { getObject(arg0).activeTexture(arg1 >>> 0); }; imports.wbg.__wbg_activeTexture_6a9afd67cc0ade73 = function(arg0, arg1) { getObject(arg0).activeTexture(arg1 >>> 0); }; imports.wbg.__wbg_texParameteri_1b210b807f1ea723 = function(arg0, arg1, arg2, arg3) { getObject(arg0).texParameteri(arg1 >>> 0, arg2 >>> 0, arg3); }; imports.wbg.__wbg_texParameteri_21fd6b6b394882c9 = function(arg0, arg1, arg2, arg3) { getObject(arg0).texParameteri(arg1 >>> 0, arg2 >>> 0, arg3); }; imports.wbg.__wbg_texSubImage2D_f06e46b3b25ee691 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).texSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8 >>> 0, arg9); }, arguments) }; imports.wbg.__wbg_texSubImage2D_421e29fed0db07ab = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).texSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8 >>> 0, getObject(arg9)); }, arguments) }; imports.wbg.__wbg_texSubImage2D_cb339dd200dd1179 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).texSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8 >>> 0, getObject(arg9)); }, arguments) }; imports.wbg.__wbg_compressedTexSubImage2D_5b2a7dc8dc7b3e73 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).compressedTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8, arg9); }; imports.wbg.__wbg_compressedTexSubImage2D_fd1cef4f6a5da5c3 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).compressedTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, getObject(arg8)); }; imports.wbg.__wbg_compressedTexSubImage2D_30943b654d04ee44 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).compressedTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, getObject(arg8)); }; imports.wbg.__wbg_texSubImage3D_ebb9e6f80d19a411 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) { getObject(arg0).texSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10 >>> 0, arg11); }, arguments) }; imports.wbg.__wbg_texSubImage3D_591b8511a3c7593a = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) { getObject(arg0).texSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10 >>> 0, getObject(arg11)); }, arguments) }; imports.wbg.__wbg_vertexAttribPointer_63d2aef49627302b = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) { getObject(arg0).vertexAttribPointer(arg1 >>> 0, arg2, arg3 >>> 0, arg4 !== 0, arg5, arg6); }; imports.wbg.__wbg_vertexAttribPointer_3b06d737566f0745 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) { getObject(arg0).vertexAttribPointer(arg1 >>> 0, arg2, arg3 >>> 0, arg4 !== 0, arg5, arg6); }; imports.wbg.__wbg_getUniformBlockIndex_a6f3a994dcc7399d = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getUniformBlockIndex(getObject(arg1), getStringFromWasm0(arg2, arg3)); return ret; }; imports.wbg.__wbg_uniformBlockBinding_50ced0c985f91a02 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniformBlockBinding(getObject(arg1), arg2 >>> 0, arg3 >>> 0); }; imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) { const ret = Reflect.get(getObject(arg0), getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_now_8172cd917e5eda6b = function(arg0) { const ret = getObject(arg0).now(); return ret; }; imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) { const ret = getObject(arg0)[arg1 >>> 0]; return addHeapObject(ret); }; imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () { const ret = window.window; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () { const ret = globalThis.globalThis; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () { const ret = global.global; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_is_undefined = function(arg0) { const ret = getObject(arg0) === undefined; return ret; }; imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) { const ret = new Function(getStringFromWasm0(arg0, arg1)); return addHeapObject(ret); }; imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).call(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_is_40a66842732708e7 = function(arg0, arg1) { const ret = Object.is(getObject(arg0), getObject(arg1)); return ret; }; imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) { const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2)); return ret; }, arguments) }; imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) { const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) { getObject(arg0).set(getObject(arg1), arg2 >>> 0); }; imports.wbg.__wbg_newwithcontextoptions_0d1099da75124451 = function() { return handleError(function (arg0) { const ret = new lAudioContext(getObject(arg0)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_createBuffer_47ef089f86b99318 = function() { return handleError(function (arg0, arg1, arg2, arg3) { const ret = getObject(arg0).createBuffer(arg1 >>> 0, arg2 >>> 0, arg3); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_resume_244684c4c6bb49fa = function() { return handleError(function (arg0) { const ret = getObject(arg0).resume(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_measure_aa7a73f17813f708 = function() { return handleError(function (arg0, arg1, arg2, arg3) { try { performance.measure(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3)); } finally { wasm.__wbindgen_free(arg0, arg1); wasm.__wbindgen_free(arg2, arg3); } }, arguments) }; imports.wbg.__wbindgen_debug_string = function(arg0, arg1) { const ret = debugString(getObject(arg1)); const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) { const ret = getObject(arg0).then(getObject(arg1)); return addHeapObject(ret); }; imports.wbg.__wbg_then_cedad20fbbd9418a = function(arg0, arg1, arg2) { const ret = getObject(arg0).then(getObject(arg1), getObject(arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) { const ret = Promise.resolve(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_instanceof_Window_acc97ff9f5d2c7b4 = function(arg0) { let result; try { result = getObject(arg0) instanceof Window; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_copyToChannel_e683ef3e184292ab = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).copyToChannel(getArrayF32FromWasm0(arg1, arg2), arg3); }, arguments) }; imports.wbg.__wbg_setbuffer_ead89b52e0bf1c40 = function(arg0, arg1) { getObject(arg0).buffer = getObject(arg1); }; imports.wbg.__wbg_setonended_ae460558754eae1e = function(arg0, arg1) { getObject(arg0).onended = getObject(arg1); }; imports.wbg.__wbg_start_e330425e284a693a = function() { return handleError(function (arg0, arg1) { getObject(arg0).start(arg1); }, arguments) }; imports.wbg.__wbg_destination_df4e9893e562390a = function(arg0) { const ret = getObject(arg0).destination; return addHeapObject(ret); }; imports.wbg.__wbg_currentTime_80316e838e7d1028 = function(arg0) { const ret = getObject(arg0).currentTime; return ret; }; imports.wbg.__wbg_createBufferSource_f06449934aee7f6f = function() { return handleError(function (arg0) { const ret = getObject(arg0).createBufferSource(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_connect_463d4300ff833991 = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).connect(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_querySelector_3628dc2c3319e7e0 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).querySelector(getStringFromWasm0(arg1, arg2)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_requestFullscreen_7d41309612540445 = function() { return handleError(function (arg0) { getObject(arg0).requestFullscreen(); }, arguments) }; imports.wbg.__wbg_setAttribute_d8436c14a59ab1af = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) { getObject(arg0).setAttribute(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4)); }, arguments) }; imports.wbg.__wbg_target_bf704b7db7ad1387 = function(arg0) { const ret = getObject(arg0).target; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_addEventListener_cbe4c6f619b032f3 = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3)); }, arguments) }; imports.wbg.__wbg_removeEventListener_dd20475efce70084 = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).removeEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3)); }, arguments) }; imports.wbg.__wbg_index_94744625261e9824 = function(arg0) { const ret = getObject(arg0).index; return ret; }; imports.wbg.__wbg_pressed_7add67434a3dd765 = function(arg0) { const ret = getObject(arg0).pressed; return ret; }; imports.wbg.__wbg_instanceof_HtmlCanvasElement_97761617af6ea089 = function(arg0) { let result; try { result = getObject(arg0) instanceof HTMLCanvasElement; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_altKey_6dbe46bf3ae42d67 = function(arg0) { const ret = getObject(arg0).altKey; return ret; }; imports.wbg.__wbg_ctrlKey_fd79f035994d9387 = function(arg0) { const ret = getObject(arg0).ctrlKey; return ret; }; imports.wbg.__wbg_key_ad4fc49423a94efa = function(arg0, arg1) { const ret = getObject(arg1).key; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_matches_206d50bc7cb1f89e = function(arg0) { const ret = getObject(arg0).matches; return ret; }; imports.wbg.__wbg_getExtension_e7912bce04869d40 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).getExtension(getStringFromWasm0(arg1, arg2)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getParameter_4e2ccc745690476a = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).getParameter(arg1 >>> 0); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getProgramParameter_acf4ae158143e2b2 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getProgramParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_name_2473476082bed625 = function(arg0, arg1) { const ret = getObject(arg1).name; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getParameter_585a5b83c595ada8 = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).getParameter(arg1 >>> 0); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getProgramParameter_eaf768a9b399b7cf = function(arg0, arg1, arg2) { const ret = getObject(arg0).getProgramParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_document_3ead31dbcad65886 = function(arg0) { const ret = getObject(arg0).document; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_setTimeout_d6fcf0d9067b8e64 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).setTimeout(getObject(arg1), arg2); return ret; }, arguments) }; imports.wbg.__wbg_deleteVertexArray_00194a31d79df7e5 = function(arg0, arg1) { getObject(arg0).deleteVertexArray(getObject(arg1)); }; imports.wbg.__wbg_deleteVertexArrayOES_98b83132b3d85825 = function(arg0, arg1) { getObject(arg0).deleteVertexArrayOES(getObject(arg1)); }; imports.wbg.__wbg_createRenderbuffer_69c2f0554298bf89 = function(arg0) { const ret = getObject(arg0).createRenderbuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createRenderbuffer_531167a301a60e27 = function(arg0) { const ret = getObject(arg0).createRenderbuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_renderbufferStorage_4ceec9b17dbd1e76 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).renderbufferStorage(arg1 >>> 0, arg2 >>> 0, arg3, arg4); }; imports.wbg.__wbg_renderbufferStorage_0b6269243d09a9f7 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).renderbufferStorage(arg1 >>> 0, arg2 >>> 0, arg3, arg4); }; imports.wbg.__wbg_renderbufferStorageMultisample_3e76453eed60554b = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).renderbufferStorageMultisample(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_texStorage3D_19979792a7a67f59 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) { getObject(arg0).texStorage3D(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5, arg6); }; imports.wbg.__wbg_getSupportedExtensions_b84494641d686623 = function(arg0) { const ret = getObject(arg0).getSupportedExtensions(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_bufferData_d6fac0d761e08fec = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, arg2, arg3 >>> 0); }; imports.wbg.__wbg_bufferData_6ce28904b25c8be9 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, arg2, arg3 >>> 0); }; imports.wbg.__wbg_getBufferSubData_6b00169c609c16f7 = function(arg0, arg1, arg2, arg3) { getObject(arg0).getBufferSubData(arg1 >>> 0, arg2, getObject(arg3)); }; imports.wbg.__wbg_deleteRenderbuffer_58c540348fb8606d = function(arg0, arg1) { getObject(arg0).deleteRenderbuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteRenderbuffer_e5b3450b8b57b395 = function(arg0, arg1) { getObject(arg0).deleteRenderbuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteSampler_ec3ca2243d8cfcad = function(arg0, arg1) { getObject(arg0).deleteSampler(getObject(arg1)); }; imports.wbg.__wbg_getShaderParameter_42a35b974329561c = function(arg0, arg1, arg2) { const ret = getObject(arg0).getShaderParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_getShaderParameter_6cd8c36fded266ea = function(arg0, arg1, arg2) { const ret = getObject(arg0).getShaderParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_getShaderInfoLog_ec7e5b959e47645b = function(arg0, arg1, arg2) { const ret = getObject(arg1).getShaderInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getShaderInfoLog_451545b963646762 = function(arg0, arg1, arg2) { const ret = getObject(arg1).getShaderInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_deleteQuery_77a7ae09eda297e1 = function(arg0, arg1) { getObject(arg0).deleteQuery(getObject(arg1)); }; imports.wbg.__wbg_getSyncParameter_ab2f9499a91faae0 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getSyncParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_clientWaitSync_ad323ab9e423d0cf = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).clientWaitSync(getObject(arg1), arg2 >>> 0, arg3 >>> 0); return ret; }; imports.wbg.__wbg_beginQuery_909ec673d606f873 = function(arg0, arg1, arg2) { getObject(arg0).beginQuery(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_endQuery_05baee8fc782e5f0 = function(arg0, arg1) { getObject(arg0).endQuery(arg1 >>> 0); }; imports.wbg.__wbg_getQueryParameter_358ea490fb85e05c = function(arg0, arg1, arg2) { const ret = getObject(arg0).getQueryParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_readPixels_db685489e1779d63 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { getObject(arg0).readPixels(arg1, arg2, arg3, arg4, arg5 >>> 0, arg6 >>> 0, getObject(arg7)); }, arguments) }; imports.wbg.__wbg_readPixels_e855be1f94815442 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { getObject(arg0).readPixels(arg1, arg2, arg3, arg4, arg5 >>> 0, arg6 >>> 0, getObject(arg7)); }, arguments) }; imports.wbg.__wbg_readPixels_5d4e6205291096f0 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { getObject(arg0).readPixels(arg1, arg2, arg3, arg4, arg5 >>> 0, arg6 >>> 0, arg7); }, arguments) }; imports.wbg.__wbg_compressedTexSubImage3D_0df5a8ddb9ebafc2 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) { getObject(arg0).compressedTexSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10, arg11); }; imports.wbg.__wbg_compressedTexSubImage3D_9c916feb243112db = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) { getObject(arg0).compressedTexSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, getObject(arg10)); }; imports.wbg.__wbg_copyTexSubImage3D_7a262558a6a33f2e = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).copyTexSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9); }; imports.wbg.__wbg_drawElementsInstancedANGLE_6ac21f9a1ebe5f6b = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).drawElementsInstancedANGLE(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_drawArraysInstancedANGLE_89a45d6f51cd0483 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawArraysInstancedANGLE(arg1 >>> 0, arg2, arg3, arg4); }; imports.wbg.__wbg_drawElementsInstanced_2e05a96af17fe284 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).drawElementsInstanced(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_drawArraysInstanced_951a1d7e32c4f855 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawArraysInstanced(arg1 >>> 0, arg2, arg3, arg4); }; imports.wbg.__wbg_drawElements_e09dbef58c8f099a = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawElements(arg1 >>> 0, arg2, arg3 >>> 0, arg4); }; imports.wbg.__wbg_drawElements_241caa588795bcb1 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawElements(arg1 >>> 0, arg2, arg3 >>> 0, arg4); }; imports.wbg.__wbg_stencilMask_00541859199befd2 = function(arg0, arg1) { getObject(arg0).stencilMask(arg1 >>> 0); }; imports.wbg.__wbg_stencilMask_4eb0f989e4108b15 = function(arg0, arg1) { getObject(arg0).stencilMask(arg1 >>> 0); }; imports.wbg.__wbg_blendEquation_5d5abe2ee10109a9 = function(arg0, arg1) { getObject(arg0).blendEquation(arg1 >>> 0); }; imports.wbg.__wbg_blendEquation_72746aedc87e3f72 = function(arg0, arg1) { getObject(arg0).blendEquation(arg1 >>> 0); }; imports.wbg.__wbg_blendFunc_49ea28240d4c1084 = function(arg0, arg1, arg2) { getObject(arg0).blendFunc(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendFunc_99b48b64bde98c6f = function(arg0, arg1, arg2) { getObject(arg0).blendFunc(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendEquationSeparate_fa6aebc5cd0c5285 = function(arg0, arg1, arg2) { getObject(arg0).blendEquationSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendEquationSeparate_f0abe930082fff02 = function(arg0, arg1, arg2) { getObject(arg0).blendEquationSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendFuncSeparate_9fef8acb74d50df5 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_blendFuncSeparate_cecb7dfda39dc38d = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_uniformMatrix4fv_f16e4a5553357886 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix4fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix4fv_68d11b378757596e = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix4fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix3fv_2b7de3010c8ed627 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix3fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix3fv_a02aa02ecb8e5f99 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix3fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix2fv_4173a282fcaa5508 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix2fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix2fv_f4fc5e6214cc5549 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix2fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniform4iv_19aa13960dc767c2 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform4iv_67eed4073c7e55c5 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3iv_76acc51e8e6fe1a4 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3iv_df752fa54b2b8b7b = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2iv_8c390eac30cb1de3 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2iv_b1b33c9425d5791b = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform4fv_a513dc4d02f192d3 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform4fv_737873ef0bcd5e6c = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3fv_d1ef35c158c348e7 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3fv_740a7286bf6328ee = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2fv_3aad4d306a1cb8af = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2fv_a611afaf4a045f7e = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform1f_f60e1072e28b8c49 = function(arg0, arg1, arg2) { getObject(arg0).uniform1f(getObject(arg1), arg2); }; imports.wbg.__wbg_uniform1f_ade6c204580582c8 = function(arg0, arg1, arg2) { getObject(arg0).uniform1f(getObject(arg1), arg2); }; imports.wbg.__wbg_bindBufferRange_b8f6dc19661d5cf7 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).bindBufferRange(arg1 >>> 0, arg2 >>> 0, getObject(arg3), arg4, arg5); }; imports.wbg.__wbg_blendColor_3bea829c60b1f6f2 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendColor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_blendColor_50e203e2f58784cb = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendColor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_frontFace_5fd354be6327d46b = function(arg0, arg1) { getObject(arg0).frontFace(arg1 >>> 0); }; imports.wbg.__wbg_frontFace_97d7f9493791771d = function(arg0, arg1) { getObject(arg0).frontFace(arg1 >>> 0); }; imports.wbg.__wbg_cullFace_aa9f8eea262690c0 = function(arg0, arg1) { getObject(arg0).cullFace(arg1 >>> 0); }; imports.wbg.__wbg_cullFace_d6b862a4ad70b414 = function(arg0, arg1) { getObject(arg0).cullFace(arg1 >>> 0); }; imports.wbg.__wbg_disableVertexAttribArray_ab474d273ff59265 = function(arg0, arg1) { getObject(arg0).disableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_disableVertexAttribArray_6f3d27dd0ad6aabf = function(arg0, arg1) { getObject(arg0).disableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_enableVertexAttribArray_3d21f4936ad4a378 = function(arg0, arg1) { getObject(arg0).enableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_enableVertexAttribArray_a1ffc091f3999354 = function(arg0, arg1) { getObject(arg0).enableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_vertexAttribIPointer_167c7ed4319992e7 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).vertexAttribIPointer(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_vertexAttribDivisorANGLE_d5931335aaf0c735 = function(arg0, arg1, arg2) { getObject(arg0).vertexAttribDivisorANGLE(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_vertexAttribDivisor_2dc16945a591d4c6 = function(arg0, arg1, arg2) { getObject(arg0).vertexAttribDivisor(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_polygonOffset_4cba459d8eacb66d = function(arg0, arg1, arg2) { getObject(arg0).polygonOffset(arg1, arg2); }; imports.wbg.__wbg_polygonOffset_7af170d91752512c = function(arg0, arg1, arg2) { getObject(arg0).polygonOffset(arg1, arg2); }; imports.wbg.__wbg_depthFunc_2ac2c797a8220f09 = function(arg0, arg1) { getObject(arg0).depthFunc(arg1 >>> 0); }; imports.wbg.__wbg_depthFunc_1015c3364a49cd2f = function(arg0, arg1) { getObject(arg0).depthFunc(arg1 >>> 0); }; imports.wbg.__wbg_stencilMaskSeparate_5e7b9b536eac0c5d = function(arg0, arg1, arg2) { getObject(arg0).stencilMaskSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_stencilMaskSeparate_69e9937a9533f4ab = function(arg0, arg1, arg2) { getObject(arg0).stencilMaskSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_stencilOpSeparate_153523493abc8ec8 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilOpSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_stencilOpSeparate_c57c8bbe863e9f57 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilOpSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_stencilFuncSeparate_1f0226d5d3acaf47 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3, arg4 >>> 0); }; imports.wbg.__wbg_stencilFuncSeparate_2939e543fa4caa77 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3, arg4 >>> 0); }; imports.wbg.__wbg_scissor_4b89b60091ee8f0e = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).scissor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_scissor_b1b9e314ab6aac29 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).scissor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_viewport_a93f3881c4202d5e = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).viewport(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_viewport_319ab5302767fcc9 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).viewport(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_depthRange_5dccc27b5cdd74b3 = function(arg0, arg1, arg2) { getObject(arg0).depthRange(arg1, arg2); }; imports.wbg.__wbg_depthRange_c6ed3371d3b601f8 = function(arg0, arg1, arg2) { getObject(arg0).depthRange(arg1, arg2); }; imports.wbg.__wbg_clearBufferfi_92173f77d7147a2f = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferfi(arg1 >>> 0, arg2, arg3, arg4); }; imports.wbg.__wbg_clearBufferuiv_1f5c5e9baa9a3d9b = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferuiv(arg1 >>> 0, arg2, getArrayU32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniform4f_5b62a0acebac4494 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).uniform4f(getObject(arg1), arg2, arg3, arg4, arg5); }; imports.wbg.__wbg_uniform4f_d564461a6e4fdfe0 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).uniform4f(getObject(arg1), arg2, arg3, arg4, arg5); }; imports.wbg.__wbg_invalidateFramebuffer_802e38619851791e = function() { return handleError(function (arg0, arg1, arg2) { getObject(arg0).invalidateFramebuffer(arg1 >>> 0, getObject(arg2)); }, arguments) }; imports.wbg.__wbg_readBuffer_f20d42ed12643534 = function(arg0, arg1) { getObject(arg0).readBuffer(arg1 >>> 0); }; imports.wbg.__wbg_blitFramebuffer_cdc1ebf043046b70 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) { getObject(arg0).blitFramebuffer(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10 >>> 0); }; imports.wbg.__wbg_framebufferRenderbuffer_6b8dd5a111d341e6 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).framebufferRenderbuffer(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4)); }; imports.wbg.__wbg_framebufferRenderbuffer_963b305ac8cb6fd6 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).framebufferRenderbuffer(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4)); }; imports.wbg.__wbg_devicePixelRatio_476ddb014eb2520a = function(arg0) { const ret = getObject(arg0).devicePixelRatio; return ret; }; imports.wbg.__wbg_fullscreenElement_de98779ddf556e06 = function(arg0) { const ret = getObject(arg0).fullscreenElement; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_removeListener_c08dac8493263a47 = function() { return handleError(function (arg0, arg1) { getObject(arg0).removeListener(getObject(arg1)); }, arguments) }; imports.wbg.__wbg_button_2bb5dc0116d6b89b = function(arg0) { const ret = getObject(arg0).button; return ret; }; imports.wbg.__wbg_shiftKey_81014521a7612e6a = function(arg0) { const ret = getObject(arg0).shiftKey; return ret; }; imports.wbg.__wbg_ctrlKey_4795fb55a59f026c = function(arg0) { const ret = getObject(arg0).ctrlKey; return ret; }; imports.wbg.__wbg_altKey_2b8d6d80ead4bad7 = function(arg0) { const ret = getObject(arg0).altKey; return ret; }; imports.wbg.__wbg_metaKey_49e49046d8402fb7 = function(arg0) { const ret = getObject(arg0).metaKey; return ret; }; imports.wbg.__wbg_offsetX_8891849b36542d53 = function(arg0) { const ret = getObject(arg0).offsetX; return ret; }; imports.wbg.__wbg_offsetY_1f52082687af467b = function(arg0) { const ret = getObject(arg0).offsetY; return ret; }; imports.wbg.__wbg_movementX_f5947c282009d740 = function(arg0) { const ret = getObject(arg0).movementX; return ret; }; imports.wbg.__wbg_movementY_2c81eed268321a0a = function(arg0) { const ret = getObject(arg0).movementY; return ret; }; imports.wbg.__wbg_keyCode_72faed4278f77f2c = function(arg0) { const ret = getObject(arg0).keyCode; return ret; }; imports.wbg.__wbg_charCode_b0f31612a52c2bff = function(arg0) { const ret = getObject(arg0).charCode; return ret; }; imports.wbg.__wbg_code_06787cd3c7a60600 = function(arg0, arg1) { const ret = getObject(arg1).code; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_shiftKey_908ae224b8722a41 = function(arg0) { const ret = getObject(arg0).shiftKey; return ret; }; imports.wbg.__wbg_metaKey_cdd15bf44efb510e = function(arg0) { const ret = getObject(arg0).metaKey; return ret; }; imports.wbg.__wbg_matchMedia_0b5dc8aaf445df72 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).matchMedia(getStringFromWasm0(arg1, arg2)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_addListener_19238ce0935173e6 = function() { return handleError(function (arg0, arg1) { getObject(arg0).addListener(getObject(arg1)); }, arguments) }; imports.wbg.__wbg_matches_0ffc2232d99a6034 = function(arg0) { const ret = getObject(arg0).matches; return ret; }; imports.wbg.__wbg_setwidth_afb418d3fbf71ba7 = function(arg0, arg1) { getObject(arg0).width = arg1 >>> 0; }; imports.wbg.__wbg_setheight_3eb8729b59493242 = function(arg0, arg1) { getObject(arg0).height = arg1 >>> 0; }; imports.wbg.__wbg_style_e9380748cee29f13 = function(arg0) { const ret = getObject(arg0).style; return addHeapObject(ret); }; imports.wbg.__wbg_setProperty_e489dfd8c0a6bffc = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) { getObject(arg0).setProperty(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4)); }, arguments) }; imports.wbg.__wbindgen_closure_wrapper2743 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_34); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21156 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21162 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21166 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21169 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21172 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21175 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21178 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21181 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper26316 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_34); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper26996 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_37); return addHeapObject(ret); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedFloat32Memory0 = new Float32Array(); cachedFloat64Memory0 = new Float64Array(); cachedInt32Memory0 = new Int32Array(); cachedUint32Memory0 = new Uint32Array(); cachedUint8Memory0 = new Uint8Array(); wasm.__wbindgen_start(); return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('flappy-bird_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init;"},{"path":"/game/life-game/bootstrap.js","content":"// A dependency graph that contains any wasm must all be imported // asynchronously. This `bootstrap.js` file does the single async import, so // that no one else needs to worry about it again. import(\"./index.js\") .catch(e => console.error(\"Error importing `index.js`:\", e));"},{"path":"/game/life-game/index.html","content":"#fps { white-space: pre; font-family: monospace; }"},{"path":"/game/push-box/bootstrap.js","content":"// A dependency graph that contains any wasm must all be imported // asynchronously. This `bootstrap.js` file does the single async import, so // that no one else needs to worry about it again. import(\"./index.js\") .catch(e => console.error(\"Error importing `index.js`:\", e));"},{"path":"/game/life-game/index.js","content":"import init from \"./pkg/rust_game_booiris.js\"; import { Universe, Cell, wasm } from \"./pkg/rust_game_booiris.js\"; const run = () => { const fps = new class { constructor() { this.fps = document.getElementById(\"fps\"); this.frames = []; this.lastFrameTimeStamp = performance.now(); } render() { // Convert the delta time since the last frame render into a measure // of frames per second. const now = performance.now(); const delta = now - this.lastFrameTimeStamp; this.lastFrameTimeStamp = now; const fps = 1 / delta * 1000; // Save only the latest 100 timings. this.frames.push(fps); if (this.frames.length > 100) { this.frames.shift(); } // Find the max, min, and mean of our 100 latest timings. let min = Infinity; let max = -Infinity; let sum = 0; for (let i = 0; i < this.frames.length; i++) { sum += this.frames[i]; min = Math.min(this.frames[i], min); max = Math.max(this.frames[i], max); } let mean = sum / this.frames.length; // Render the statistics. this.fps.textContent = ` Frames per Second: latest = ${Math.round(fps)} avg of last 100 = ${Math.round(mean)} min of last 100 = ${Math.round(min)} max of last 100 = ${Math.round(max)} `.trim(); } }; const CELL_SIZE = 10; // px const GRID_COLOR = \"#CCCCCC\"; const DEAD_COLOR = \"#FFFFFF\"; const ALIVE_COLOR = \"#022222\"; const universe = Universe.new(); const width = universe.width(); const height = universe.height(); // Give the canvas room for all of our cells and a 1px border // around each of them. const canvas = document.getElementById(\"game-of-life-canvas\"); canvas.height = (CELL_SIZE + 1) * height + 1; canvas.width = (CELL_SIZE + 1) * width + 1; const ctx = canvas.getContext(\"2d\"); canvas.addEventListener(\"click\", (event) => { const boundingRect = canvas.getBoundingClientRect(); const scaleX = canvas.width / boundingRect.width; const scaleY = canvas.height / boundingRect.height; const canvasLeft = (event.clientX - boundingRect.left) * scaleX; const canvasTop = (event.clientY - boundingRect.top) * scaleY; const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1); const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1); universe.toggle_cell(row, col); drawGrid(); drawCells(); }); let animationId = null; const isPaused = () => { return animationId === null; }; const playPauseButton = document.getElementById(\"play-pause\"); const reStartButton = document.getElementById(\"restart\"); const play = () => { playPauseButton.textContent = \"â¸\"; reStartButton.textContent = \"âŒ\"; renderLoop(); }; const pause = () => { reStartButton.textContent = \"ğŸ”¥\"; playPauseButton.textContent = \"â–¶\"; cancelAnimationFrame(animationId); animationId = null; }; playPauseButton.addEventListener(\"click\", (event) => { if (isPaused()) { play(); } else { pause(); } }); reStartButton.addEventListener(\"click\", (event) => { if ((animationId === null)) { universe.restart(); drawGrid(); drawCells(); } }); const renderLoop = () => { fps.render(); universe.tick(); drawGrid(); drawCells(); // setTimeout(() => { // animationId = requestAnimationFrame(renderLoop); // }, 100); animationId = requestAnimationFrame(renderLoop); }; const drawGrid = () => { ctx.beginPath(); ctx.lineWidth = 1 / window.devicePixelRatio; ctx.strokeStyle = GRID_COLOR; // Vertical lines. for (let i = 0; i { const cellsPtr = universe.cells(); const cells = new Uint8Array(wasm.memory.buffer, cellsPtr, width * height); ctx.beginPath(); for (let row = 0; row < height; row++) { for (let col = 0; col < width; col++) { const idx = getIndex(row, col); ctx.fillStyle = cells[idx] === Cell.Dead ? DEAD_COLOR : ALIVE_COLOR; ctx.fillRect( col * (CELL_SIZE + 1) + 1, row * (CELL_SIZE + 1) + 1, CELL_SIZE, CELL_SIZE ); } } ctx.stroke(); }; drawGrid(); drawCells(); // requestAnimationFrame(renderLoop); pause(); }; init().then(run);"},{"path":"/game/push-box/index.js","content":"import init from \"./pkg/push_box.js\"; import { Game, Cell, wasm } from \"./pkg/push_box.js\"; const run = () => { const CELL_SIZE = 50; // px const LINE_SIZE = 4 const LINE_COLOR = \"#EEEEEE\"; const BACK_COLOR = \"#022222\"; const game = Game.new(); const height = game.height(); const width = game.width(); const person = new Image(); person.src = \"./img/spy.svg\" const key = new Image(); key.src = \"./img/key.svg\" const aim = new Image(); aim.src = \"./img/strongbox.svg\" const wall = new Image(); wall.src = \"./img/brick-wall.svg\" const canvas = document.getElementById(\"game-canvas\"); canvas.height = (CELL_SIZE + LINE_SIZE) * height + LINE_SIZE; canvas.width = (CELL_SIZE + LINE_SIZE) * width + LINE_SIZE; let trueHeight = canvas.height let trueWidth = canvas.width const ctx = canvas.getContext(\"2d\"); ctx.canvas.style.imageRendering = 'auto' let devicePixelRatio = window.devicePixelRatio || 1 let backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1 let ratio = devicePixelRatio / backingStoreRatio canvas.width = canvas.width * ratio canvas.height = canvas.height * ratio ctx.scale(ratio, ratio); canvas.style.width = `${trueWidth}px` canvas.style.height = `${trueHeight}px` let iter = 0 const renderLoop = () => { while (true) { if (game.game_over()) { if (iter % 500 == 0) { console.log(iter + 2 + \" begin!\") } iter += 1; game.restart() } if (iter > 5000) { console.log(\"end!!!!\") break } game.tick(); if (iter % 500 == 0) { drawGrid(); drawMap(); game.set_is_log(false) setTimeout(() => { requestAnimationFrame(renderLoop); }, 100); break } else { game.set_is_log(false) } } }; const drawGrid = () => { ctx.fillStyle = BACK_COLOR; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.lineWidth = LINE_SIZE; ctx.strokeStyle = LINE_COLOR; // Vertical lines. for (let i = 0; i { ctx.drawImage(img, 7 + (CELL_SIZE + LINE_SIZE) * x, 7 + (CELL_SIZE + LINE_SIZE) * y, CELL_SIZE - 5, CELL_SIZE - 5) } const drawMap = () => { const roomPtr = game.room(); const room = new Uint8Array(wasm.memory.buffer, roomPtr, width * height); for (let row = 0; row < height; row++) { for (let col = 0; col < width; col++) { const idx = getIndex(row, col); if (room[idx] == Cell.Empty) { continue; } else if (room[idx] == Cell.Person) { drawItem(person, row, col) } else if (room[idx] == Cell.Key) { drawItem(key, row, col) } else if (room[idx] == Cell.Aim) { drawItem(aim, row, col) } else if (room[idx] == Cell.Wall) { drawItem(wall, row, col) } } } } drawGrid(); drawMap(); renderLoop(); }; init().then(run);"},{"path":"/game/push-box/index.html","content":""},{"path":"/game/snake/bootstrap.js","content":"// A dependency graph that contains any wasm must all be imported // asynchronously. This `bootstrap.js` file does the single async import, so // that no one else needs to worry about it again. import(\"./index.js\") .catch(e => console.error(\"Error importing `index.js`:\", e));"},{"path":"/game/snake/draw.js","content":"import { BackEnd, wasm } from \"./test.js\"; const CELL_SIZE = 22; // px let WindowHandle; let Height, Width, Screen; let Ctx; function initDraw(data) { WindowHandle = BackEnd.new(data); Height = WindowHandle.height(); Width = WindowHandle.width(); const screenPtr = WindowHandle.screen(); Screen = new Uint8Array(wasm.memory.buffer, screenPtr, Width * Height * 3); const canvas = document.getElementById(\"canvas\"); canvas.height = CELL_SIZE * Height; canvas.width = CELL_SIZE * Width; Ctx = canvas.getContext(\"2d\"); return; } const getIndex = (row, col, width) => { return row * width * 3 + col * 3; } const draw = () => { Ctx.beginPath(); for (let row = 0; row < Height; row++) { for (let col = 0; col < Width; col++) { const idx = getIndex(row, col, Width); const r = Screen[idx]; const g = Screen[idx + 1]; const b = Screen[idx + 2]; Ctx.fillStyle = `rgb(${r}, ${g}, ${b})`; Ctx.fillRect( col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE ); } } Ctx.stroke(); } const drawRun = () => { draw(); const renderLoop = () => { WindowHandle.run() draw(); setTimeout(() => { requestAnimationFrame(renderLoop); }, 20); } renderLoop(); } export default initDraw; export { draw, drawRun };"},{"path":"/game/snake/foo.js","content":"// foo.js export async function read_file(path) { let resp = await fetch(path); let buffer = await resp.arrayBuffer(); const data = new Uint8Array(buffer); return data; }"},{"path":"/game/snake/index.html.html","content":"Trunk Template"},{"path":"/game/snake/index.js","content":"import { read_file } from \"./foo.js\"; import init from \"./test.js\"; import initDraw, { drawRun } from \"./draw.js\"; const run = (data) => { initDraw(data) drawRun() } await init(); let data = await read_file(\"./snake.nes\"); run(data);"},{"path":"/game/snake/index.html","content":""},{"path":"/game/snake/test.js","content":"let wasm; const heap = new Array(128).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 132) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } function debugString(val) { // primitive types const type = typeof val; if (type == 'number' || type == 'boolean' || val == null) { return `${val}`; } if (type == 'string') { return `\"${val}\"`; } if (type == 'symbol') { const description = val.description; if (description == null) { return 'Symbol'; } else { return `Symbol(${description})`; } } if (type == 'function') { const name = val.name; if (typeof name == 'string' && name.length > 0) { return `Function(${name})`; } else { return 'Function'; } } // objects if (Array.isArray(val)) { const length = val.length; let debug = '['; if (length > 0) { debug += debugString(val[0]); } for(let i = 1; i < length; i++) { debug += ', ' + debugString(val[i]); } debug += ']'; return debug; } // Test for built-in const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val)); let className; if (builtInMatches.length > 1) { className = builtInMatches[1]; } else { // Failed to match the standard '[object ClassName]' return toString.call(val); } if (className == 'Object') { // we're a user defined class or Object // JSON.stringify avoids problems with cycles, and is generally much // easier than looping through ownProperties of `val`. try { return 'Object(' + JSON.stringify(val) + ')'; } catch (_) { return 'Object'; } } // errors if (val instanceof Error) { return `${val.name}: ${val.message} ${val.stack}`; } // TODO we could test for more things here, like `Set`s and `Map`s. return className; } let WASM_VECTOR_LEN = 0; let cachedUint8Memory0 = null; function getUint8Memory0() { if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } let cachedInt32Memory0 = null; function getInt32Memory0() { if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function makeMutClosure(arg0, arg1, dtor, f) { const state = { a: arg0, b: arg1, cnt: 1, dtor }; const real = (...args) => { // First up with a closure we increment the internal reference // count. This ensures that the Rust closure environment won't // be deallocated while we're invoking it. state.cnt++; const a = state.a; state.a = 0; try { return f(a, state.b, ...args); } finally { if (--state.cnt === 0) { wasm.__wbindgen_export_2.get(state.dtor)(a, state.b); } else { state.a = a; } } }; real.original = state; return real; } function __wbg_adapter_14(arg0, arg1, arg2) { wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hf273e620554bcd11(arg0, arg1, addHeapObject(arg2)); } function passArray8ToWasm0(arg, malloc) { const ptr = malloc(arg.length * 1); getUint8Memory0().set(arg, ptr / 1); WASM_VECTOR_LEN = arg.length; return ptr; } function isLikeNone(x) { return x === undefined || x === null; } function handleError(f, args) { try { return f.apply(this, args); } catch (e) { wasm.__wbindgen_exn_store(addHeapObject(e)); } } function getArrayU8FromWasm0(ptr, len) { return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len); } /** */ export class BackEnd { static __wrap(ptr) { const obj = Object.create(BackEnd.prototype); obj.ptr = ptr; return obj; } __destroy_into_raw() { const ptr = this.ptr; this.ptr = 0; return ptr; } free() { const ptr = this.__destroy_into_raw(); wasm.__wbg_backend_free(ptr); } /** * @param {Uint8Array} data * @returns {BackEnd} */ static new(data) { const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc); const len0 = WASM_VECTOR_LEN; const ret = wasm.backend_new(ptr0, len0); return BackEnd.__wrap(ret); } /** * @returns {number} */ width() { const ret = wasm.backend_width(this.ptr); return ret >>> 0; } /** * @returns {number} */ height() { const ret = wasm.backend_height(this.ptr); return ret >>> 0; } /** * @returns {number} */ screen() { const ret = wasm.backend_screen(this.ptr); return ret; } /** */ run() { wasm.backend_run(this.ptr); } } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbg_instanceof_Window_e266f02eee43b570 = function(arg0) { let result; try { result = getObject(arg0) instanceof Window; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_document_950215a728589a2d = function(arg0) { const ret = getObject(arg0).document; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbindgen_object_clone_ref = function(arg0) { const ret = getObject(arg0); return addHeapObject(ret); }; imports.wbg.__wbg_addEventListener_615d4590d38da1c9 = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3)); }, arguments) }; imports.wbg.__wbg_key_f0decac219aa904b = function(arg0, arg1) { const ret = getObject(arg1).key; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) { getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2)); }; imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) { getObject(arg0).getRandomValues(getObject(arg1)); }; imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) { const ret = getObject(arg0).crypto; return addHeapObject(ret); }; imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) { const ret = getObject(arg0).msCrypto; return addHeapObject(ret); }; imports.wbg.__wbindgen_is_undefined = function(arg0) { const ret = getObject(arg0) === undefined; return ret; }; imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() { const ret = module; return addHeapObject(ret); }; imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) { const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) { const ret = getObject(arg0).getRandomValues; return addHeapObject(ret); }; imports.wbg.__wbg_newnoargs_2b8b6bd7753c76ba = function(arg0, arg1) { const ret = new Function(getStringFromWasm0(arg0, arg1)); return addHeapObject(ret); }; imports.wbg.__wbg_call_95d1ea488d03e4e8 = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).call(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_self_e7c1f827057f6584 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_window_a09ec664e14b1b81 = function() { return handleError(function () { const ret = window.window; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_globalThis_87cbb8506fecf3a9 = function() { return handleError(function () { const ret = globalThis.globalThis; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_global_c85a9259e621f3db = function() { return handleError(function () { const ret = global.global; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_buffer_cf65c07de34b9a08 = function(arg0) { const ret = getObject(arg0).buffer; return addHeapObject(ret); }; imports.wbg.__wbg_new_537b7341ce90bb31 = function(arg0) { const ret = new Uint8Array(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_set_17499e8aa4003ebd = function(arg0, arg1, arg2) { getObject(arg0).set(getObject(arg1), arg2 >>> 0); }; imports.wbg.__wbg_length_27a2afe8ab42b09f = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbg_newwithlength_b56c882b57805732 = function(arg0) { const ret = new Uint8Array(arg0 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_subarray_7526649b91a252a6 = function(arg0, arg1, arg2) { const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbindgen_debug_string = function(arg0, arg1) { const ret = debugString(getObject(arg1)); const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbindgen_memory = function() { const ret = wasm.memory; return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper63 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 12, __wbg_adapter_14); return addHeapObject(ret); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedInt32Memory0 = null; cachedUint8Memory0 = null; return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('test_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init; export { wasm }"},{"title":"1.2 é“¾è¡¨","path":"/wiki/redis/1.2 é“¾è¡¨.html","content":"TODO 1"},{"title":"1.1 SDS(åŠ¨æ€å­—ç¬¦ä¸²)","path":"/wiki/redis/1.1 SDS(åŠ¨æ€å­—ç¬¦ä¸²).html","content":"SDSä»‹ç» Redisè‡ªå·±æ„å»ºäº†ä¸€ç§åä¸ºç®€å•åŠ¨æ€å­—ç¬¦ä¸²(simple dynamic string, SDS) çš„æŠ½è±¡ç±»å‹ï¼Œå¹¶å°†å…¶ä½œä¸ºRedisçš„é»˜è®¤å­—ç¬¦ä¸²è¡¨ç¤ºã€‚ SDSå®šä¹‰ åœ¨ Redis7.0 ä¸­ å®šä¹‰çš„ä»£ç ä½äº src/sds.h ä¸­ï¼Œå®šä¹‰å¦‚ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */struct __attribute__ ((__packed__)) sdshdr5 &#123; unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; // æŸ”æ€§æ•°ç»„&#125;;struct __attribute__ ((__packed__)) sdshdr8 &#123; uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // æŸ”æ€§æ•°ç»„&#125;;struct __attribute__ ((__packed__)) sdshdr16 &#123; uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // æŸ”æ€§æ•°ç»„&#125;;struct __attribute__ ((__packed__)) sdshdr32 &#123; uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // æŸ”æ€§æ•°ç»„&#125;;struct __attribute__ ((__packed__)) sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // æŸ”æ€§æ•°ç»„&#125;; æ ¹æ®å­—ç¬¦ä¸²é•¿åº¦ä¸åŒï¼Œç”¨æ¥å­˜æ”¾å®ƒçš„sdsç±»å‹ä¹Ÿä¸åŒã€‚ å…¶ä¸­ len è¡¨ç¤ºä½¿ç”¨çš„å­—ç¬¦ä¸²é•¿åº¦ï¼Œalloc è¡¨ç¤ºåˆ†é…çš„æ€»ç©ºé—´çš„é•¿åº¦ï¼Œflags è¡¨ç¤ºå½“å‰ç»“æ„ä½“ç±»å‹ï¼Œå› ä¸ºåªæœ‰äº”ç§ç±»å‹ï¼Œæ‰€ä»¥åªä½¿ç”¨ä½ä¸‰ä½ï¼Œæœ‰å¦‚ä¸‹æšä¸¾å€¼ã€‚ 12345#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4 ç»“æ„å‰åŠ ä¸Šäº† __attribute__ ((__packed__)) å–æ¶ˆç¼–è¯‘å™¨çš„å†…å­˜å¯¹é½[1]ã€‚ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œä¸åŒçš„æ•°æ®ç±»å‹æœ‰ä¸åŒçš„å¯¹é½æ–¹å¼ï¼Œflags ä¸ buf å­˜åœ¨å¡«å……æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰å–æ¶ˆå†…å­˜å¯¹é½ï¼ŒÂ (char*)buf - 1 æ— æ³•ç›´æ¥è·å–æ•°æ®ç±»å‹çš„ flagsã€‚ SDSçš„å†…å­˜åˆ†é…æ–¹å¼è¯¦è§ 1.8 å†…å­˜åˆ†é…ã€‚ æ¥å£å®šä¹‰ å­—ç¬¦ä¸²å±æ€§æ¥å£ 12345678910// len å±æ€§ç›¸å…³static inline size_t sdslen(const sds s) ;static inline size_t sdsavail(const sds s);static inline void sdssetlen(sds s, size_t newlen) ;static inline void sdsinclen(sds s, size_t inc);// alloc å±æ€§ç›¸å…³/* sdsalloc() = sdsavail() + sdslen() */static inline size_t sdsalloc(const sds s);static inline void sdssetalloc(sds s, size_t newlen); sdslen æ¥å£ sdslen å‡½æ•°è¿”å›å­—ç¬¦ä¸²çš„å½“å‰é•¿åº¦ã€‚ 12345678910111213141516static inline size_t sdslen(const sds s) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16,s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32,s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64,s)-&gt;len; &#125; return 0;&#125; sds ç”± typedef char* sds; å®šä¹‰ã€‚å¯ä»¥çœ‹åˆ°ï¼Œsds å®é™…ä¸Šå°±æ˜¯æŒ‡å‘ sds ç»“æ„ä½“çš„ buf å±æ€§çš„æŒ‡é’ˆã€‚ç”±äºå–æ¶ˆäº†å†…å­˜å¯¹é½ï¼Œflags å’Œ buf ä¸­ä¸å«æœ‰å¡«å……æ•°æ®ï¼Œ(char *)buf - 1 å°±æ˜¯ flagsçš„å€¼ã€‚æ ¹æ® flags çš„å€¼åˆ¤æ–­å­—ç¬¦ä¸² 1#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) sdsavail æ¥å£ 12345678910111213141516171819202122232425static inline size_t sdsavail(const sds s) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; return 0; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8,s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16,s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32,s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64,s); return sh-&gt;alloc - sh-&gt;len; &#125; &#125; return 0;&#125; sdssetlen æ¥å£ 1234567891011121314151617181920212223static inline void sdssetlen(sds s, size_t newlen) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char*)s)-1; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8,s)-&gt;len = newlen; break; case SDS_TYPE_16: SDS_HDR(16,s)-&gt;len = newlen; break; case SDS_TYPE_32: SDS_HDR(32,s)-&gt;len = newlen; break; case SDS_TYPE_64: SDS_HDR(64,s)-&gt;len = newlen; break; &#125;&#125; sdsinclen æ¥å£ 123456789101112131415161718192021222324static inline void sdsinclen(sds s, size_t inc) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char*)s)-1; unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8,s)-&gt;len += inc; break; case SDS_TYPE_16: SDS_HDR(16,s)-&gt;len += inc; break; case SDS_TYPE_32: SDS_HDR(32,s)-&gt;len += inc; break; case SDS_TYPE_64: SDS_HDR(64,s)-&gt;len += inc; break; &#125;&#125; å‚è€ƒé“¾æ¥ c - Redis æºç è§£è¯»â€”â€”sds_ä¸ªäººæ–‡ç«  - SegmentFault æ€å¦ redisæºç è§£è¯»(ä¸€):åŸºç¡€æ•°æ®ç»“æ„ä¹‹SDS_czrzchaoçš„åšå®¢-CSDNåšå®¢ TODO: å®šä¹‰##æ“ä½œç¬¦ å¦‚æœæ²¡æœ‰é¢„å®šä¹‰å¯¹é½å€¼ï¼Œé‚£ä¹ˆç»“æ„ä½“æˆ–è€…ç±»çš„è‡ªèº«å¯¹é½å€¼ç­‰äºå…¶æˆå‘˜ä¸­è‡ªèº«å¯¹é½å€¼æœ€å¤§çš„é‚£ä¸ªå€¼ã€‚ â†©ï¸"},{"title":"1.3 å­—å…¸","path":"/wiki/redis/1.3 å­—å…¸.html","content":"TODO"},{"title":"1.4 è·³è¡¨","path":"/wiki/redis/1.4 è·³è¡¨.html","content":"TODO"},{"title":"1.5 æ•´æ•°é›†åˆ","path":"/wiki/redis/1.5 æ•´æ•°é›†åˆ.html","content":"TODO"},{"title":"1.7 å¯¹è±¡","path":"/wiki/redis/1.7 å¯¹è±¡.html","content":"TODO"},{"title":"1.8 å†…å­˜åˆ†é…","path":"/wiki/redis/1.8 å†…å­˜åˆ†é….html","content":"TODO"},{"title":"1.6 å‹ç¼©åˆ—è¡¨","path":"/wiki/redis/1.6 å‹ç¼©åˆ—è¡¨.html","content":"TODO"},{"title":"ç›®å½•","path":"/wiki/redis/catalog.html","content":"å‚è€ƒ ã€ŠRedisè®¾è®¡ä¸å®ç°ã€‹ ç¬¬ä¸€ç« ï¼šæ•°æ®å¯¹è±¡ 1.1 SDS(åŠ¨æ€å­—ç¬¦ä¸²) 1.2 é“¾è¡¨ 1.3 å­—å…¸ 1.4 è·³è¡¨ 1.5 æ•´æ•°é›†åˆ 1.6 å‹ç¼©åˆ—è¡¨ 1.7 å¯¹è±¡ 1.8 å†…å­˜åˆ†é… ç¬¬äºŒç« ï¼š RDB æŒä¹…åŒ–"},{"title":"å¼€å§‹","path":"/wiki/redis/å¼€å§‹.html","content":"å‚è€ƒ ã€ŠRedisè®¾è®¡ä¸å®ç°ã€‹ redis 7.0 ä»£ç ç»“æ„"},{"title":"1051-Height Checker","path":"/wiki/leetcode/1051-Height Checker.html","content":"é¢˜æ„ A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] != expected[i]. é¢˜è§£ æ’åºåŸæ•°ç»„ï¼Œå¯¹åº”ä½ç½®ä¸åŒçš„è®¡æ•°åŠ ä¸€ï¼Œè¿”å›æœ€ç»ˆä¸åŒå…ƒç´ çš„è®¡æ•°ã€‚ 12345678910111213141516171819202122232425#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int heightChecker(vector&lt;int&gt; &amp;heights) &#123; vector&lt;int&gt; temp(heights); sort(heights.begin(), heights.end()); int res = 0; for (int i = 0; i &lt; heights.size(); i++) &#123; if (heights[i] != temp[i]) res++; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"1089-Duplicate Zeros","path":"/wiki/leetcode/1089-Duplicate Zeros.html","content":"é¢˜æ„ ç»™ä½ ä¸€ä¸ªé•¿åº¦å›ºå®šçš„æ•´æ•°æ•°ç»„Â arrï¼Œè¯·ä½ å°†è¯¥æ•°ç»„ä¸­å‡ºç°çš„æ¯ä¸ªé›¶éƒ½å¤å†™ä¸€éï¼Œå¹¶å°†å…¶ä½™çš„å…ƒç´ å‘å³å¹³ç§»ã€‚ æ³¨æ„ï¼šè¯·ä¸è¦åœ¨è¶…è¿‡è¯¥æ•°ç»„é•¿åº¦çš„ä½ç½®å†™å…¥å…ƒç´ ã€‚ è¦æ±‚ï¼šè¯·å¯¹è¾“å…¥çš„æ•°ç»„Â å°±åœ°Â è¿›è¡Œä¸Šè¿°ä¿®æ”¹ï¼Œä¸è¦ä»å‡½æ•°è¿”å›ä»»ä½•ä¸œè¥¿ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(1)O(1)O(1)ã€‚ é¢˜è§£ ä½¿ç”¨åŒæŒ‡é’ˆï¼Œé€šè¿‡ç»´æŠ¤ä¸¤ä¸ªåŒæŒ‡é’ˆæ¨¡æ‹Ÿæ ˆã€‚ 12345678910111213141516171819202122232425262728293031#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: void duplicateZeros(vector&lt;int&gt; &amp;arr) &#123; int now = 0, top = 0; while (top &lt; arr.size()) &#123; if (arr[now] == 0) top++; now++, top++; &#125; while (now &gt; 0) &#123; now--, top--; if (arr[now] == 0) &#123; if (top &lt; arr.size()) arr[top] = 0; top--; &#125; arr[top] = arr[now]; &#125; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"1157-Online Majority Element In Subarray","path":"/wiki/leetcode/1157-Online Majority Element In Subarray.html","content":"é¢˜æ„ è®¾è®¡ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œæœ‰æ•ˆåœ°æ‰¾åˆ°ç»™å®šå­æ•°ç»„çš„ å¤šæ•°å…ƒç´  ã€‚ å­æ•°ç»„çš„ å¤šæ•°å…ƒç´  æ˜¯åœ¨å­æ•°ç»„ä¸­å‡ºç°Â thresholdÂ æ¬¡æ•°æˆ–æ¬¡æ•°ä»¥ä¸Šçš„å…ƒç´ ã€‚ å®ç° MajorityChecker ç±»: MajorityChecker(int[] arr)Â ä¼šç”¨ç»™å®šçš„æ•°ç»„ arrÂ å¯¹Â MajorityChecker åˆå§‹åŒ–ã€‚ int query(int left, int right, int threshold)Â è¿”å›å­æ•°ç»„ä¸­çš„å…ƒç´  arr[leftâ€¦right]Â è‡³å°‘å‡ºç°Â thresholdÂ æ¬¡æ•°ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„å…ƒç´ åˆ™è¿”å› -1ã€‚ é¢˜è§£ çº¿æ®µæ ‘+æ‘©å°”æŠ•ç¥¨ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::f32::consts::E;use std::ops::AddAssign;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;#[derive(Clone, Copy)]pub struct Node &#123; num: i32, cnt: i32,&#125;impl Node &#123; #[inline] fn new(num: i32, cnt: i32) -&gt; Self &#123; Node &#123; num, cnt &#125; &#125;&#125;impl AddAssign for Node &#123; fn add_assign(&amp;mut self, rhs: Self) &#123; if self.num == rhs.num &#123; self.cnt += rhs.cnt; &#125; else if self.cnt &gt;= rhs.cnt &#123; self.cnt -= rhs.cnt; &#125; else &#123; self.num = rhs.num; self.cnt = rhs.cnt - self.cnt; &#125; &#125;&#125;pub struct SegTree &#123; tree: Vec&lt;Node&gt;, val: Vec&lt;i32&gt;, len: usize,&#125;impl SegTree &#123; #[inline] pub fn new(arr: Vec&lt;i32&gt;) -&gt; Self &#123; let len = arr.len(); SegTree &#123; tree: vec![Node::new(0, 0); len * 4 + 1], val: arr, len, &#125; &#125; pub fn build(&amp;mut self, id: usize, l: usize, r: usize) &#123; if l == r &#123; self.tree[id].num = self.val[l]; self.tree[id].cnt = 1; return; &#125; let mid = (l + r) / 2; self.build(id * 2 + 1, l, mid); self.build(id * 2 + 2, mid + 1, r); let temp = self.tree[id * 2 + 1]; self.tree[id] += temp; let temp = self.tree[id * 2 + 2]; self.tree[id] += temp; &#125; pub fn query(&amp;self, id: usize, l: usize, r: usize, ql: usize, qr: usize, ans: &amp;mut Node) &#123; if l &gt; qr || r &lt; ql &#123; return; &#125; if ql &lt;= l &amp;&amp; r &lt;= qr &#123; *ans += self.tree[id]; return; &#125; let mid = (l + r) / 2; self.query(id * 2 + 1, l, mid, ql, qr, ans); self.query(id * 2 + 2, mid + 1, r, ql, qr, ans); &#125;&#125;struct MajorityChecker &#123; seg_tree: SegTree, loc: HashMap&lt;i32, Vec&lt;usize&gt;&gt;,&#125;/** * `&amp;self` means the method takes an immutable reference. * If you need a mutable reference, change it to `&amp;mut self` instead. */impl MajorityChecker &#123; fn new(arr: Vec&lt;i32&gt;) -&gt; Self &#123; let mut loc = HashMap::new(); for (i, v) in arr.iter().enumerate() &#123; loc.entry(*v).or_insert(vec![]).push(i); &#125; let mut seg_tree = SegTree::new(arr); seg_tree.build(0, 0, seg_tree.len - 1); MajorityChecker &#123; seg_tree, loc &#125; &#125; fn query(&amp;self, left: i32, right: i32, threshold: i32) -&gt; i32 &#123; let mut ans = Node::new(0, 0); self.seg_tree.query( 0, 0, self.seg_tree.len - 1, left as usize, right as usize, &amp;mut ans, ); let key = self.loc.get(&amp;ans.num); if key.is_none() &#123; return -1; &#125; let key = key.unwrap(); let cnt = key.partition_point(|x| *x &lt;= right as usize) - key.partition_point(|x| *x &lt; left as usize); if cnt &gt;= threshold as usize &#123; ans.num &#125; else &#123; -1 &#125; &#125;&#125;/** * Your MajorityChecker object will be instantiated and called as such: * let obj = MajorityChecker::new(arr); * let ret_1: i32 = obj.query(left, right, threshold); */#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let arr = [1, 1, 2, 2, 1, 1]; let obj = MajorityChecker::new(arr.into()); let ini = [[0, 5, 4], [0, 3, 3], [2, 3, 2]]; for x in ini &#123; println!(&quot;res:&#123;&#125;&quot;, obj.query(x[0], x[1], x[2])); &#125;&#125; æ ‘å¥—æ ‘","tags":[null,null,null]},{"title":"1302-Deepest Leaves Sum","path":"/wiki/leetcode/1302-Deepest Leaves Sum.html","content":"é¢˜æ„ ç»™å‡ºä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®—æœ€æ·±ä¸€å±‚çš„èŠ‚ç‚¹å’Œã€‚ é¢˜è§£ dfsï¼Œå¦‚æœå½“å‰çš„å±‚æ•°å¤§äºæœ€å¤§å±‚æ•°ï¼Œåˆ™æ›´æ–°æœ€å¤§å±‚æ•°ï¼Œå¹¶ä¸”é‡ç½®èŠ‚ç‚¹å’Œã€‚å½“å½“å‰å±‚æ•°ç­‰äºæœ€å¤§å±‚æ•°çš„æ—¶å€™ï¼Œå°†å½“å‰èŠ‚ç‚¹å€¼åŠ å…¥èŠ‚ç‚¹å’Œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#[allow(dead_code)]#[allow(unused_imports)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;// Definition for a binary tree node.#[cfg(feature = &quot;local&quot;)]#[derive(Debug, PartialEq, Eq)]pub struct TreeNode &#123; pub val: i32, pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,&#125;#[cfg(feature = &quot;local&quot;)]impl TreeNode &#123; #[inline] pub fn new(val: i32) -&gt; Self &#123; TreeNode &#123; val, left: None, right: None, &#125; &#125;&#125;fn dfs(now: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, depth: i32, maxdepth: &amp;mut i32, key: &amp;mut i32) &#123; if let Some(ref x) = now &#123; if depth &gt; *maxdepth &#123; *maxdepth = depth; *key = 0; &#125; if depth == *maxdepth &#123; *key += x.borrow().val; &#125; dfs(x.borrow_mut().left.take(), depth + 1, maxdepth, key); dfs(x.borrow_mut().right.take(), depth + 1, maxdepth, key); &#125;&#125;use std::cell::RefCell;use std::rc::Rc;impl Solution &#123; pub fn deepest_leaves_sum(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 &#123; let mut maxdepth = 0; let mut key = 0; dfs(root, 0, &amp;mut maxdepth, &amp;mut key); key &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; println!(&quot;res:&quot;);&#125;"},{"title":"1403-Minimum Subsequence in Non-Increasing Order","path":"/wiki/leetcode/1403-Minimum Subsequence in Non-Increasing Order.html","content":"é¢˜æ„ ç»™å‡ºä¸€ä¸ªæ•°ç»„ï¼Œå°†æ•°ç»„åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œå…¶ä¸­ä¸€ä¸ªéƒ¨åˆ†Aå’Œä¸¥æ ¼å¤§äºå¦ä¸€éƒ¨åˆ†å’Œï¼Œè¦æ±‚Aéƒ¨åˆ†å°½å¯èƒ½çŸ­ï¼Œå¦‚æœå…ˆç›¸åŒé•¿åº¦Açš„å’Œå°½å¯èƒ½å¤§ã€‚ é¢˜è§£ ä»å¤§åˆ°å°æ’åºæ•°ç»„ï¼Œä¸æ–­å–å‡ºå½“å‰æœ€å¤§çš„æ•°ç›´åˆ°å–å‡ºçš„æ•°çš„å’Œå¤§äºå‰©ä¸‹çš„æ•°çš„å’Œã€‚å–å‡ºçš„æ•°é›†å³ä¸ºç­”æ¡ˆã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#[allow(dead_code)]#[allow(unused_imports)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;impl Solution &#123; pub fn min_subsequence(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123; nums.sort_unstable(); nums.reverse(); let mut sum = nums.iter().sum(); let mut res = vec![]; let mut now = 0; for num in nums.iter() &#123; now += *num; sum -= *num; res.push(*num); if now &gt; sum &#123; break; &#125; &#125; res &#125;&#125;#[cfg(test)]pub fn main() &#123; println!(&quot;res:&#123;:?&#125;&quot;, Solution::min_subsequence(vec![4, 3, 10, 9, 8]));&#125;","tags":[null]},{"title":"1728-Cat and Mouse II","path":"/wiki/leetcode/1728-Cat and Mouse II.html","content":"é¢˜æ„ A game is played by a cat and a mouse named Cat and Mouse. The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food. Players are represented by the characters â€˜Câ€™(Cat),â€˜Mâ€™(Mouse). Floors are represented by the character â€˜.â€™ and can be walked on. Walls are represented by the character â€˜#â€™ and cannot be walked on. Food is represented by the character â€˜Fâ€™ and can be walked on. There is only one of each character â€˜Câ€™, â€˜Mâ€™, and â€˜Fâ€™ in grid. Mouse and Cat play according to the following rules: Mouse moves first, then they take turns to move. During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid. catJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length. Staying in the same position is allowed. Mouse can jump over Cat. The game can end in 4 ways: If Cat occupies the same position as Mouse, Cat wins. If Cat reaches the food first, Cat wins. If Mouse reaches the food first, Mouse wins. If Mouse cannot get to the food within 1000 turns, Cat wins. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. é¢˜è§£1ï¼ˆä¼ªï¼‰ åšå¼ˆ+è®°å¿†åŒ–æœç´¢å‰ªæã€‚ å¦‚æœè½®åˆ°ç©å®¶1è¡ŒåŠ¨ï¼Œæœç´¢å½“å‰ç©å®¶æ‰€æœ‰å¯è¡Œçš„è¡ŒåŠ¨ï¼Œå¦‚æœæœ‰å¯ä»¥è·èƒœçš„è¡ŒåŠ¨ï¼Œé‚£ä¹ˆç©å®¶1ä¸€å®šä¼šé‡‡ç”¨è¿™ä¸ªè¡ŒåŠ¨ï¼Œæ‰€ä»¥æ­¤å±‚åšå¼ˆè¿”å›ç©å®¶1è·èƒœã€‚å¦‚æœç©å®¶1ä¸‹ä¸€æ­¥çš„æ‰€æœ‰è¡ŒåŠ¨éƒ½ä¸èƒ½è·èƒœï¼Œé‚£ä¹ˆç©å®¶1å¿…è´¥ï¼Œæ‰€ä»¥æ­¤å±‚åšå¼ˆè¿”å›ç©å®¶1å¤±è´¥ã€‚ç©å®¶2çš„æƒ…å†µç±»ä¼¼ã€‚ ä½¿ç”¨ dfs æœç´¢åšå¼ˆæ ‘ï¼Œä½¿ç”¨ä¸€ä¸ªçŠ¶æ€æ•°ç»„ä¿å­˜æœç´¢çŠ¶æ€ï¼Œç„¶è€Œï¼Œæœ€å¤§æ­¥æ•°ä¸º 1000ã€‚æ‰€æœ‰çš„çŠ¶æ€æœ‰ 1000å±‚ Ã—\\timesÃ— ç©å®¶1å¯èƒ½çš„ä½ç½® 8*8=64 Ã—\\timesÃ— ç©å®¶2å¯èƒ½çš„ä½ç½® 8*8=64ã€‚æ€»çŠ¶æ€æœ‰ 1000Ã—64Ã—64=4e61000 \\times 64 \\times 64 = 4e61000Ã—64Ã—64=4e6 ï¼Œåœ¨ TLE çš„è¾¹ç¼˜ã€‚ä¸å‡ºæ„å¤–ï¼Œæäº¤ä¼šå‡ºç° TLEã€‚ç„å­¦è®¾ç½®æœ€å¤§å±‚æ•°ä¸º 256ï¼Œå°±å¡è¿‡å»äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int cj, mj; vector&lt;string&gt; grid; int n, m; int vis[260][64][64]; int dir[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;; int dfs(int x1, int y1, int x2, int y2, int depth, int player) &#123; if (x1 == x2 &amp;&amp; y1 == y2) return 2; if (depth &gt;= 256) return 2; if (grid[x1][y1] == &#x27;F&#x27;) return 1; if (grid[x2][y2] == &#x27;F&#x27;) return 2; int pos1 = x1 * m + y1; int pos2 = x2 * m + y2; if (vis[depth][pos1][pos2] != 0) &#123; return vis[depth][pos1][pos2]; &#125; // cout &lt;&lt; player &lt;&lt; &quot; &quot; &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; y1 &lt;&lt; &quot; &quot; &lt;&lt; x2 &lt;&lt; &quot; &quot; &lt;&lt; y2 &lt;&lt; &quot; &quot;; int res = 0; if (player == 1) &#123; for (int j = 0; j &lt; 4; j++) &#123; for (int i = 1; i &lt;= mj; i++) &#123; int nx = x1 + dir[j][0] * i, ny = y1 + dir[j][1] * i; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) break; if (grid[nx][ny] == &#x27;#&#x27;) break; int flag = dfs(nx, ny, x2, y2, depth + 1, 2); if (flag == 1) res = 1; &#125; &#125; int flag = dfs(x1, y1, x2, y2, depth + 1, 2); if (flag == 1) res = 1; if (res == 0) res = 2; &#125; else &#123; for (int j = 0; j &lt; 4; j++) &#123; for (int i = 1; i &lt;= cj; i++) &#123; int nx = x2 + dir[j][0] * i, ny = y2 + dir[j][1] * i; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) break; if (grid[nx][ny] == &#x27;#&#x27;) break; int flag = dfs(x1, y1, nx, ny, depth + 1, 1); if (flag == 2) res = 2; &#125; &#125; int flag = dfs(x1, y1, x2, y2, depth + 1, 1); if (flag == 2) res = 2; if (res == 0) res = 1; &#125; vis[depth][pos1][pos2] = res; return res; &#125; bool canMouseWin(vector&lt;string&gt; _grid, int _catJump, int _mouseJump) &#123; cj = _catJump; mj = _mouseJump; grid = _grid; n = grid.size(); m = grid[0].size(); int mx, my, cx, cy; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == &#x27;C&#x27;) cx = i, cy = j; if (grid[i][j] == &#x27;M&#x27;) mx = i, my = j; &#125; &#125; return dfs(mx, my, cx, cy, 0, 1) == 1 ? true : false; &#125;&#125;;#ifdef LOCALint main() &#123; // ios::sync_with_stdio(false); // cin.tie(0); Solution s; // .M... // ..#.. // #..#. // C#.#. // ...#F vector&lt;string&gt; a = &#123;&quot;.M...&quot;, &quot;..#..&quot;, &quot;#..#.&quot;, &quot;C#.#.&quot;, &quot;...#F&quot;&#125;; cout &lt;&lt; s.canMouseWin(a, 3, 1) &lt;&lt; &quot; &quot;;&#125;#endif é¢˜è§£2 æ‹“æ‰‘æ’åº #todo [ ] TODO: æ‹“æ‰‘æ’åº","tags":[null,null]},{"title":"1823-Find the Winner of the Circular Game","path":"/wiki/leetcode/1823-Find the Winner of the Circular Game.html","content":"é¢˜æ„ çº¦ç‘Ÿå¤«ç¯é—®é¢˜ï¼Œä» 1 å¼€å§‹ï¼Œæ•° k ä¸ªæ•°ï¼Œæœ€åä¸€ä¸ªäººå‡ºå»ï¼Œå†æ¥ç€æ•°ï¼Œç›´åˆ°å‰©ä¸‹æœ€åä¸€ä¸ªäººï¼Œæ±‚æœ€åä¸€ä¸ªäººå¯¹åº”çš„ä½ç½®ã€‚ ä¸‹é¢æ˜¯ 5 ä¸ªäººï¼Œæ¯æ¬¡æ•° 2 ä¸ªçš„æƒ…å†µã€‚ é¢˜è§£ å¯¹äºæœ€åä¸€ä¸ªäººï¼Œæ¯æ¬¡æ“ä½œä¸ä¸‹ä¸€æ¬¡æ“ä½œå·® kï¼Œ é€’å½’è§£å†³å³å¯ï¼Œæ³¨æ„ä¸‹æ ‡ä» 1 å¼€å§‹ï¼Œæ³¨æ„ä¸€ä¸‹è¾¹ç•Œæ¡ä»¶ã€‚ 1234567891011121314151617181920212223#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int findTheWinner(int n, int k) &#123; if (n == 1) return 1; int pre = findTheWinner(n - 1, k); int res = (pre + k) % n; return res == 0 ? n : res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0); Solution s; cout &lt;&lt; s.findTheWinner(5, 2) &lt;&lt; &quot; &quot;;&#125;#endif","tags":[null]},{"title":"442-Find All Duplicates in an Array","path":"/wiki/leetcode/442-Find All Duplicates in an Array.html","content":"é¢˜æ„ ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„å…ƒç´ çš„å€¼ä¸º [1,n], æ•°ç»„ä¸­å­˜åœ¨å‡ºç°ä¸€æ¬¡å’Œå‡ºç°ä¸¤æ¬¡çš„å…ƒç´ ï¼Œè¦æ±‚åœ¨ O(n)O(n)O(n) æ—¶é—´å’Œ O(1)O(1)O(1) ç©ºé—´è¿”å›å‡ºç°ä¸¤æ¬¡çš„å…ƒç´ ã€‚ é¢˜è§£ 1234567891011121314151617181920212223242526#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt; &amp;nums) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; while (nums[i] != nums[nums[i] - 1]) swap(nums[i], nums[nums[i] - 1]); &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] - 1 != i) res.push_back(nums[i] - 1); &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"433-Minimum Genetic Mutation","path":"/wiki/leetcode/433-Minimum Genetic Mutation.html","content":"é¢˜æ„ ç»™å‡ºåˆå§‹å­—ç¬¦ä¸²ã€ç›®æ ‡å­—ç¬¦ä¸²å’Œä¸€ç»„ä¸­é—´å­—ç¬¦ä¸²ï¼Œæœ‰å¦‚ä¸‹è§„åˆ™ã€‚ æ¯æ¬¡æ”¹å˜åªèƒ½æ”¹å˜å­—ç¬¦ä¸²ä¸­çš„ä¸€ä½å­—ç¬¦ã€‚ æ”¹å˜åçš„å­—ç¬¦ä¸²å¿…é¡»åœ¨ä¸­é—´å­—ç¬¦ä¸²ä¸­ã€‚ ä¸ºåˆå§‹å­—ç¬¦ä¸²å˜åŒ–ä¸ºç›®æ ‡å­—ç¬¦ä¸²æ‰€éœ€è¦çš„æ¬¡æ•°ã€‚ é¢˜è§£ æ ¹æ®è§„åˆ™åœ¨ä¸­é—´å­—ç¬¦ä¸²å†…å»ºå›¾ï¼Œå¯¹äºä¸­é—´å­—ç¬¦ä¸²å†…ä¸¤ä¸ªä¸åŒçš„å­—ç¬¦ä¸² a, bï¼Œå¦‚æœä»–ä»¬ç›¸å·®ä¸€ä½å­—ç¬¦ï¼Œåˆ™è¿ä¸Šä¸€æ¡åŒå‘è¾¹ã€‚æœ€åä»¥åˆå§‹å­—ç¬¦ä¸²ä½œä¸ºæºç‚¹å’Œä»¥ç›®æ ‡å­—ç¬¦ä¸²ä¸ºæ±‡ç‚¹å»ºå›¾ã€‚ æœ€åæ ¹æ®å»ºå¥½çš„å›¾ bfs ä¸€éå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: unordered_map&lt;string, int&gt; id; vector&lt;string&gt; mp; vector&lt;int&gt; p[15]; bool vis[15]; int minMutation(string start, string end, vector&lt;string&gt; &amp;bank) &#123; mp = bank; for (int i = 1; i &lt;= bank.size(); i++) &#123; id[bank[i - 1]] = i; &#125; int n = bank.size() + 1; for (int i = 0; i &lt; bank.size(); i++) &#123; for (int j = 0; j &lt; bank.size(); j++) &#123; if (i == j) continue; int flag = 0; for (int k = 0; k &lt; bank[i].size(); k++) &#123; if (bank[i][k] != bank[j][k]) flag++; &#125; if (flag == 1) &#123; p[id[bank[i]]].push_back(id[bank[j]]); p[id[bank[j]]].push_back(id[bank[i]]); &#125; &#125; int flag = 0; for (int k = 0; k &lt; bank[i].size(); k++) &#123; if (start[k] != bank[i][k]) flag++; &#125; if (flag == 1) &#123; p[0].push_back(id[bank[i]]); p[id[bank[i]]].push_back(0); &#125; flag = 0; for (int k = 0; k &lt; bank[i].size(); k++) &#123; if (end[k] != bank[i][k]) flag++; &#125; if (flag == 0) &#123; p[n].push_back(id[bank[i]]); p[id[bank[i]]].push_back(n); &#125; &#125; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(0, -1); vis[0] = 1; while (!q.empty()) &#123; auto now = q.front(); q.pop(); if (now.first == n) &#123; return now.second; &#125; for (int i = 0; i &lt; p[now.first].size(); i++) &#123; int nxt = p[now.first][i]; if (vis[nxt]) continue; vis[nxt] = 1; q.emplace(nxt, now.second + 1); &#125; &#125; return -1; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"449-Serialize and Deserialize BST","path":"/wiki/leetcode/449-Serialize and Deserialize BST.html","content":"é¢˜æ„ å°†ä¸€ä¸ªæœç´¢æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºä¸€æ£µæ ‘ã€‚ åºåˆ—åŒ–ï¼š æŒ‰ç…§è‡ªå·±çš„è§„åˆ™å°†ä¸€ç»„æ•°æ®ç»“æ„ç”¨å­—ç¬¦ä¸²è¡¨ç¤ºã€‚ é¢˜è§£ æ²¡çœ‹åˆ°æ˜¯æœç´¢æ ‘ï¼Œç›´æ¥ç”¨å±‚åºéå†åºåˆ—åŒ–ï¼Œè®°å½•æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°æ®ï¼Œç©ºèŠ‚ç‚¹ç”¨ç‰¹æ®Šå­—ç¬¦è¡¨ç¤ºå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123; public: // Encodes a tree to a single string. string serialize(TreeNode *root) &#123; if (root == nullptr) return &quot;&quot;; string res = &quot;&quot;; queue&lt;pair&lt;TreeNode *, char&gt;&gt; q; q.emplace(root, &#x27;N&#x27;); while (!q.empty()) &#123; int len = q.size(); while (len--) &#123; auto qf = q.front(); q.pop(); auto now = qf.first; if (now == nullptr) &#123; res += qf.second; continue; &#125; stringstream ss; ss &lt;&lt; now-&gt;val; string temp; ss &gt;&gt; temp; res += temp + qf.second; if (now-&gt;left != nullptr) q.emplace(now-&gt;left, &#x27;L&#x27;); else q.emplace(nullptr, &#x27;#&#x27;); if (now-&gt;right != nullptr) q.emplace(now-&gt;right, &#x27;R&#x27;); else q.emplace(nullptr, &#x27;%&#x27;); &#125; res += &#x27;$&#x27;; &#125; return res; &#125; // Decodes your encoded data to tree. TreeNode *deserialize(string data) &#123; // cout&lt;&lt;data&lt;&lt;&quot; &quot;; if (data == &quot;&quot;) return nullptr; int index = 0; string temp = &quot;&quot;; while (data[index] &gt;= &#x27;0&#x27; &amp;&amp; data[index] &lt;= &#x27;9&#x27;) &#123; temp += data[index]; index++; &#125; index++; stringstream tt; tt &lt;&lt; temp; int root_v; tt &gt;&gt; root_v; TreeNode *root = new TreeNode(root_v); queue&lt;TreeNode *&gt; q; q.emplace(nullptr); q.emplace(root); TreeNode *now = root; while (index &lt; data.size()) &#123; if (data[index] == &#x27;$&#x27;) &#123; while (!q.empty() &amp;&amp; q.front() != nullptr) &#123; q.pop(); &#125; q.pop(); q.emplace(nullptr); index++; continue; &#125; else if (data[index] == &#x27;#&#x27;) &#123; index++; continue; &#125; else if (data[index] == &#x27;%&#x27;) &#123; index++; q.pop(); continue; &#125; string temp = &quot;&quot;; while (data[index] &gt;= &#x27;0&#x27; &amp;&amp; data[index] &lt;= &#x27;9&#x27;) &#123; temp += data[index]; index++; &#125; int now_val; stringstream ss; ss &lt;&lt; temp; ss &gt;&gt; now_val; if (data[index] == &#x27;L&#x27;) &#123; q.front()-&gt;left = new TreeNode(now_val); q.emplace(q.front()-&gt;left); &#125; else &#123; q.front()-&gt;right = new TreeNode(now_val); q.emplace(q.front()-&gt;right); q.pop(); &#125; index++; &#125; return root; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec* ser = new Codec();// Codec* deser = new Codec();// string tree = ser-&gt;serialize(root);// TreeNode* ans = deser-&gt;deserialize(tree);// return ans;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"497-Random Point in Non-overlapping Rectangles","path":"/wiki/leetcode/497-Random Point in Non-overlapping Rectangles.html","content":"é¢˜æ„ ç»™å‡ºå¤šä¸ªåœ¨å¹³é¢ä¸Šä¸”ä¸ç›¸äº¤çš„å¤šä¸ªé•¿æ–¹å½¢ï¼Œè¦æ±‚ç­‰æ¦‚ç‡ä»è¿™äº›é•¿æ–¹å½¢èŒƒå›´å†…é€‰å‡ºä¸€ä¸ªç‚¹ï¼ˆåŒ…å«é•¿æ–¹å½¢çš„è¾¹ï¼‰ï¼Œè¿”å›ç‚¹çš„äºŒç»´åæ ‡ã€‚ é¢˜è§£ é¢˜ç›®ä¸­çš„é•¿æ–¹å½¢æ•°é‡å°äº100ï¼Œæ¯ä¸ªé•¿æ–¹å½¢é•¿å’Œå®½çš„é•¿åº¦ä¸å¤§äº2000ï¼Œæ‰€ä»¥æ¯ä¸ªé•¿æ–¹å½¢æœ€å¤šæœ‰ 2000Ã—2000=4e62000\\times2000=4e62000Ã—2000=4e6 ä¸ªç‚¹ï¼Œæ€»å…±æœ€å¤š 4e6Ã—100=4e84e6\\times 100 = 4e84e6Ã—100=4e8 ä¸ªç‚¹ã€‚æ‰€ä»¥é¦–å…ˆä¸ºæ¯ä¸ªç‚¹ç¼–å·ï¼Œç„¶åç­‰æ¦‚ç‡é€‰å–ä¸€ä¸ªç‚¹ï¼Œæ ¹æ®ç‚¹çš„ç¼–å·åˆ¤æ–­è¯¥ç‚¹åœ¨å“ªä¸ªé•¿æ–¹å½¢ä¸­ï¼Œç„¶åæ ¹æ®ç‚¹çš„ç¼–å·ä¸é•¿æ–¹å½¢å·¦ä¸‹è§’ç‚¹ç¼–å·çš„å·®è·è®¡ç®—åç§»ï¼Œç„¶åæ±‚å‡ºé€‰å–ç‚¹çš„åæ ‡ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; key; int maxn = 0; vector&lt;vector&lt;int&gt;&gt; rect; Solution(vector&lt;vector&lt;int&gt;&gt; &amp;rects) : rect(rects) &#123; for (auto &amp;x : rects) &#123; key.push_back(maxn); //Give points numbers maxn += (x[2] - x[0] + 1) * (x[3] - x[1] + 1); &#125; &#125; vector&lt;int&gt; pick() &#123; int now = rand() % maxn; int index = 0; while (index &lt; key.size() &amp;&amp; key[index] &lt;= now) index++; index--; // get which rectangle the point is in now -= key[index]; // calculate offset int len = rect[index][3] - rect[index][1] + 1; return &#123;rect[index][0] + now / len, rect[index][1] + now % len&#125;; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(rects); * vector&lt;int&gt; param_1 = obj-&gt;pick(); */#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"498-Diagonal Traverse","path":"/wiki/leetcode/498-Diagonal Traverse.html","content":"é¢˜æ„ æŒ‰å¯¹è§’çº¿éå†æ•°ç»„ã€‚ é¢˜è§£ åªæœ‰ä¸¤ç§æ–¹å‘ï¼Œä¸€ç§æ–œå‘ä¸Š x-1,y+1ï¼›ä¸€ç§æ–œå‘ä¸‹ x+1,y-1ã€‚å¯¹äºæ‹è§’å¤„ï¼Œæœ‰å‡ ç§æƒ…å†µã€‚ åœ¨å¯¹è§’å¤„æ”¹å˜æ–¹å‘ï¼Œè¿™æ—¶éœ€è¦æ ¹æ®åœ¨å·¦ä¸‹è§’è¿˜æ˜¯å³ä¸Šè§’çš„æƒ…å†µåšå‡ºä¸åŒå¤„ç†ã€‚ åœ¨å·¦è¾¹å’Œä¸Šé¢æ”¹å˜æ–¹å‘ï¼Œå·¦è¾¹å¯¹åº” y å°äº 0 ï¼Œä¸Šé¢å¯¹åº” x å°äº 0 ï¼Œè¿™æ—¶åªéœ€è¦å°† x æˆ– yé‡ç½®ä¸º0ï¼Œç„¶åæ”¹å˜æ–¹å‘ã€‚ åœ¨å³è¾¹å’Œä¸‹é¢æ”¹å˜æ–¹å‘ï¼Œå³è¾¹å¯¹åº” y ç­‰äº m ï¼Œä¸‹è¾¹å¯¹åº” x ç­‰äº nï¼Œè¿™æ˜¯é™¤äº†å°† y æ”¹å˜ä¸º m-1 ï¼Œæˆ–å°† x æ”¹å˜ä¸º n-1 ï¼Œè¿˜éœ€è¦å°†å¯¹åº” x åŠ  2æˆ–è€… y åŠ  2ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt; &amp;mat) &#123; int n = mat.size(); int m = mat[0].size(); vector&lt;int&gt; res; int dir = 1; int nowx = 0, nowy = 0; for (int i = 0; i &lt; m * n; i++) &#123; res.push_back(mat[nowx][nowy]); nowx -= dir, nowy += dir; if (nowx &lt; 0 &amp;&amp; nowy &gt;= m) &#123; nowx = 1; nowy = m - 1; dir = -1; &#125; else if (nowx &gt;= n &amp;&amp; nowy &lt; 0) &#123; nowx = n - 1; nowy = 1; dir = 1; &#125; else if (nowx &lt; 0) &#123; nowx = 0; dir = -1; &#125; else if (nowx &gt;= n) &#123; nowx = n - 1; nowy += 2; dir = 1; &#125; else if (nowy &lt; 0) &#123; nowy = 0; dir = 1; &#125; else if (nowy &gt;= m) &#123; nowy = m - 1; nowx += 2; dir = -1; &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"513-Find Bottom Left Tree Value","path":"/wiki/leetcode/513-Find Bottom Left Tree Value.html","content":"é¢˜æ„ æ‰¾åˆ°æ ‘ä¸­æœ€å·¦ä¸‹çš„èŠ‚ç‚¹ã€‚ é¢˜è§£ å±‚åºéå†æ ‘ï¼Œæ¯æ¬¡å–æ¯ä¸€å±‚æœ€å·¦è¾¹çš„èŠ‚ç‚¹ï¼Œæœ€åçš„å€¼å³ä¸ºæœ€å·¦ä¸‹çš„èŠ‚ç‚¹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123; public: int findBottomLeftValue(TreeNode *root) &#123; int res; queue&lt;TreeNode *&gt; q; q.push(root); while (!q.empty()) &#123; int len = q.size(); res = q.front()-&gt;val; while (len--) &#123; auto now = q.front(); q.pop(); if (now-&gt;left != nullptr) q.push(now-&gt;left); if (now-&gt;right != nullptr) q.push(now-&gt;right); &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"508-Most Frequent Subtree Sum","path":"/wiki/leetcode/508-Most Frequent Subtree Sum.html","content":"é¢˜æ„ æ±‚æ ‘ä¸­é¢‘ç‡æœ€é«˜çš„å­æ ‘å’Œçš„æ•°å­—ã€‚ é¢˜è§£ æ·±åº¦ä¼˜å…ˆæœç´¢æ ‘ï¼Œè¿”å›å½“å‰å­æ ‘å’Œï¼Œç„¶åæ›´æ–°å­æ ‘å’Œçš„é¢‘ç‡ï¼Œå¦‚æœå½“å‰å­æ ‘å’Œå¤§äºæœ€å¤§é¢‘ç‡ï¼Œåˆ™æ›´æ–°ç­”æ¡ˆã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution &#123; public: vector&lt;int&gt; res; int maxcnt = 0; unordered_map&lt;int, int&gt; mp; int dfs(TreeNode *now) &#123; if (now == nullptr) return 0; int l, r; l = dfs(now-&gt;left); r = dfs(now-&gt;right); int sum = now-&gt;val + l + r; mp[sum]++; if (mp[sum] &gt; maxcnt) &#123; maxcnt = mp[sum]; res.clear(); &#125; if (mp[sum] == maxcnt) &#123; res.push_back(sum); &#125; return sum; &#125; vector&lt;int&gt; findFrequentTreeSum(TreeNode *root) &#123; dfs(root); return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"646. Maximum Length of Pair Chain","path":"/wiki/leetcode/646. Maximum Length of Pair Chain.html","content":"é¢˜æ„ ç»™å®šä¸€ä¸ªæ•°å¯¹é›†åˆï¼Œæ‰¾å‡ºèƒ½å¤Ÿå½¢æˆçš„æœ€é•¿æ•°å¯¹é“¾çš„é•¿åº¦ã€‚ å½“ä¸”ä»…å½“Â b &lt; cÂ æ—¶ï¼Œæ•°å¯¹(c, d)Â æ‰å¯ä»¥è·Ÿåœ¨Â (a, b)Â åé¢ã€‚æˆ‘ä»¬ç”¨è¿™ç§å½¢å¼æ¥æ„é€ ä¸€ä¸ªæ•°å¯¹é“¾ã€‚ é¢˜è§£ ç±»ä¼¼æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼Œåˆ›å»ºä¸€ä¸ªæ•°ç»„ç»´æŠ¤æ¯ä¸€ä¸ªåºåˆ—é•¿åº¦å¯¹åº”çš„æœ€å°æœ«å°¾ã€‚å¯¹äºäºŒç»´æ•°å¯¹çš„æƒ…å†µï¼Œå¯ä»¥å…ˆå¯¹å…¶æŒ‰ç¬¬ä¸€ä¸ªå…ƒç´ æ’åºï¼Œç„¶åå¯¹ç¬¬äºŒä¸ªå…ƒç´ è¿›è¡Œdpã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#[allow(dead_code)]#[allow(unused_imports)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;impl Solution &#123; pub fn find_longest_chain(mut pairs: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 &#123; let mut key = vec![]; pairs.sort_unstable(); for x in pairs &#123; let (s, e) = (x[0], x[1]); let index = key.partition_point(|x| x &lt; &amp;s); let index = key.get_mut(index); match index &#123; Some(x) =&gt; *x = min(*x, e), _ =&gt; key.push(e), &#125; &#125; key.len() as i32 &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let temp = vec![vec![1, 2], vec![7, 8], vec![4, 5]]; println!(&quot;res:&#123;&#125;&quot;, Solution::find_longest_chain(temp));&#125;"},{"title":"713-Subarray Product Less Than K","path":"/wiki/leetcode/713-Subarray Product Less Than K.html","content":"é¢˜æ„ æ±‚æ•°åˆ—å­—ä¸²ç§¯å°äº k çš„å­—ä¸²ä¸ªæ•°ã€‚ é¢˜è§£ æšä¸¾å·¦èŠ‚ç‚¹ï¼Œå¯¹äºæ¯ä¸€ä¸ªå·¦èŠ‚ç‚¹ iï¼Œæ‰¾åˆ°æ»¡è¶³å­—ä¸²ç§¯å°äº k çš„æœ€é•¿å­—ä¸²çš„å³èŠ‚ç‚¹ highï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªå·¦èŠ‚ç‚¹æœ‰æ•ˆçš„å­—ä¸²ä¸ªæ•°ä¸º high - i +1ã€‚ å¯¹äºä¸¤ä¸ªå·¦èŠ‚ç‚¹ i,ji , ji,jã€‚ å¦‚æœ i&lt;ji&lt;ji&lt;jï¼Œé‚£ä¹ˆå®ƒä»¬çš„æœ€é•¿å³èŠ‚ç‚¹ä¸€å®šæœ‰ highi&lt;=highjhigh_i &lt;= high_jhighiâ€‹&lt;=highjâ€‹ ã€‚æšä¸¾å·¦èŠ‚ç‚¹æ—¶ high æ˜¯å•è°ƒé€’å¢çš„ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º O(n)O(n)O(n)ã€‚ 123456789101112131415161718192021222324252627282930313233#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int numSubarrayProductLessThanK(vector&lt;int&gt; &amp;nums, int k) &#123; int high = 0; int now = 1; int n = nums.size(); int res = 0; for (int i = 0; i &lt; n; i++) &#123; while (high &lt; n &amp;&amp; now * nums[high] &lt; k) &#123; now *= nums[high++]; &#125; if (high &gt; i) &#123; res += high - i; now /= nums[i]; &#125; else &#123; now = 1; high = i + 1; &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"827. Making A Large Island","path":"/wiki/leetcode/827. Making A Large Island.html","content":"é¢˜æ„ ç»™ä½ ä¸€ä¸ªå¤§å°ä¸ºn x näºŒè¿›åˆ¶çŸ©é˜µ grid ã€‚æœ€å¤šåªèƒ½å°†ä¸€æ ¼0å˜æˆ1 ã€‚ è¿”å›æ‰§è¡Œæ­¤æ“ä½œåï¼Œgrid ä¸­æœ€å¤§çš„å²›å±¿é¢ç§¯æ˜¯å¤šå°‘ï¼Ÿ å²›å±¿ç”±ä¸€ç»„ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ç›¸è¿çš„Â 1 å½¢æˆã€‚ é¢˜è§£ é¦–å…ˆ dfs æŸ“è‰²ï¼Œå¾—åˆ°æ¯ä¸ªé¢œè‰²çš„æ ¼å­æ•°é‡ã€‚ç„¶åæšä¸¾æ•´ä¸ªåœ°å›¾ï¼Œå¯¹äºæ¯ä¸€ä¸ªç‚¹ï¼Œéå†å®ƒçš„ä¸Šä¸‹å·¦å³çš„ç‚¹æ‰€åœ¨çš„é¢œè‰²åŒºåŸŸï¼Œæœ€åæ±‚å’Œå¾—åˆ°ç›¸è¿çš„åŒºåŸŸå¤§å°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;const DIR: [[i32; 2]; 4] = [[0, 1], [1, 0], [-1, 0], [0, -1]];fn dfs( color: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, vis: &amp;mut Vec&lt;Vec&lt;bool&gt;&gt;, cnt: &amp;mut HashMap&lt;i32, i32&gt;, grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, p: (usize, usize), nowc: i32,) &#123; color[p.0][p.1] = nowc; vis[p.0][p.1] = true; cnt.entry(nowc).and_modify(|c| *c += 1).or_insert(1); let n = grid.len() as i32; for x in DIR &#123; let nx = p.0 as i32 + x[0]; let ny = p.1 as i32 + x[1]; if nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; !vis[nx as usize][ny as usize] &amp;&amp; grid[nx as usize][ny as usize] == 1 &#123; dfs(color, vis, cnt, grid, (nx as usize, ny as usize), nowc); &#125; &#125;&#125;impl Solution &#123; pub fn largest_island(grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 &#123; let mut cnt = HashMap::&lt;i32, i32&gt;::new(); cnt.insert(0, 0); let mut res = 0; let mut color = vec![vec![0; grid[0].len()]; grid.len()]; let mut vis = vec![vec![false; grid[0].len()]; grid.len()]; let mut now = 1; let n = grid.len() as i32; for i in 0..grid.len() &#123; for j in 0..grid.len() &#123; if grid[i][j] == 1 &amp;&amp; !vis[i][j] &#123; dfs(&amp;mut color, &amp;mut vis, &amp;mut cnt, &amp;grid, (i, j), now); now += 1; &#125; &#125; &#125; for i in 0..grid.len() &#123; for j in 0..grid.len() &#123; let mut temp = HashSet::new(); for d in DIR &#123; let nx = i as i32 + d[0]; let ny = j as i32 + d[1]; if nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &#123; temp.insert(color[nx as usize][ny as usize]); &#125; &#125; let mut sum = 0; if grid[i][j] == 0 &#123; sum = 1; &#125; for x in &amp;temp &#123; sum += cnt.get(x).unwrap(); &#125; res = max(res, sum); &#125; &#125; res &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let a = vec![vec![0, 0], vec![1, 0]]; println!(&quot;res:&#123;&#125;&quot;, Solution::largest_island(a));&#125;"},{"title":"857. Minimum Cost to Hire K Workers","path":"/wiki/leetcode/857. Minimum Cost to Hire K Workers.html","content":"é¢˜æ„ æœ‰ nÂ åå·¥äººã€‚Â ç»™å®šä¸¤ä¸ªæ•°ç»„Â qualityÂ å’ŒÂ wageÂ ï¼Œå…¶ä¸­ï¼Œquality[i]Â è¡¨ç¤ºç¬¬Â iÂ åå·¥äººçš„å·¥ä½œè´¨é‡ï¼Œå…¶æœ€ä½æœŸæœ›å·¥èµ„ä¸ºÂ wage[i]Â ã€‚ ç°åœ¨æˆ‘ä»¬æƒ³é›‡ä½£Â kÂ åå·¥äººç»„æˆä¸€ä¸ªå·¥èµ„ç»„ã€‚åœ¨é›‡ä½£Â ä¸€ç»„ kÂ åå·¥äººæ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æŒ‰ç…§ä¸‹è¿°è§„åˆ™å‘ä»–ä»¬æ”¯ä»˜å·¥èµ„ï¼š å¯¹å·¥èµ„ç»„ä¸­çš„æ¯åå·¥äººï¼Œåº”å½“æŒ‰å…¶å·¥ä½œè´¨é‡ä¸åŒç»„å…¶ä»–å·¥äººçš„å·¥ä½œè´¨é‡çš„æ¯”ä¾‹æ¥æ”¯ä»˜å·¥èµ„ã€‚ å·¥èµ„ç»„ä¸­çš„æ¯åå·¥äººè‡³å°‘åº”å½“å¾—åˆ°ä»–ä»¬çš„æœ€ä½æœŸæœ›å·¥èµ„ã€‚ ç»™å®šæ•´æ•° k ï¼Œè¿”å› ç»„æˆæ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„ä»˜è´¹ç¾¤ä½“æ‰€éœ€çš„æœ€å°é‡‘é¢ é¢˜è§£ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;impl Solution &#123; pub fn mincost_to_hire_workers(quality: Vec&lt;i32&gt;, wage: Vec&lt;i32&gt;, k: i32) -&gt; f64 &#123; let mut key = quality .iter() .zip(wage.iter()) .map(|(&amp;x, &amp;y)| vec![x, y]) .collect::&lt;Vec&lt;_&gt;&gt;(); key.sort_unstable_by(|x, y| (x[1] * y[0]).cmp(&amp;(x[0] * y[1]))); let mut q = BinaryHeap::new(); let mut sum = 0; for i in 0..(k - 1) as usize &#123; q.push(key[i][0]); sum += key[i][0]; &#125; let mut res: f64 = 1000000000.0; for i in (k - 1) as usize..key.len() &#123; let temp = sum + key[i][0]; res = res.min(temp as f64 / key[i][0] as f64 * key[i][1] as f64); if let Some(x) = q.peek() &#123; if key[i][0] &lt; *x &#123; sum -= *x; q.pop(); q.push(key[i][0]); sum += key[i][0]; &#125; &#125; &#125; res &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let a = vec![3, 1, 10, 10, 1]; let b = vec![4, 8, 2, 2, 7]; println!(&quot;res:&#123;&#125;&quot;, Solution::mincost_to_hire_workers(a, b, 3));&#125;","tags":[null,null]},{"title":"890-Find and Replace Pattern","path":"/wiki/leetcode/890-Find and Replace Pattern.html","content":"é¢˜æ„ ç»™å®šä¸€ç»„ç›®æ ‡å­—ç¬¦ä¸²å’ŒåŸå­—ç¬¦ä¸²ï¼Œè§„å®šä¸€ç§å˜æ¢ï¼ŒåŸå­—ç¬¦ä¸²ä¸­æ‰€æœ‰ç›¸åŒçš„å­—æ¯å¯ä»¥å˜æ¢ä¸ºå¦ä¸€ç§å­—æ¯ã€‚é™åˆ¶ä¸ºæ¯ç§å­—æ¯åªèƒ½å˜æ¢ä¸€ç§å­—æ¯ï¼Œä¸åŒçš„å­—æ¯ä¸èƒ½å˜æ¢æˆç›¸åŒçš„å­—æ¯ã€‚å¦‚&quot;abb&quot;å¯ä»¥å˜æ¢ä¸º&quot;cdd&quot;ï¼Œä¸èƒ½å˜æ¢æˆ&quot;cde&quot;æˆ–&quot;ccc&quot;ã€‚ é¢˜è§£ éå†ç›®æ ‡å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼Œå¦‚æœé•¿åº¦å’ŒåŸå­—ç¬¦ä¸²ä¸ç›¸ç­‰ç›´æ¥è·³è¿‡ï¼Œç„¶åéå†åŸå­—ç¬¦ä¸²ï¼Œå¦‚æœå½“å‰å­—ç¬¦ä¸å­˜åœ¨æ˜ å°„ï¼Œå°±å¯¹åº”åˆ°ç›®æ ‡å­—ç¬¦ä¸²å¯¹åº”ä½ç½®çš„å­—ç¬¦ï¼Œå¦‚æœå­˜åœ¨æ˜ å°„ä½†ä¸å½“å‰å¯¹åº”ä½ç½®å­—ç¬¦ä¸ç›¸ç­‰ç›´æ¥è·³è¿‡ï¼Œå¦‚æœæœ‰å¤šä¸ªå­—ç¬¦å¯¹åº”åŒä¸€ä¸ªå­—ç¬¦ï¼Œè·³è¿‡å½“å‰çš„ç›®æ ‡å­—ç¬¦ä¸²ï¼Œå°†æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„ç›®æ ‡å­—ç¬¦ä¸²æ”¾å…¥ç­”æ¡ˆä¸­ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;string&gt; findAndReplacePattern(vector&lt;string&gt; &amp;words, string pattern) &#123; int key[30]; bool vis[30]; vector&lt;string&gt; res; for (auto &amp;x : words) &#123; if (x.size() != pattern.size()) continue; memset(key, 0, sizeof key); memset(vis, 0, sizeof vis); bool flag = 1; for (int i = 0; i &lt; pattern.size(); i++) &#123; if (key[pattern[i] - &#x27;a&#x27;] == 0) &#123; if (vis[x[i] - &#x27;a&#x27;]) &#123; flag = 0; break; &#125; vis[x[i] - &#x27;a&#x27;] = 1; key[pattern[i] - &#x27;a&#x27;] = x[i]; &#125; if (key[pattern[i] - &#x27;a&#x27;] != x[i]) &#123; flag = 0; break; &#125; &#125; if (flag) &#123; res.push_back(x); &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"926-Flip String to Monotone Increasing","path":"/wiki/leetcode/926-Flip String to Monotone Increasing.html","content":"é¢˜æ„ ç»™å®šä¸€ä¸²01ä¸²ï¼Œèƒ½å¤Ÿå¯¹å…¶æ¯ä¸€ä½è¿›è¡Œç¿»è½¬ï¼Œå³0å˜1ï¼Œ1å˜0ã€‚è¦æ±‚æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªä¸ä¸‹é™çš„01ä¸²ï¼Œä¾‹å¦‚000111111ï¼Œæ±‚æœ€å°ç¿»è½¬æ¬¡æ•°ã€‚ é¢˜è§£ ä½¿ç”¨å‰ç¼€å’Œç»Ÿè®¡æ¯ä¸€ä½å·¦è¾¹0å’Œ1ï¼Œå’Œå³è¾¹0å’Œ1çš„ä¸ªæ•°ï¼Œæšä¸¾æ¯ä¸€ä½ i ä½œä¸º0åˆ°1ä¸Šå‡çš„è¾¹ç¼˜ã€‚i å·¦è¾¹å…¨ä¸º0ï¼Œå³è¾¹å…¨ä¸º1ï¼Œæ‰€ä»¥ç¿»è½¬æ¬¡æ•°ä¸º i å·¦è¾¹1çš„ä¸ªæ•°åŠ ä¸Š i å³è¾¹0çš„ä¸ªæ•°ï¼Œæœ€åæ±‚å‡ºæœ€å°å€¼ã€‚ 123456789101112131415161718192021222324252627282930313233343536#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int key0[100005], key1[100005]; int minFlipsMonoIncr(string s) &#123; int cnt0 = 0; int index = 0; for (auto &amp;x : s) &#123; key0[index + 1] += key0[index], key1[index + 1] += key1[index]; if (x == &#x27;0&#x27;) &#123; cnt0++; key0[index + 1]++; &#125; else &#123; key1[index + 1]++; &#125; index++; &#125; int res = INT_MAX; for (int i = 0; i &lt;= s.size(); i++) &#123; res = min(res, key1[i] + cnt0 - key0[i]); &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"933-Number of Recent Calls","path":"/wiki/leetcode/933-Number of Recent Calls.html","content":"é¢˜æ„ æµå¼è¾“å…¥æ—¶é—´æˆ³ä¸º t çš„è¯·æ±‚ï¼Œå¯¹äºæ¯ä¸€æ¬¡è¾“å…¥ï¼Œè¿”å› [t-3000,t] å†…è¯·æ±‚çš„ä¸ªæ•°ã€‚ é¢˜è§£ ä½¿ç”¨é˜Ÿåˆ—ç»´æŠ¤ï¼Œå°†å°äº t-3000 çš„æ•°å‡ºé˜Ÿï¼Œå†å°† t å…¥é˜Ÿï¼Œè¿”å›å½“å‰é˜Ÿåˆ—å…ƒç´ ä¸ªæ•°ã€‚ 1234567891011121314151617181920212223242526272829303132#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class RecentCounter &#123; public: queue&lt;int&gt; q; RecentCounter() &#123; &#125; int ping(int t) &#123; int low = t - 3000; while (!q.empty() &amp;&amp; low &gt; q.front()) &#123; q.pop(); &#125; q.push(t); return q.size(); &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj-&gt;ping(t); */#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"937-Reorder Data in Log Files","path":"/wiki/leetcode/937-Reorder Data in Log Files.html","content":"é¢˜æ„ ç»™å®šå­—ç¬¦ä¸²æ•°ç»„ï¼ŒæŒ‰è§„åˆ™å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œè§„åˆ™å¦‚ä¸‹ï¼š æ¯ä¸ªå­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå•è¯ä¸ºé”®ï¼Œåé¢çš„ä¸ºæ•°æ®ï¼Œå­˜åœ¨ä¸¤ç§æ•°æ®ï¼Œä¸€ç§åªåŒ…å«å°å†™å­—æ¯ï¼Œä¸€ç§åªåŒ…å«æ•°å­—ã€‚ æ‰€æœ‰å°å†™å­—æ¯æ•°æ®åœ¨æ•°å­—æ•°æ®å‰é¢ã€‚ å¯¹äºå°å†™å­—æ¯æ•°æ®ï¼ŒæŒ‰ç…§å­—å…¸åºè¿›è¡Œæ’åºï¼Œå¦‚æœæ•°æ®ç›¸åŒï¼ŒæŒ‰ç…§é”®çš„å­—å…¸åºæ’åºã€‚ å¯¹äºæ•°å­—æ•°æ®ï¼Œä¿æŒé¡ºåºå’ŒåŸæ•°ç»„ç›¸å¯¹é¡ºåºç›¸åŒå³å¯ã€‚ é¢˜è§£ æŒ‰ç…§è§„åˆ™æ¨¡æ‹Ÿå³å¯ 1234567891011121314151617181920212223242526272829303132333435363738394041#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt; &amp;logs) &#123; vector&lt;int&gt; dig; vector&lt;pair&lt;string, string&gt;&gt; word; for (int i = 0; i &lt; logs.size(); i++) &#123; int now = 0; string key = &quot;&quot;; while (logs[i][now] != &#x27; &#x27;) key += logs[i][now], now++; if (logs[i][now + 1] &gt;= &#x27;0&#x27; &amp;&amp; logs[i][now + 1] &lt;= &#x27;9&#x27;) &#123; dig.push_back(i); &#125; else &#123; word.emplace_back(key, logs[i].substr(now)); &#125; &#125; sort(word.begin(), word.end(), [](const auto &amp;x, const auto &amp;y) &#123; if (x.second == y.second) return x.first &lt; y.first; return x.second &lt; y.second; &#125;); vector&lt;string&gt; res; for (auto &amp;x : word) &#123; res.emplace_back(x.first + x.second); &#125; for (auto &amp;x : dig) res.push_back((logs[x])); return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"942-DI String Match","path":"/wiki/leetcode/942-DI String Match.html","content":"é¢˜æ„ ç»™å‡ºä¸€ç»„å­—ç¬¦ä¸²ï¼Œç”± â€˜Dâ€™ å’Œ â€˜Iâ€™ ç»„æˆã€‚è¿™ä¸ªå­—ç¬¦ä¸²å¯¹åº”ç€ä¸€ä¸ªç”±å…ƒç´ èŒƒå›´ä¸º [0,n] æ— é‡æ•°ç»„çš„å…³ç³»ï¼š å½“ s[i] == â€˜Iâ€™, a[i] &lt; a[i+1]ã€‚ å½“ s[i] == â€˜Dâ€™, a[i] &gt; a[i+1]ã€‚ ä¸¾ä¾‹ï¼š [3, 2, 0 ,1] å¯¹åº”çš„å­—ç¬¦ä¸²ä¸º â€˜DDIâ€™ã€‚ ç»™å‡ºå…³ç³»ï¼Œè¦æ±‚è¿˜åŸä»»æ„ç¬¦åˆè¦æ±‚çš„æ•°ç»„ã€‚ é¢˜è§£ è´ªå¿ƒåœ°æ„é€ æ•°ç»„ï¼Œè®¾ç½®å½“å‰æœ€å¤§å€¼å’Œå½“å‰æœ€å°å€¼ï¼Œå½“å‰å­—ç¬¦ä¸º â€˜Iâ€™ æ—¶ï¼Œæ’å…¥å½“å‰æœ€å°å€¼ï¼Œæœ€å°å€¼åŠ 1ï¼Œå­—ç¬¦ä¸º â€˜Dâ€™ æ—¶ç±»ä¼¼ã€‚ ä¸Šé¢è¿‡ç¨‹ä¿è¯äº†æ„é€ çš„æ•°ç»„å…ƒç´ å…³ç³»ç¬¦åˆç»™å‡ºçš„å­—ç¬¦ä¸²ã€‚ 1234567891011121314151617181920212223242526#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; diStringMatch(string s) &#123; int low = 0, high = s.size(); vector&lt;int&gt; res; for (auto &amp;x : s) &#123; if (x == &#x27;I&#x27;) res.emplace_back(low++); else res.emplace_back(high--); &#125; res.emplace_back(low); return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"one way lcci","path":"/wiki/leetcode/one way lcci.html","content":"é¢˜æ„ ç»™å‡ºåŸå­—ç¬¦ä¸²å’Œç›®æ ‡å­—ç¬¦ä¸²ï¼Œæœ‰ä¸‰ç§æ“ä½œï¼š åŸå­—ç¬¦ä¸²æ”¹å˜ä¸€ä¸ªå­—ç¬¦ã€‚ åŸå­—ç¬¦ä¸²åˆ é™¤ä¸€ä¸ªå­—ç¬¦ã€‚ åŸå­—ç¬¦ä¸²æ·»åŠ ä¸€ä¸ªå­—ç¬¦ã€‚ æœ€å¤šå¯ä»¥åšä¸€æ¬¡æ“ä½œï¼Œé—®èƒ½å¦å°†åŸå­—ç¬¦ä¸²å˜ä¸ºç›®æ ‡å­—ç¬¦ä¸²ã€‚ é¢˜è§£ é¦–å…ˆåŸå­—ç¬¦ä¸²æ·»åŠ ä¸€ä¸ªå­—ç¬¦ä¸²ç›¸å½“äºç›®æ ‡å­—ç¬¦ä¸²åˆ é™¤ä¸€ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥å½“åŸå­—ç¬¦ä¸²çš„é•¿åº¦å°äºç›®æ ‡å­—ç¬¦ä¸²æ—¶äº¤æ¢ä¸€ä¸‹åŸå­—ç¬¦ä¸²å’Œç›®æ ‡å­—ç¬¦ä¸²å³å¯ï¼Œæ‰€ä»¥åªå‰©ä¸‹ä¸¤ç§æ“ä½œéœ€è¦è®¨è®ºã€‚ åŸå­—ç¬¦ä¸²æ”¹å˜ä¸€ä¸ªå­—ç¬¦ï¼š é¦–å…ˆåŸå­—ç¬¦ä¸²å’Œç›®æ ‡å­—ç¬¦ä¸²é•¿åº¦å¿…é¡»ç›¸ç­‰ï¼Œç„¶åéå†ä¸€ä¸‹ï¼Œå¦‚æœä¸åŒçš„å­—ç¬¦è¶…è¿‡ä¸€ä¸ªè¯´æ˜ä¸èƒ½æ”¹å˜ã€‚ åŸå­—ç¬¦ä¸²åˆ é™¤ä¸€ä¸ªå­—ç¬¦ï¼š éå†å­—ç¬¦ä¸²ï¼Œå¦‚æœä¸ç›¸ç­‰å°±è·³è¿‡ï¼Œéœ€è¦åˆ é™¤è¿™ä¸ªå­—ç¬¦ï¼Œå¦‚æœå‡ºç°ä¸¤æ¬¡ä¸åŒçš„æƒ…å†µï¼Œè¯´æ˜ä¸èƒ½æ”¹å˜ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: bool oneEditAway(string first, string second) &#123; if (first == second) return true; if (abs((int)first.size() - (int)second.size()) &gt; 1) return false; if (first.size() == second.size()) &#123; int cnt = 0; for (int i = 0; i &lt; first.size(); i++) &#123; if (first[i] != second[i]) &#123; cnt++; if (cnt &gt; 1) return false; &#125; &#125; &#125; else &#123; if (first.size() &lt; second.size()) swap(first, second); bool flag = 0; int now = second.size() - 1; for (int i = first.size() - 1; i &gt;= 0; i--) &#123; if (now == -1 &amp;&amp; i == 0) return true; if (first[i] != second[now]) &#123; if (flag) return false; flag = 1; &#125; else now--; &#125; &#125; return true; &#125;&#125;;"},{"title":"é¢è¯•é¢˜ 17.19. Missing Two LCCI","path":"/wiki/leetcode/é¢è¯•é¢˜ 17.19. Missing Two LCCI.html","content":"é¢˜æ„ You are given an array with all the numbers from 1 to N appearing exactly once, except for two number that is missing. How can you find the missing number in O(N) time and 0(1) space? é¢˜è§£ åŸåœ°å“ˆå¸Œ æ•°å­¦ ä½è¿ç®— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;// impl Solution &#123;// pub fn missing_two(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;// nums.push(-1);// nums.push(-1);// let mut res = vec![];// for i in 0..nums.len() &#123;// while nums[i] != -1 &amp;&amp; nums[i] - 1 != i as i32 &#123;// let temp = nums[i] as usize - 1;// nums.swap(i, temp);// &#125;// &#125;// for i in 0..nums.len() &#123;// if nums[i] == -1 &#123;// res.push(i as i32 + 1);// &#125;// &#125;// res// &#125;// &#125;// impl Solution &#123;// pub fn missing_two(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;// let sum = nums.iter().sum::&lt;i32&gt;();// let n = nums.len() as i32 + 2;// let sum_two = n * (n + 1) / 2 - sum;// let key = sum_two / 2;// let sum_low = nums.iter().filter(|&amp;&amp;x| x &lt;= key).sum::&lt;i32&gt;();// let one = key * (key + 1) / 2 - sum_low;// // println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, sum_two, sum_low, sum);// vec![one, sum_two - one]// &#125;// &#125;impl Solution &#123; pub fn missing_two(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123; let nums = &amp;nums; let n = nums.len() as i32 + 2; let mut key = 0; (1..=n).into_iter().for_each(|x| key ^= x); nums.into_iter().for_each(|x| key ^= x); let diff = key &amp; -key; let mut one = 0; (1..=n).into_iter().for_each(|x| &#123; if x &amp; diff != 0 &#123; one ^= x &#125; &#125;); nums.into_iter().for_each(|x| &#123; if x &amp; diff != 0 &#123; one ^= x &#125; &#125;); vec![one, key ^ one] &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; println!(&quot;res:&#123;:?&#125;&quot;, Solution::missing_two(vec![1]));&#125;","tags":[null,null,null]},{"title":"ç›®å½•","path":"/wiki/rust_code/index.html","content":"rust æºç åˆ†æ (1) æ¦‚è¿° rust æºç åˆ†æ (2)-core-å†…å­˜æ¨¡å— rust æºç åˆ†æ (3)-std-allocæ¨¡å— rust æºç åˆ†æ (4)-std-backtraceæ¨¡å— rust æºç åˆ†æ (5)-std-collection rust æºç åˆ†æ (6)-std-collection-HashMap","tags":[null]},{"title":"rust æºç åˆ†æ (1): æ¦‚è¿°","path":"/wiki/rust_code/rust æºç åˆ†æ (1) æ¦‚è¿°.html","content":"rust æºç ç‰ˆæœ¬: 1.72.0 rust æºç ç»“æ„ ä»£ç ç»“æ„å¦‚ä¸‹ 123456789101112131415161718192021222324.â”œâ”€â”€ Cargo.lockâ”œâ”€â”€ Cargo.tomlâ”œâ”€â”€ CODE_OF_CONDUCT.mdâ”œâ”€â”€ compilerâ”œâ”€â”€ config.example.tomlâ”œâ”€â”€ configureâ”œâ”€â”€ CONTRIBUTING.mdâ”œâ”€â”€ COPYRIGHTâ”œâ”€â”€ libraryâ”œâ”€â”€ LICENSE-APACHEâ”œâ”€â”€ LICENSE-MITâ”œâ”€â”€ LICENSESâ”œâ”€â”€ README.mdâ”œâ”€â”€ RELEASES.mdâ”œâ”€â”€ rustfmt.tomlâ”œâ”€â”€ rust-toolchainâ”œâ”€â”€ srcâ”œâ”€â”€ targetâ”œâ”€â”€ testsâ”œâ”€â”€ triagebot.tomlâ”œâ”€â”€ xâ”œâ”€â”€ x.ps1â””â”€â”€ x.py å…¶ä¸­éœ€è¦å…³æ³¨çš„æ˜¯ compiler ã€library ã€src è¿™ä¸‰ä¸ªæ–‡ä»¶å¤¹ã€‚ compiler æ–‡ä»¶å¤¹åŒ…å«äº† rust çš„ç¼–è¯‘å™¨æºä»£ç ï¼Œè¿™é‡Œçš„ä»£ç å®ç°äº† Rust è¯­è¨€çš„è¯­æ³•åˆ†æã€ç±»å‹æ£€æŸ¥ã€ä»£ç ä¼˜åŒ–å’Œä»£ç ç”Ÿæˆç­‰åŠŸèƒ½ã€‚ library åŒ…å«äº†æ ‡å‡†åº“çš„æºä»£ç ï¼Œæä¾›äº†è®¸å¤šå¸¸ç”¨çš„æ•°æ®ç»“æ„ã€å‡½æ•°å’Œç‰¹æ€§ã€‚ src æ–‡ä»¶å¤¹ä¸­çš„ README è¯´æ˜äº†è¯¥æ–‡ä»¶å¤¹çš„ç”¨é€”ï¼Œé‡Œé¢åŒ…å«äº† æ„å»ºç³»ç»Ÿã€rustdocã€cargo ç­‰å·¥å…·çš„æºç ã€‚ This directory contains some source code for the Rust project, including: The bootstrapping build system Various submodules for tools, like cargo, tidy, etc. rust æ ‡å‡†åº“ å‚è€ƒ std - Rust library é‡ŒåŒ…å«ä¸¤ä¸ªå…³é”®çš„æ–‡ä»¶å¤¹ core ã€std ï¼Œå¯ä»¥å‘ç°ä»–ä»¬å¯¼å‡ºçš„æ¨¡å—æœ‰éƒ¨åˆ†é‡å ï¼Œä¸‹é¢æ˜¯ä»–ä»¬çš„ä¸€äº›å…³é”®åŒºåˆ«ã€‚ Core æ¨¡å— (core)ï¼š core æ¨¡å—æ˜¯ Rust çš„æ ¸å¿ƒæ ‡å‡†åº“ï¼Œå®ƒåŒ…å«äº† Rust è¯­è¨€çš„åŸºæœ¬æ„å»ºå—å’Œæœ€åŸºæœ¬çš„æ•°æ®ç±»å‹ã€‚ è¿™ä¸ªæ¨¡å—æ˜¯æ— ä¾èµ–çš„ï¼Œæ„å‘³ç€å®ƒä¸ä¾èµ–äºæ“ä½œç³»ç»Ÿæˆ–å¤–éƒ¨åº“ã€‚è¿™ä½¿å¾— Rust çš„æ ¸å¿ƒåŠŸèƒ½å¯ä»¥åœ¨å„ç§å¹³å°ä¸Šä½¿ç”¨ã€‚ core æ¨¡å—ä¸­çš„åŠŸèƒ½é€šå¸¸è¢«è®¤ä¸ºæ˜¯â€œæ— æ ‡å‡†åº“â€ç¯å¢ƒä¸‹çš„ Rustï¼Œå› ä¸ºå®ƒä¸åŒ…æ‹¬ä¸æ“ä½œç³»ç»Ÿäº¤äº’ã€æ–‡ä»¶ I/O ç­‰é«˜çº§åŠŸèƒ½ã€‚ è¯¥æ¨¡å—é€šå¸¸ç”¨äºç¼–å†™åµŒå…¥å¼ç³»ç»Ÿã€æ“ä½œç³»ç»Ÿå†…æ ¸ã€WebAssembly ç­‰ä¸éœ€è¦æ ‡å‡†åº“çš„ç¯å¢ƒä¸­çš„ä»£ç ã€‚ Std æ¨¡å— (std)ï¼š std æ¨¡å—æ˜¯ Rust çš„æ ‡å‡†åº“ï¼Œå®ƒæ„å»ºåœ¨ core æ¨¡å—ä¹‹ä¸Šï¼Œå¹¶æä¾›äº†æ›´å¤šçš„åŠŸèƒ½å’ŒåŠŸèƒ½æ€§ã€‚ è¿™ä¸ªæ¨¡å—ä¾èµ–äºæ“ä½œç³»ç»Ÿå’Œå¤–éƒ¨åº“ï¼Œå› æ­¤åŒ…æ‹¬ä¸æ–‡ä»¶ç³»ç»Ÿã€å¤šçº¿ç¨‹ã€ç½‘ç»œç¼–ç¨‹ã€è¾“å…¥è¾“å‡ºç­‰ç›¸å…³çš„åŠŸèƒ½ã€‚ std æ¨¡å—é€šå¸¸ç”¨äºç¼–å†™å¤§å¤šæ•° Rust åº”ç”¨ç¨‹åºï¼ŒåŒ…æ‹¬å‘½ä»¤è¡Œå·¥å…·ã€ç½‘ç»œæœåŠ¡å™¨ã€æ¡Œé¢åº”ç”¨ç¨‹åºç­‰ã€‚ å®ƒæä¾›äº†æ ‡å‡†çš„ Rust æŠ½è±¡å’Œç±»å‹ï¼Œå¦‚ Vecã€Stringã€HashMap ç­‰ã€‚ æ€»ä¹‹ï¼Œ core æ˜¯ Rust çš„æ ¸å¿ƒæ ‡å‡†åº“ï¼Œæä¾›äº†åŸºæœ¬çš„ Rust è¯­è¨€æ„å»ºå—ï¼Œè€Œ std æ˜¯æ„å»ºåœ¨ core ä¹‹ä¸Šçš„æ ‡å‡†åº“ï¼Œæä¾›äº†æ›´å¤šçš„é«˜çº§åŠŸèƒ½å’Œä¸å¤–éƒ¨ç¯å¢ƒçš„äº¤äº’ã€‚ rust ç¼–è¯‘å™¨ #todo [ ] ç¼–è¯‘å™¨ rust ç›¸å…³å·¥ç¨‹ #todo [ ] rust project","tags":[null]},{"title":"rust æºç åˆ†æ (2)-core: å†…å­˜æ¨¡å—","path":"/wiki/rust_code/rust æºç åˆ†æ (2)-core-å†…å­˜æ¨¡å—.html","content":"rust æºç ç‰ˆæœ¬: 1.72.0 æ¦‚è¿° rust æŒ‡é’ˆ æ–‡ä»¶ä½ç½®: library/core/src/ptr æ–‡ä»¶ç»“æ„ 12345678./â”œâ”€â”€ alignment.rsâ”œâ”€â”€ const_ptr.rsâ”œâ”€â”€ metadata.rsâ”œâ”€â”€ mod.rsâ”œâ”€â”€ mut_ptr.rsâ”œâ”€â”€ non_null.rsâ””â”€â”€ unique.rs mod metadata #todo [ ] å¤ªæŠ½è±¡äº†ï¼Œè¿˜æ˜¯çœ‹çœ‹è¿œæ–¹çš„stdåº“å§","tags":[null]},{"title":"rust æºç åˆ†æ (3)-std-allocæ¨¡å—","path":"/wiki/rust_code/rust æºç åˆ†æ (3)-std-allocæ¨¡å—.html","content":"rust æºç ç‰ˆæœ¬: 1.72.0 æ–‡ä»¶ä½ç½® library/std/src/alloc.rs","tags":[null]},{"title":"rust æºç åˆ†æ (4)-std-backtraceæ¨¡å—","path":"/wiki/rust_code/rust æºç åˆ†æ (4)-std-backtraceæ¨¡å—.html","content":"rust æºç ç‰ˆæœ¬: 1.72.0","tags":[null]},{"title":"rust æºç åˆ†æ (5)-std-collection","path":"/wiki/rust_code/rust æºç åˆ†æ (5)-std-collection.html","content":"rust æºç ç‰ˆæœ¬: 1.72.0 æ–‡ä»¶ä½ç½® library/std/src/collections/mod.rs ä»‹ç» å‚è€ƒ std::collections - Rust rust æ ‡å‡†åº“å®ç°äº†ä¸€äº›å¸¸è§çš„æ•°æ®ç»“æ„: æ•°ç»„ Vec åŒç«¯æ•°ç»„ VecDeque é“¾è¡¨ LinkedList å“ˆå¸Œmap HashMap æŒ‰é”®æ’åºmap BTreeMap å“ˆå¸Œset HashSet æŒ‰é”®æ’åºset BTreeSet ä¼˜å…ˆé˜Ÿåˆ— BinaryHeap Tips Performance Sequences : get(i) insert(i) remove(i) append split_off(i) [Vec] O(1) O(n-i)* O(n-i) O(m)* O(n-i) [VecDeque] O(1) O(min(i, n-i))* O(min(i, n-i)) O(m)* O(min(i, n-i)) [LinkedList] O(min(i, n-i)) O(min(i, n-i)) O(min(i, n-i)) O(1) O(min(i, n-i)) Map : get insert remove range append [HashMap] O(1)~ O(1)~* O(1)~ N/A N/A [BTreeMap] O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(n+m) å…¶ä¸­å¸¦ * çš„ä¸ºå‡æ‘Šå¤æ‚åº¦ï¼Œå¸¦ ~ ä¸ºæœŸæœ›å¤æ‚åº¦ã€‚ Capacity Management ä½¿ç”¨ with_capacity æ–¹æ³•é¢„å…ˆåˆ†é…å®¹å™¨å†…å­˜ã€‚ ä½¿ç”¨ reserve æ–¹æ³•æ‰©å®¹ã€‚ ä½¿ç”¨ shrink_to_fit ç¼©å®¹ã€‚ Iterators é€šå¸¸ç”¨ iter ã€ iter_mut ã€into_iter è¿­ä»£å®¹å™¨ã€‚","tags":[null]},{"title":"rust æºç åˆ†æ (6)-std-collection-HashMap","path":"/wiki/rust_code/rust æºç åˆ†æ (6)-std-collection-HashMap.html","content":"rust æºç ç‰ˆæœ¬: 1.78.0 æ–‡ä»¶ä½ç½® library/std/src/collections/hash/map.rs HashMap å’Œ HashSet ä½äº std åº“ä¸­ï¼Œ è€Œå…¶ä½™çš„å®¹å™¨åˆ™åœ¨ alloc åº“ä¸­ï¼Œç”± std åº“é‡å¯¼å‡ºã€‚ åŸå› å‚è€ƒ Move HashMap to liballoc Â· Issue #27242 Â· rust-lang/rust Â· GitHub hashbrown itself isÂ #[no_std]Â since it uses a non-HashDOS-safe hasher. The std shim is what adds the SipHash hasher which depends on randomness and TLS. å¯èƒ½æ˜¯å“ˆå¸Œçš„å®ç°æ–¹æ³•ä¾èµ–äºç³»ç»Ÿçš„éšæœºæ•°å‘ç”Ÿå™¨ï¼Œæ‰€ä»¥ HashMap å’Œ HashSet éœ€è¦æ”¾åˆ° std åº“ä¸­ã€‚ å®ç° type 123pub struct HashMap&lt;K, V, S = RandomState&gt; &#123; base: base::HashMap&lt;K, V, S&gt;,&#125; å…¶ä¸­ Kã€V ã€S åˆ†åˆ«è¡¨ç¤ºé”®ç±»å‹ã€å€¼ç±»å‹å’Œå“ˆå¸Œå‡½æ•°ã€‚std çš„ hashMap å®é™…ä¸Šçš„åº•å±‚å®ç°å®é™…ä¸Šæ˜¯ GitHub - rust-lang/hashbrown ã€‚ ç”±äº hashMap å†…åŸºæœ¬ä¸º hashbrown çš„å°è£…ï¼Œæ‰€ä»¥å…¶ä¸­çš„å¸¸è§„å‡½æ•°å’Œè¿­ä»£å™¨å°±çœç•¥ä¸è®²ï¼Œä¸‹é¢è®²ä¸€ä¸‹å…¶ä¸­æœ‰è¶£çš„åœ°æ–¹ã€‚ issue HashMapçš„é»˜è®¤å“ˆå¸Œå‡½æ•°ä¸º SipHash ï¼Œç”¨çš„æ˜¯ SipHash-1-3 ã€‚ ä¸‹é¢è¿™è¿™æ®µä»£ç æ¥è‡ª rust/library/std/src/hash/random.rsï¼Œä¸ºé»˜è®¤å“ˆå¸Œå‡½æ•°çš„å®ç°ã€‚ 12345678910111213141516171819202122pub fn new() -&gt; RandomState &#123; // Historically this function did not cache keys from the OS and instead // simply always called `rand::thread_rng().gen()` twice. In #31356 it // was discovered, however, that because we re-seed the thread-local RNG // from the OS periodically that this can cause excessive slowdown when // many hash maps are created on a thread. To solve this performance // trap we cache the first set of randomly generated keys per-thread. // // Later in #36481 it was discovered that exposing a deterministic // iteration order allows a form of DOS attack. To counter that we // increment one of the seeds on every RandomState creation, giving // every corresponding HashMap a different iteration order. thread_local!(static KEYS: Cell&lt;(u64, u64)&gt; = &#123; Cell::new(sys::hashmap_random_keys()) &#125;); KEYS.with(|keys| &#123; let (k0, k1) = keys.get(); keys.set((k0.wrapping_add(1), k1)); RandomState &#123; k0, k1 &#125; &#125;)&#125; å“ˆå¸Œå‡½æ•°å‚æ•°çš„åˆå§‹åŒ–ä»æ³¨é‡Šä¸­èƒ½çœ‹å‡ºæœ‰ç‚¹è¯´æ³•ï¼Œæœ€åˆå‚æ•°æ˜¯åœ¨åˆå§‹åŒ–éšæœºæ•°ç”Ÿæˆå™¨åï¼Œè°ƒç”¨ä¸¤æ¬¡éšæœºæ•°ç”Ÿæˆå™¨åˆ†åˆ«ç”Ÿæˆk0ï¼Œk1 ä¸¤ä¸ªå‚æ•°ï¼Œæœ€åˆçš„ä»£ç ä¸º: 1234 pub fn new() -&gt; RandomState &#123; let mut r = rand::thread_rng(); RandomState &#123; k0: r.gen(), k1: r.gen() &#125;&#125; rand ä»£ç ä½äº rust/src/libstd/rand/mod.rs randomState ä»£ç ä½äº rust/src/libstd/collections/hash/map.rs åœ¨ #27243 å’Œ #31356 ä¸­æå‡ºï¼Œæ¯ä¸ªçº¿ç¨‹ä½¿ç”¨å›ºå®šçš„éšæœºæ•°ç§å­å¯¹äºåˆå§‹åŒ–é€Ÿåº¦æœ‰æ˜¾è‘—çš„æå‡(64å€)ï¼Œæœ€ç»ˆåœ¨ #33318 ä¸­è¿™ä¸ªæ”¹åŠ¨è¢«åˆå…¥ï¼Œä»£ç ä¸º: 1234567891011pub fn new() -&gt; RandomState &#123; thread_local!(static KEYS: (u64, u64) = &#123; let r = rand::OsRng::new(); let mut r = r.expect(&quot;failed to create an OS RNG&quot;); (r.gen(), r.gen()) &#125;); KEYS.with(|&amp;(k0, k1)| &#123; RandomState &#123; k0: k0, k1: k1 &#125; &#125;)&#125; è¿™ä¸ª mr çš„åšæ³•ä¸ºä¸ºæ¯ä¸ªçº¿ç¨‹ç”Ÿæˆä¸¤ä¸ªéšæœºç§å­ï¼Œä¹‹åçš„åŒä¸€çº¿ç¨‹åˆå§‹åŒ–çš„ HashMap éƒ½ä½¿ç”¨å›ºå®šçš„éšæœºç§å­(è¿™ä¸ªæ“ä½œæœ‰ç‚¹éªšæ°”)ã€‚ç„¶ååœ¨ #36481 ä¸­æ½œåœ¨çš„é—®é¢˜è¢«é€®ä½äº†ï¼Œè¿™ç§åšæ³•ä¼šè¢« Hash DoS attackã€‚å…·ä½“æ˜¯è¿™æ ·çš„ ç”±äºæ¯ä¸ªçº¿ç¨‹ä¸­åˆ›å»ºçš„ hashMap ä½¿ç”¨åŒä¸€ä¸ªéšæœºç§å­ï¼Œè€ƒè™‘å¦‚ä¸‹ä»£ç  1234let first_map: HashMap&lt;u64, _&gt; = (0..900000).map(|i| (i, ())).collect();let second_map: HashMap&lt;u64, _&gt; = (900000..1800000).map(|i| (i, ())).collect();let mut merged = first_map;merged.extend(second_map); ä¿®å¤: #38368 #37470 variance ä¸ºäº†è®©ç”Ÿå‘½å‘¨æœŸæ›´ä¸ºæ™ºèƒ½ï¼Œ rust å¼•å…¥äº†å­ç±»å‹å’Œå˜å¼‚æ€§(subtypingÂ andÂ variance)ï¼Œå…·ä½“æ¥è¯´å¯ä»¥å‚è€ƒä»¥ä¸‹ä¸¤ä¸ªé“¾æ¥ã€‚ å­ç±»å‹åŒ–å’Œå˜å¼‚æ€§ - Rust ç§˜å…¸ï¼ˆæ­»çµä¹¦ï¼‰ Subtyping and Variance - The Rustonomicon å¯ä»¥çœ‹å‡º HashMap çš„å„ç§è¿­ä»£å™¨å¯¹äºç”Ÿå‘½å‘¨æœŸæ˜¯åå˜çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637fn assert_covariance() &#123; fn map_key&lt;&#x27;new&gt;(v: HashMap&lt;&amp;&#x27;static str, u8&gt;) -&gt; HashMap&lt;&amp;&#x27;new str, u8&gt; &#123; v &#125; fn map_val&lt;&#x27;new&gt;(v: HashMap&lt;u8, &amp;&#x27;static str&gt;) -&gt; HashMap&lt;u8, &amp;&#x27;new str&gt; &#123; v &#125; fn iter_key&lt;&#x27;a, &#x27;new&gt;(v: Iter&lt;&#x27;a, &amp;&#x27;static str, u8&gt;) -&gt; Iter&lt;&#x27;a, &amp;&#x27;new str, u8&gt; &#123; v &#125; fn iter_val&lt;&#x27;a, &#x27;new&gt;(v: Iter&lt;&#x27;a, u8, &amp;&#x27;static str&gt;) -&gt; Iter&lt;&#x27;a, u8, &amp;&#x27;new str&gt; &#123; v &#125; fn into_iter_key&lt;&#x27;new&gt;(v: IntoIter&lt;&amp;&#x27;static str, u8&gt;) -&gt; IntoIter&lt;&amp;&#x27;new str, u8&gt; &#123; v &#125; fn into_iter_val&lt;&#x27;new&gt;(v: IntoIter&lt;u8, &amp;&#x27;static str&gt;) -&gt; IntoIter&lt;u8, &amp;&#x27;new str&gt; &#123; v &#125; fn keys_key&lt;&#x27;a, &#x27;new&gt;(v: Keys&lt;&#x27;a, &amp;&#x27;static str, u8&gt;) -&gt; Keys&lt;&#x27;a, &amp;&#x27;new str, u8&gt; &#123; v &#125; fn keys_val&lt;&#x27;a, &#x27;new&gt;(v: Keys&lt;&#x27;a, u8, &amp;&#x27;static str&gt;) -&gt; Keys&lt;&#x27;a, u8, &amp;&#x27;new str&gt; &#123; v &#125; fn values_key&lt;&#x27;a, &#x27;new&gt;(v: Values&lt;&#x27;a, &amp;&#x27;static str, u8&gt;) -&gt; Values&lt;&#x27;a, &amp;&#x27;new str, u8&gt; &#123; v &#125; fn values_val&lt;&#x27;a, &#x27;new&gt;(v: Values&lt;&#x27;a, u8, &amp;&#x27;static str&gt;) -&gt; Values&lt;&#x27;a, u8, &amp;&#x27;new str&gt; &#123; v &#125; fn drain&lt;&#x27;new&gt;( d: Drain&lt;&#x27;static, &amp;&#x27;static str, &amp;&#x27;static str&gt;, ) -&gt; Drain&lt;&#x27;new, &amp;&#x27;new str, &amp;&#x27;new str&gt; &#123; d &#125;&#125;","tags":[null]},{"path":"/game/life-game/pkg/package.json","content":"{\"name\":\"rust-game-booiris\",\"collaborators\":[\"booiris \"],\"version\":\"0.1.0\",\"files\":[\"rust_game_booiris_bg.wasm\",\"rust_game_booiris.js\",\"rust_game_booiris.d.ts\"],\"module\":\"rust_game_booiris.js\",\"types\":\"rust_game_booiris.d.ts\",\"sideEffects\":false}"},{"path":"/game/life-game/pkg/README.html","content":"wasm-pack-template A template for kick starting a Rust and WebAssembly project using wasm-pack. Tutorial | Chat Built with ğŸ¦€ğŸ•¸ by The Rust and WebAssembly Working Group About ğŸ“š Read this template tutorial! ğŸ“š This template is designed for compiling Rust libraries into WebAssembly and publishing the resulting package to NPM. Be sure to check out other wasm-pack tutorials online for other templates and usages of wasm-pack. ğŸš´ Usage ğŸ‘ Use cargo generate to Clone this Template Learn more about cargo generate here. 12cargo generate --git https://github.com/rustwasm/wasm-pack-template.git --name my-projectcd my-project ğŸ› ï¸ Build with wasm-pack build 1wasm-pack build ğŸ”¬ Test in Headless Browsers with wasm-pack test 1wasm-pack test --headless --firefox ğŸ Publish to NPM with wasm-pack publish 1wasm-pack publish ğŸ”‹ Batteries Included wasm-bindgen for communicating between WebAssembly and JavaScript. console_error_panic_hook for logging panic messages to the developer console. wee_alloc, an allocator optimized for small code size. LICENSE-APACHE and LICENSE-MIT: most Rust projects are licensed this way, so these are included for you License Licensed under either of Apache License, Version 2.0, (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0) MIT license (LICENSE-MIT or http://opensource.org/licenses/MIT) at your option. Contribution Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions."},{"path":"/game/life-game/pkg/rust_game_booiris.js","content":"let wasm; const heap = new Array(32).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 36) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); let cachedUint8Memory0 = new Uint8Array(); function getUint8Memory0() { if (cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } let WASM_VECTOR_LEN = 0; const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } let cachedInt32Memory0 = new Int32Array(); function getInt32Memory0() { if (cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } function notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; } /** */ export const Cell = Object.freeze({ Dead:0,\"0\":\"Dead\",Alive:1,\"1\":\"Alive\", }); /** */ export class Universe { static __wrap(ptr) { const obj = Object.create(Universe.prototype); obj.ptr = ptr; return obj; } __destroy_into_raw() { const ptr = this.ptr; this.ptr = 0; return ptr; } free() { const ptr = this.__destroy_into_raw(); wasm.__wbg_universe_free(ptr); } /** */ tick() { wasm.universe_tick(this.ptr); } /** * @returns {Universe} */ static new() { const ret = wasm.universe_new(); return Universe.__wrap(ret); } /** * @returns {number} */ width() { const ret = wasm.universe_width(this.ptr); return ret >>> 0; } /** * @returns {number} */ height() { const ret = wasm.universe_height(this.ptr); return ret >>> 0; } /** * @param {number} width */ set_width(width) { wasm.universe_set_width(this.ptr, width); } /** * @param {number} height */ set_height(height) { wasm.universe_set_height(this.ptr, height); } /** * @returns {number} */ cells() { const ret = wasm.universe_cells(this.ptr); return ret; } /** * @param {number} row * @param {number} column */ toggle_cell(row, column) { wasm.universe_toggle_cell(this.ptr, row, column); } /** */ restart() { wasm.universe_restart(this.ptr); } } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbg_random_656f2ae924b2540e = typeof Math.random == 'function' ? Math.random : notDefined('Math.random'); imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedInt32Memory0 = new Int32Array(); cachedUint8Memory0 = new Uint8Array(); return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('rust_game_booiris_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init; export { wasm }"},{"path":"/game/push-box/pkg/README.html","content":"wasm-pack-template A template for kick starting a Rust and WebAssembly project using wasm-pack. Tutorial | Chat Built with ğŸ¦€ğŸ•¸ by The Rust and WebAssembly Working Group About ğŸ“š Read this template tutorial! ğŸ“š This template is designed for compiling Rust libraries into WebAssembly and publishing the resulting package to NPM. Be sure to check out other wasm-pack tutorials online for other templates and usages of wasm-pack. ğŸš´ Usage ğŸ‘ Use cargo generate to Clone this Template Learn more about cargo generate here. 12cargo generate --git https://github.com/rustwasm/wasm-pack-template.git --name my-projectcd my-project ğŸ› ï¸ Build with wasm-pack build 1wasm-pack build ğŸ”¬ Test in Headless Browsers with wasm-pack test 1wasm-pack test --headless --firefox ğŸ Publish to NPM with wasm-pack publish 1wasm-pack publish ğŸ”‹ Batteries Included wasm-bindgen for communicating between WebAssembly and JavaScript. console_error_panic_hook for logging panic messages to the developer console. wee_alloc, an allocator optimized for small code size. LICENSE-APACHE and LICENSE-MIT: most Rust projects are licensed this way, so these are included for you License Licensed under either of Apache License, Version 2.0, (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0) MIT license (LICENSE-MIT or http://opensource.org/licenses/MIT) at your option. Contribution Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions."},{"path":"/game/push-box/pkg/package.json","content":"{\"name\":\"push-box\",\"collaborators\":[\"booiris \"],\"version\":\"0.1.0\",\"files\":[\"push_box_bg.wasm\",\"push_box.js\",\"push_box.d.ts\"],\"module\":\"push_box.js\",\"types\":\"push_box.d.ts\",\"sideEffects\":false}"},{"path":"/game/push-box/pkg/rust_game_booiris.js","content":"export { wasm }"},{"path":"/game/push-box/pkg/push_box.js","content":"let wasm; const heap = new Array(32).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 36) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); let cachedUint8Memory0 = new Uint8Array(); function getUint8Memory0() { if (cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } let WASM_VECTOR_LEN = 0; const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } let cachedInt32Memory0 = new Int32Array(); function getInt32Memory0() { if (cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } function handleError(f, args) { try { return f.apply(this, args); } catch (e) { wasm.__wbindgen_exn_store(addHeapObject(e)); } } function getArrayU8FromWasm0(ptr, len) { return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len); } /** */ export const Cell = Object.freeze({ Empty:0,\"0\":\"Empty\",Person:1,\"1\":\"Person\",Key:2,\"2\":\"Key\",Aim:3,\"3\":\"Aim\",Wall:4,\"4\":\"Wall\", }); /** */ export class Game { static __wrap(ptr) { const obj = Object.create(Game.prototype); obj.ptr = ptr; return obj; } __destroy_into_raw() { const ptr = this.ptr; this.ptr = 0; return ptr; } free() { const ptr = this.__destroy_into_raw(); wasm.__wbg_game_free(ptr); } /** */ tick() { wasm.game_tick(this.ptr); } /** * @returns {Game} */ static new() { const ret = wasm.game_new(); return Game.__wrap(ret); } /** * @returns {number} */ width() { const ret = wasm.game_width(this.ptr); return ret >>> 0; } /** * @returns {number} */ height() { const ret = wasm.game_height(this.ptr); return ret >>> 0; } /** * @returns {number} */ room() { const ret = wasm.game_room(this.ptr); return ret; } /** * @returns {boolean} */ game_over() { const ret = wasm.game_game_over(this.ptr); return ret !== 0; } /** */ restart() { wasm.game_restart(this.ptr); } /** * @param {boolean} v */ set_is_log(v) { wasm.game_set_is_log(this.ptr, v); } } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbindgen_string_new = function(arg0, arg1) { const ret = getStringFromWasm0(arg0, arg1); return addHeapObject(ret); }; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_log_4b5638ad60bdc54a = function(arg0) { console.log(getObject(arg0)); }; imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) { getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2)); }; imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) { getObject(arg0).getRandomValues(getObject(arg1)); }; imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) { const ret = getObject(arg0).crypto; return addHeapObject(ret); }; imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) { const ret = getObject(arg0).msCrypto; return addHeapObject(ret); }; imports.wbg.__wbindgen_is_undefined = function(arg0) { const ret = getObject(arg0) === undefined; return ret; }; imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) { const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) { const ret = getObject(arg0).getRandomValues; return addHeapObject(ret); }; imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() { const ret = module; return addHeapObject(ret); }; imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) { const ret = getObject(arg0).buffer; return addHeapObject(ret); }; imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) { const ret = new Uint8Array(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) { getObject(arg0).set(getObject(arg1), arg2 >>> 0); }; imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) { const ret = new Uint8Array(arg0 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) { const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbindgen_memory = function() { const ret = wasm.memory; return addHeapObject(ret); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedInt32Memory0 = new Int32Array(); cachedUint8Memory0 = new Uint8Array(); return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('push_box_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init; export { wasm }"}]